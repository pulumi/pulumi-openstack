// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Manages a V2 VM instance resource within OpenStack.
 *
 * > **Note:** All arguments including the instance admin password will be stored
 * in the raw state as plain-text. Read more about sensitive data in
 * state.
 *
 * ## Example Usage
 *
 * ### Basic Instance
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const basic = new openstack.compute.Instance("basic", {
 *     name: "basic",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     metadata: {
 *         "this": "that",
 *     },
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * ```
 *
 * ### Instance With Attached Volume
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const myvol = new openstack.blockstorage.Volume("myvol", {
 *     name: "myvol",
 *     size: 1,
 * });
 * const myinstance = new openstack.compute.Instance("myinstance", {
 *     name: "myinstance",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * const attached = new openstack.compute.VolumeAttach("attached", {
 *     instanceId: myinstance.id,
 *     volumeId: myvol.id,
 * });
 * ```
 *
 * ### Boot From Volume
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const boot_from_volume = new openstack.compute.Instance("boot-from-volume", {
 *     name: "boot-from-volume",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [{
 *         uuid: "<image-id>",
 *         sourceType: "image",
 *         volumeSize: 5,
 *         bootIndex: 0,
 *         destinationType: "volume",
 *         deleteOnTermination: true,
 *     }],
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * ```
 *
 * ### Boot From an Existing Volume
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const myvol = new openstack.blockstorage.Volume("myvol", {
 *     name: "myvol",
 *     size: 5,
 *     imageId: "<image-id>",
 * });
 * const boot_from_volume = new openstack.compute.Instance("boot-from-volume", {
 *     name: "bootfromvolume",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [{
 *         uuid: myvol.id,
 *         sourceType: "volume",
 *         bootIndex: 0,
 *         destinationType: "volume",
 *         deleteOnTermination: true,
 *     }],
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * ```
 *
 * ### Boot Instance, Create Volume, and Attach Volume as a Block Device
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const instance1 = new openstack.compute.Instance("instance_1", {
 *     name: "instance_1",
 *     imageId: "<image-id>",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [
 *         {
 *             uuid: "<image-id>",
 *             sourceType: "image",
 *             destinationType: "local",
 *             bootIndex: 0,
 *             deleteOnTermination: true,
 *         },
 *         {
 *             sourceType: "blank",
 *             destinationType: "volume",
 *             volumeSize: 1,
 *             bootIndex: 1,
 *             deleteOnTermination: true,
 *         },
 *     ],
 * });
 * ```
 *
 * ### Boot Instance and Attach Existing Volume as a Block Device
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const volume1 = new openstack.blockstorage.Volume("volume_1", {
 *     name: "volume_1",
 *     size: 1,
 * });
 * const instance1 = new openstack.compute.Instance("instance_1", {
 *     name: "instance_1",
 *     imageId: "<image-id>",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [
 *         {
 *             uuid: "<image-id>",
 *             sourceType: "image",
 *             destinationType: "local",
 *             bootIndex: 0,
 *             deleteOnTermination: true,
 *         },
 *         {
 *             uuid: volume1.id,
 *             sourceType: "volume",
 *             destinationType: "volume",
 *             bootIndex: 1,
 *             deleteOnTermination: true,
 *         },
 *     ],
 * });
 * ```
 *
 * ### Instance With Multiple Networks
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const myip = new openstack.networking.FloatingIp("myip", {pool: "my_pool"});
 * const multi_net = new openstack.compute.Instance("multi-net", {
 *     name: "multi-net",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     networks: [
 *         {
 *             name: "my_first_network",
 *         },
 *         {
 *             name: "my_second_network",
 *         },
 *     ],
 * });
 * const vm_port = pulumi.all([multi_net.id, multi_net.networks]).apply(([id, networks]) => openstack.networking.getPortOutput({
 *     deviceId: id,
 *     networkId: networks[1].uuid,
 * }));
 * const fipVm = new openstack.networking.FloatingIpAssociate("fip_vm", {
 *     floatingIp: myip.address,
 *     portId: vm_port.apply(vm_port => vm_port.id),
 * });
 * ```
 *
 * ### Instance With Personality
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const personality = new openstack.compute.Instance("personality", {
 *     name: "personality",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     personalities: [{
 *         file: "/path/to/file/on/instance.txt",
 *         content: "contents of file",
 *     }],
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * ```
 *
 * ### Instance with Multiple Ephemeral Disks
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const multi_eph = new openstack.compute.Instance("multi-eph", {
 *     name: "multi_eph",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [
 *         {
 *             bootIndex: 0,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "image",
 *             uuid: "<image-id>",
 *         },
 *         {
 *             bootIndex: -1,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "blank",
 *             volumeSize: 1,
 *             guestFormat: "ext4",
 *         },
 *         {
 *             bootIndex: -1,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "blank",
 *             volumeSize: 1,
 *         },
 *     ],
 * });
 * ```
 *
 * ### Instance with Boot Disk and Swap Disk
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const flavor_with_swap = new openstack.compute.Flavor("flavor-with-swap", {
 *     name: "flavor-with-swap",
 *     ram: 8096,
 *     vcpus: 2,
 *     disk: 20,
 *     swap: 4096,
 * });
 * const vm_swap = new openstack.compute.Instance("vm-swap", {
 *     name: "vm_swap",
 *     flavorId: flavor_with_swap.id,
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     blockDevices: [
 *         {
 *             bootIndex: 0,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "image",
 *             uuid: "<image-id>",
 *         },
 *         {
 *             bootIndex: -1,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "blank",
 *             guestFormat: "swap",
 *             volumeSize: 4,
 *         },
 *     ],
 * });
 * ```
 *
 * ### Instance with User Data (cloud-init)
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const instance1 = new openstack.compute.Instance("instance_1", {
 *     name: "basic",
 *     imageId: "ad091b52-742f-469e-8f3c-fd81cadf0743",
 *     flavorId: "3",
 *     keyPair: "my_key_pair_name",
 *     securityGroups: ["default"],
 *     userData: `#cloud-config
 * hostname: instance_1.example.com
 * fqdn: instance_1.example.com`,
 *     networks: [{
 *         name: "my_network",
 *     }],
 * });
 * ```
 *
 * `userData` can come from a variety of sources: inline, read in from the `file`
 * function, or the `templateCloudinitConfig` resource.
 *
 * ## Notes
 *
 * ### Multiple Ephemeral Disks
 *
 * It's possible to specify multiple `blockDevice` entries to create an instance
 * with multiple ephemeral (local) disks. In order to create multiple ephemeral
 * disks, the sum of the total amount of ephemeral space must be less than or
 * equal to what the chosen flavor supports.
 *
 * The following example shows how to create an instance with multiple ephemeral
 * disks:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const foo = new openstack.compute.Instance("foo", {
 *     name: "terraform-test",
 *     securityGroups: ["default"],
 *     blockDevices: [
 *         {
 *             bootIndex: 0,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "image",
 *             uuid: "<image uuid>",
 *         },
 *         {
 *             bootIndex: -1,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "blank",
 *             volumeSize: 1,
 *         },
 *         {
 *             bootIndex: -1,
 *             deleteOnTermination: true,
 *             destinationType: "local",
 *             sourceType: "blank",
 *             volumeSize: 1,
 *         },
 *     ],
 * });
 * ```
 *
 * ### Instances and Security Groups
 *
 * When referencing a security group resource in an instance resource, always
 * use the _name_ of the security group. If you specify the ID of the security
 * group, Terraform will remove and reapply the security group upon each call.
 * This is because the OpenStack Compute API returns the names of the associated
 * security groups and not their IDs.
 *
 * Note the following example:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const sg1 = new openstack.networking.SecGroup("sg_1", {name: "sg_1"});
 * const foo = new openstack.compute.Instance("foo", {
 *     name: "terraform-test",
 *     securityGroups: [sg1.name],
 * });
 * ```
 *
 * ### Instances and Ports
 *
 * Neutron Ports are a great feature and provide a lot of functionality. However,
 * there are some notes to be aware of when mixing Instances and Ports:
 *
 * * In OpenStack environments prior to the Kilo release, deleting or recreating
 * an Instance will cause the Instance's Port(s) to be deleted. One way of working
 * around this is to taint any Port(s) used in Instances which are to be recreated.
 * See [here](https://review.openstack.org/#/c/126309/) for further information.
 *
 * * When attaching an Instance to one or more networks using Ports, place the
 * security groups on the Port and not the Instance. If you place the security
 * groups on the Instance, the security groups will not be applied upon creation,
 * but they will be applied upon a refresh. This is a known OpenStack bug.
 *
 * * Network IP information is not available within an instance for networks that
 * are attached with Ports. This is mostly due to the flexibility Neutron Ports
 * provide when it comes to IP addresses. For example, a Neutron Port can have
 * multiple Fixed IP addresses associated with it. It's not possible to know which
 * single IP address the user would want returned to the Instance's state
 * information. Therefore, in order for a Provisioner to connect to an Instance
 * via it's network Port, customize the `connection` information:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const port1 = new openstack.networking.Port("port_1", {
 *     name: "port_1",
 *     adminStateUp: true,
 *     networkId: "0a1d0a27-cffa-4de3-92c5-9d3fd3f2e74d",
 *     securityGroupIds: [
 *         "2f02d20a-8dca-49b7-b26f-b6ce9fddaf4f",
 *         "ca1e5ed7-dae8-4605-987b-fadaeeb30461",
 *     ],
 * });
 * const instance1 = new openstack.compute.Instance("instance_1", {
 *     name: "instance_1",
 *     networks: [{
 *         port: port1.id,
 *     }],
 * });
 * ```
 *
 * ### Instances and Networks
 *
 * Instances almost always require a network. Here are some notes to be aware of
 * with how Instances and Networks relate:
 *
 * * In scenarios where you only have one network available, you can create an
 * instance without specifying a `network` block. OpenStack will automatically
 * launch the instance on this network.
 *
 * * If you have access to more than one network, you will need to specify a network
 * with a `network` block. Not specifying a network will result in the following
 * error:
 *
 * * If you intend to use the `openstack.compute.InterfaceAttach` resource,
 *   you still need to make sure one of the above points is satisfied. An instance
 *   cannot be created without a valid network configuration even if you intend to
 *   use `openstack.compute.InterfaceAttach` after the instance has been created.
 *
 * ## Importing instances
 *
 * Importing instances can be tricky, since the nova api does not offer all
 * information provided at creation time for later retrieval.
 * Network interface attachment order, and number and sizes of ephemeral
 * disks are examples of this.
 *
 * ### Importing basic instance
 * Assume you want to import an instance with one ephemeral root disk,
 * and one network interface.
 *
 * Your configuration would look like the following:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const basicInstance = new openstack.compute.Instance("basic_instance", {
 *     name: "basic",
 *     flavorId: "<flavor_id>",
 *     keyPair: "<keyname>",
 *     securityGroups: ["default"],
 *     imageId: "<image_id>",
 *     networks: [{
 *         name: "<network_name>",
 *     }],
 * });
 * ```
 * Then you execute
 *
 * ### Importing an instance with multiple emphemeral disks
 *
 * The importer cannot read the emphemeral disk configuration
 * of an instance, so just specify imageId as in the configuration
 * of the basic instance example.
 *
 * ### Importing instance with multiple network interfaces.
 *
 * Nova returns the network interfaces grouped by network, thus not in creation
 * order.
 * That means that if you have multiple network interfaces you must take
 * care of the order of networks in your configuration.
 *
 * As example we want to import an instance with one ephemeral root disk,
 * and 3 network interfaces.
 *
 * Examples
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const boot_from_volume = new openstack.compute.Instance("boot-from-volume", {
 *     name: "boot-from-volume",
 *     flavorId: "<flavor_id",
 *     keyPair: "<keyname>",
 *     imageId: "<image_id>",
 *     securityGroups: ["default"],
 *     networks: [
 *         {
 *             name: "<network1>",
 *         },
 *         {
 *             name: "<network2>",
 *         },
 *         {
 *             name: "<network1>",
 *             fixedIpV4: "<fixed_ip_v4>",
 *         },
 *     ],
 * });
 * ```
 *
 * In the above configuration the networks are out of order compared to what nova
 * and thus the import code returns, which means the plan will not
 * be empty after import.
 *
 * So either with care check the plan and modify configuration, or read the
 * network order in the state file after import and modify your
 * configuration accordingly.
 *
 *  * A note on ports. If you have created a neutron port independent of an
 *     instance, then the import code has no way to detect that the port is created
 *     idenpendently, and therefore on deletion of imported instances you might have
 *     port resources in your project, which you expected to be created by the
 *     instance and thus to also be deleted with the instance.
 *
 * ### Importing instances with multiple block storage volumes.
 *
 * We have an instance with two block storage volumes, one bootable and one
 * non-bootable.
 * Note that we only configure the bootable device as block_device.
 * The other volumes can be specified as `openstack.blockstorage.Volume`
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as openstack from "@pulumi/openstack";
 *
 * const instance2 = new openstack.compute.Instance("instance_2", {
 *     name: "instance_2",
 *     imageId: "<image_id>",
 *     flavorId: "<flavor_id>",
 *     keyPair: "<keyname>",
 *     securityGroups: ["default"],
 *     blockDevices: [{
 *         uuid: "<image_id>",
 *         sourceType: "image",
 *         destinationType: "volume",
 *         bootIndex: 0,
 *         deleteOnTermination: true,
 *     }],
 *     networks: [{
 *         name: "<network_name>",
 *     }],
 * });
 * const volume1 = new openstack.blockstorage.Volume("volume_1", {
 *     size: 1,
 *     name: "<vol_name>",
 * });
 * const va1 = new openstack.compute.VolumeAttach("va_1", {
 *     volumeId: volume1.id,
 *     instanceId: instance2.id,
 * });
 * ```
 * To import the instance outlined in the above configuration
 * do the following:
 *
 * * A note on block storage volumes, the importer does not read
 *   deleteOnTermination flag, and always assumes true. If you
 *   import an instance created with deleteOnTermination false,
 *   you end up with "orphaned" volumes after destruction of
 *   instances.
 */
export class Instance extends pulumi.CustomResource {
    /**
     * Get an existing Instance resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: InstanceState, opts?: pulumi.CustomResourceOptions): Instance {
        return new Instance(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'openstack:compute/instance:Instance';

    /**
     * Returns true if the given object is an instance of Instance.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Instance {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Instance.__pulumiType;
    }

    /**
     * The first detected Fixed IPv4 address.
     */
    declare public /*out*/ readonly accessIpV4: pulumi.Output<string>;
    /**
     * The first detected Fixed IPv6 address.
     */
    declare public /*out*/ readonly accessIpV6: pulumi.Output<string>;
    /**
     * The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     */
    declare public readonly adminPass: pulumi.Output<string | undefined>;
    /**
     * Contains all instance metadata, even metadata not set
     * by Terraform.
     */
    declare public /*out*/ readonly allMetadata: pulumi.Output<{[key: string]: string}>;
    /**
     * The collection of tags assigned on the instance, which have
     * been explicitly and implicitly added.
     */
    declare public /*out*/ readonly allTags: pulumi.Output<string[]>;
    /**
     * The availability zone in which to create
     * the server. Conflicts with `availabilityZoneHints`. Changing this creates
     * a new server.
     */
    declare public readonly availabilityZone: pulumi.Output<string>;
    /**
     * The availability zone in which to
     * create the server. This argument is preferred to `availabilityZone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availabilityZone`. Changing this creates a
     * new server.
     */
    declare public readonly availabilityZoneHints: pulumi.Output<string | undefined>;
    /**
     * Configuration of block devices. The blockDevice
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     */
    declare public readonly blockDevices: pulumi.Output<outputs.compute.InstanceBlockDevice[] | undefined>;
    /**
     * Whether to use the configDrive feature to
     * configure the instance. Changing this creates a new server.
     */
    declare public readonly configDrive: pulumi.Output<boolean | undefined>;
    /**
     * The creation time of the instance.
     */
    declare public /*out*/ readonly created: pulumi.Output<string>;
    /**
     * The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     */
    declare public readonly flavorId: pulumi.Output<string>;
    /**
     * The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     */
    declare public readonly flavorName: pulumi.Output<string>;
    /**
     * Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     */
    declare public readonly forceDelete: pulumi.Output<boolean | undefined>;
    /**
     * Specifies the exact hypervisor hostname on
     * which to create the instance. When provided, this parameter is included in
     * the request to Nova, directing the scheduler to launch the instance on the
     * specified host. Note: This option requires administrative privileges and a
     * Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
     * this value forces a new instance to be created.
     */
    declare public readonly hypervisorHostname: pulumi.Output<string>;
    /**
     * (Optional; Required if `imageName` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     */
    declare public readonly imageId: pulumi.Output<string>;
    /**
     * (Optional; Required if `imageId` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     */
    declare public readonly imageName: pulumi.Output<string>;
    /**
     * The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant's account.
     * Changing this creates a new server.
     */
    declare public readonly keyPair: pulumi.Output<string | undefined>;
    /**
     * Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     */
    declare public readonly metadata: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * A unique name for the resource.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Special string for `network` option to create
     * the server. `networkMode` can be `"auto"` or `"none"`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     */
    declare public readonly networkMode: pulumi.Output<string | undefined>;
    /**
     * An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     */
    declare public readonly networks: pulumi.Output<outputs.compute.InstanceNetwork[]>;
    /**
     * Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure is
     * described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
     * the existing server.
     */
    declare public readonly personalities: pulumi.Output<outputs.compute.InstancePersonality[] | undefined>;
    /**
     * Provide the VM state. Only 'active', 'shutoff', 'paused'
     * and 'shelved_offloaded' are supported values.
     * *Note*: If the initial powerState is the shutoff or paused
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     */
    declare public readonly powerState: pulumi.Output<string | undefined>;
    /**
     * The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     */
    declare public readonly region: pulumi.Output<string>;
    /**
     * Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     */
    declare public readonly schedulerHints: pulumi.Output<outputs.compute.InstanceSchedulerHint[] | undefined>;
    /**
     * An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     */
    declare public readonly securityGroups: pulumi.Output<string[]>;
    /**
     * Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn't stop within timeout, it will be destroyed anyway.
     */
    declare public readonly stopBeforeDestroy: pulumi.Output<boolean | undefined>;
    /**
     * A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * The time when the instance was last updated.
     */
    declare public /*out*/ readonly updated: pulumi.Output<string>;
    /**
     * The user data to provide when launching the instance.
     * Changing this creates a new server.
     */
    declare public readonly userData: pulumi.Output<string | undefined>;
    /**
     * Map of additional vendor-specific options.
     * Supported options are described below.
     */
    declare public readonly vendorOptions: pulumi.Output<outputs.compute.InstanceVendorOptions | undefined>;

    /**
     * Create a Instance resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: InstanceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: InstanceArgs | InstanceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as InstanceState | undefined;
            resourceInputs["accessIpV4"] = state?.accessIpV4;
            resourceInputs["accessIpV6"] = state?.accessIpV6;
            resourceInputs["adminPass"] = state?.adminPass;
            resourceInputs["allMetadata"] = state?.allMetadata;
            resourceInputs["allTags"] = state?.allTags;
            resourceInputs["availabilityZone"] = state?.availabilityZone;
            resourceInputs["availabilityZoneHints"] = state?.availabilityZoneHints;
            resourceInputs["blockDevices"] = state?.blockDevices;
            resourceInputs["configDrive"] = state?.configDrive;
            resourceInputs["created"] = state?.created;
            resourceInputs["flavorId"] = state?.flavorId;
            resourceInputs["flavorName"] = state?.flavorName;
            resourceInputs["forceDelete"] = state?.forceDelete;
            resourceInputs["hypervisorHostname"] = state?.hypervisorHostname;
            resourceInputs["imageId"] = state?.imageId;
            resourceInputs["imageName"] = state?.imageName;
            resourceInputs["keyPair"] = state?.keyPair;
            resourceInputs["metadata"] = state?.metadata;
            resourceInputs["name"] = state?.name;
            resourceInputs["networkMode"] = state?.networkMode;
            resourceInputs["networks"] = state?.networks;
            resourceInputs["personalities"] = state?.personalities;
            resourceInputs["powerState"] = state?.powerState;
            resourceInputs["region"] = state?.region;
            resourceInputs["schedulerHints"] = state?.schedulerHints;
            resourceInputs["securityGroups"] = state?.securityGroups;
            resourceInputs["stopBeforeDestroy"] = state?.stopBeforeDestroy;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["updated"] = state?.updated;
            resourceInputs["userData"] = state?.userData;
            resourceInputs["vendorOptions"] = state?.vendorOptions;
        } else {
            const args = argsOrState as InstanceArgs | undefined;
            resourceInputs["adminPass"] = args?.adminPass ? pulumi.secret(args.adminPass) : undefined;
            resourceInputs["availabilityZone"] = args?.availabilityZone;
            resourceInputs["availabilityZoneHints"] = args?.availabilityZoneHints;
            resourceInputs["blockDevices"] = args?.blockDevices;
            resourceInputs["configDrive"] = args?.configDrive;
            resourceInputs["flavorId"] = args?.flavorId;
            resourceInputs["flavorName"] = args?.flavorName;
            resourceInputs["forceDelete"] = args?.forceDelete;
            resourceInputs["hypervisorHostname"] = args?.hypervisorHostname;
            resourceInputs["imageId"] = args?.imageId;
            resourceInputs["imageName"] = args?.imageName;
            resourceInputs["keyPair"] = args?.keyPair;
            resourceInputs["metadata"] = args?.metadata;
            resourceInputs["name"] = args?.name;
            resourceInputs["networkMode"] = args?.networkMode;
            resourceInputs["networks"] = args?.networks;
            resourceInputs["personalities"] = args?.personalities;
            resourceInputs["powerState"] = args?.powerState;
            resourceInputs["region"] = args?.region;
            resourceInputs["schedulerHints"] = args?.schedulerHints;
            resourceInputs["securityGroups"] = args?.securityGroups;
            resourceInputs["stopBeforeDestroy"] = args?.stopBeforeDestroy;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["userData"] = args?.userData;
            resourceInputs["vendorOptions"] = args?.vendorOptions;
            resourceInputs["accessIpV4"] = undefined /*out*/;
            resourceInputs["accessIpV6"] = undefined /*out*/;
            resourceInputs["allMetadata"] = undefined /*out*/;
            resourceInputs["allTags"] = undefined /*out*/;
            resourceInputs["created"] = undefined /*out*/;
            resourceInputs["updated"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["adminPass"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Instance.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Instance resources.
 */
export interface InstanceState {
    /**
     * The first detected Fixed IPv4 address.
     */
    accessIpV4?: pulumi.Input<string>;
    /**
     * The first detected Fixed IPv6 address.
     */
    accessIpV6?: pulumi.Input<string>;
    /**
     * The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     */
    adminPass?: pulumi.Input<string>;
    /**
     * Contains all instance metadata, even metadata not set
     * by Terraform.
     */
    allMetadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The collection of tags assigned on the instance, which have
     * been explicitly and implicitly added.
     */
    allTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The availability zone in which to create
     * the server. Conflicts with `availabilityZoneHints`. Changing this creates
     * a new server.
     */
    availabilityZone?: pulumi.Input<string>;
    /**
     * The availability zone in which to
     * create the server. This argument is preferred to `availabilityZone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availabilityZone`. Changing this creates a
     * new server.
     */
    availabilityZoneHints?: pulumi.Input<string>;
    /**
     * Configuration of block devices. The blockDevice
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     */
    blockDevices?: pulumi.Input<pulumi.Input<inputs.compute.InstanceBlockDevice>[]>;
    /**
     * Whether to use the configDrive feature to
     * configure the instance. Changing this creates a new server.
     */
    configDrive?: pulumi.Input<boolean>;
    /**
     * The creation time of the instance.
     */
    created?: pulumi.Input<string>;
    /**
     * The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     */
    flavorId?: pulumi.Input<string>;
    /**
     * The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     */
    flavorName?: pulumi.Input<string>;
    /**
     * Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Specifies the exact hypervisor hostname on
     * which to create the instance. When provided, this parameter is included in
     * the request to Nova, directing the scheduler to launch the instance on the
     * specified host. Note: This option requires administrative privileges and a
     * Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
     * this value forces a new instance to be created.
     */
    hypervisorHostname?: pulumi.Input<string>;
    /**
     * (Optional; Required if `imageName` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     */
    imageId?: pulumi.Input<string>;
    /**
     * (Optional; Required if `imageId` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     */
    imageName?: pulumi.Input<string>;
    /**
     * The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant's account.
     * Changing this creates a new server.
     */
    keyPair?: pulumi.Input<string>;
    /**
     * Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     */
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A unique name for the resource.
     */
    name?: pulumi.Input<string>;
    /**
     * Special string for `network` option to create
     * the server. `networkMode` can be `"auto"` or `"none"`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     */
    networkMode?: pulumi.Input<string>;
    /**
     * An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     */
    networks?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetwork>[]>;
    /**
     * Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure is
     * described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
     * the existing server.
     */
    personalities?: pulumi.Input<pulumi.Input<inputs.compute.InstancePersonality>[]>;
    /**
     * Provide the VM state. Only 'active', 'shutoff', 'paused'
     * and 'shelved_offloaded' are supported values.
     * *Note*: If the initial powerState is the shutoff or paused
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     */
    powerState?: pulumi.Input<string>;
    /**
     * The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     */
    region?: pulumi.Input<string>;
    /**
     * Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     */
    schedulerHints?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulerHint>[]>;
    /**
     * An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     */
    securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn't stop within timeout, it will be destroyed anyway.
     */
    stopBeforeDestroy?: pulumi.Input<boolean>;
    /**
     * A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The time when the instance was last updated.
     */
    updated?: pulumi.Input<string>;
    /**
     * The user data to provide when launching the instance.
     * Changing this creates a new server.
     */
    userData?: pulumi.Input<string>;
    /**
     * Map of additional vendor-specific options.
     * Supported options are described below.
     */
    vendorOptions?: pulumi.Input<inputs.compute.InstanceVendorOptions>;
}

/**
 * The set of arguments for constructing a Instance resource.
 */
export interface InstanceArgs {
    /**
     * The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     */
    adminPass?: pulumi.Input<string>;
    /**
     * The availability zone in which to create
     * the server. Conflicts with `availabilityZoneHints`. Changing this creates
     * a new server.
     */
    availabilityZone?: pulumi.Input<string>;
    /**
     * The availability zone in which to
     * create the server. This argument is preferred to `availabilityZone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availabilityZone`. Changing this creates a
     * new server.
     */
    availabilityZoneHints?: pulumi.Input<string>;
    /**
     * Configuration of block devices. The blockDevice
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     */
    blockDevices?: pulumi.Input<pulumi.Input<inputs.compute.InstanceBlockDevice>[]>;
    /**
     * Whether to use the configDrive feature to
     * configure the instance. Changing this creates a new server.
     */
    configDrive?: pulumi.Input<boolean>;
    /**
     * The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     */
    flavorId?: pulumi.Input<string>;
    /**
     * The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     */
    flavorName?: pulumi.Input<string>;
    /**
     * Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     */
    forceDelete?: pulumi.Input<boolean>;
    /**
     * Specifies the exact hypervisor hostname on
     * which to create the instance. When provided, this parameter is included in
     * the request to Nova, directing the scheduler to launch the instance on the
     * specified host. Note: This option requires administrative privileges and a
     * Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
     * this value forces a new instance to be created.
     */
    hypervisorHostname?: pulumi.Input<string>;
    /**
     * (Optional; Required if `imageName` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     */
    imageId?: pulumi.Input<string>;
    /**
     * (Optional; Required if `imageId` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     */
    imageName?: pulumi.Input<string>;
    /**
     * The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant's account.
     * Changing this creates a new server.
     */
    keyPair?: pulumi.Input<string>;
    /**
     * Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     */
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A unique name for the resource.
     */
    name?: pulumi.Input<string>;
    /**
     * Special string for `network` option to create
     * the server. `networkMode` can be `"auto"` or `"none"`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     */
    networkMode?: pulumi.Input<string>;
    /**
     * An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     */
    networks?: pulumi.Input<pulumi.Input<inputs.compute.InstanceNetwork>[]>;
    /**
     * Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure is
     * described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
     * the existing server.
     */
    personalities?: pulumi.Input<pulumi.Input<inputs.compute.InstancePersonality>[]>;
    /**
     * Provide the VM state. Only 'active', 'shutoff', 'paused'
     * and 'shelved_offloaded' are supported values.
     * *Note*: If the initial powerState is the shutoff or paused
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     */
    powerState?: pulumi.Input<string>;
    /**
     * The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     */
    region?: pulumi.Input<string>;
    /**
     * Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     */
    schedulerHints?: pulumi.Input<pulumi.Input<inputs.compute.InstanceSchedulerHint>[]>;
    /**
     * An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     */
    securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn't stop within timeout, it will be destroyed anyway.
     */
    stopBeforeDestroy?: pulumi.Input<boolean>;
    /**
     * A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The user data to provide when launching the instance.
     * Changing this creates a new server.
     */
    userData?: pulumi.Input<string>;
    /**
     * Map of additional vendor-specific options.
     * Supported options are described below.
     */
    vendorOptions?: pulumi.Input<inputs.compute.InstanceVendorOptions>;
}
