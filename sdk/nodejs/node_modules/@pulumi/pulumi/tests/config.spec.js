"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const index_1 = require("../index");
describe("config", () => {
    it("works, basically", () => {
        // Set up some config and then read them back as strings.
        index_1.runtime.setConfig("pkg:config:a", "foo");
        index_1.runtime.setConfig("pkg:config:bar", "b");
        index_1.runtime.setConfig("pkg:config:baz", "baz");
        index_1.runtime.setConfig("otherpkg:config:a", "babble");
        index_1.runtime.setConfig("otherpkg:config:nothere", "bazzle");
        const config = new index_1.Config("pkg:config");
        assert.strictEqual("foo", config.get("a"));
        assert.strictEqual("foo", config.require("a"));
        assert.strictEqual("b", config.get("bar"));
        assert.strictEqual("b", config.require("bar"));
        assert.strictEqual("baz", config.get("baz"));
        assert.strictEqual("baz", config.require("baz"));
        assert.strictEqual(undefined, config.get("nothere"));
        assert.throws(() => { config.require("missing"); });
    });
    it("does strongly typed too!", () => {
        // Set up some config and then read them back as typed things.
        index_1.runtime.setConfig("pkg:config:boolf", "false");
        index_1.runtime.setConfig("pkg:config:boolt", "true");
        index_1.runtime.setConfig("pkg:config:num", "42.333");
        index_1.runtime.setConfig("pkg:config:array", "[ 0, false, 2, \"foo\" ]");
        index_1.runtime.setConfig("pkg:config:struct", "{ \"foo\": \"bar\", \"mim\": [] }");
        const config = new index_1.Config("pkg:config");
        assert.strictEqual(false, config.getBoolean("boolf"));
        assert.strictEqual(false, config.requireBoolean("boolf"));
        assert.strictEqual(true, config.getBoolean("boolt"));
        assert.strictEqual(true, config.requireBoolean("boolt"));
        assert.strictEqual(undefined, config.getBoolean("boolmissing"));
        assert.strictEqual(42.333, config.getNumber("num"));
        assert.strictEqual(42.333, config.requireNumber("num"));
        assert.strictEqual(undefined, config.getNumber("nummissing"));
        assert.deepEqual([0, false, 2, "foo"], config.getObject("array"));
        assert.deepEqual([0, false, 2, "foo"], config.requireObject("array"));
        assert.deepEqual({ "foo": "bar", "mim": [] }, config.getObject("struct"));
        assert.deepEqual({ "foo": "bar", "mim": [] }, config.requireObject("struct"));
        assert.strictEqual(undefined, config.getObject("complexmissing"));
        // ensure requireX throws when missing:
        assert.throws(() => { config.requireBoolean("missing"); });
        assert.throws(() => { config.requireNumber("missing"); });
        assert.throws(() => { config.requireObject("missing"); });
        // ensure getX throws when the value is of the wrong type:
        assert.throws(() => { config.getBoolean("num"); });
        assert.throws(() => { config.getNumber("boolf"); });
    });
});
