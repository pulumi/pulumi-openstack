# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'BgpvpnPortAssociateV2RouteArgs',
    'BgpvpnPortAssociateV2RouteArgsDict',
    'TaasTapMirrorV2DirectionsArgs',
    'TaasTapMirrorV2DirectionsArgsDict',
]

MYPY = False

if not MYPY:
    class BgpvpnPortAssociateV2RouteArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Can be `prefix` or `bgpvpn`. For the `prefix` type, the
        CIDR prefix (v4 or v6) must be specified in the `prefix` key. For the
        `bgpvpn` type, the BGP VPN ID must be specified in the `bgpvpn_id` key.
        """
        bgpvpn_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the BGP VPN to be advertised. Required
        if `type` is `bgpvpn`. Conflicts with `prefix`.
        """
        local_pref: NotRequired[pulumi.Input[_builtins.int]]
        """
        The BGP LOCAL\\_PREF value of the routes that will
        be advertised.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR prefix (v4 or v6) to be advertised. Required
        if `type` is `prefix`. Conflicts with `bgpvpn_id`.
        """
elif False:
    BgpvpnPortAssociateV2RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BgpvpnPortAssociateV2RouteArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 bgpvpn_id: Optional[pulumi.Input[_builtins.str]] = None,
                 local_pref: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Can be `prefix` or `bgpvpn`. For the `prefix` type, the
               CIDR prefix (v4 or v6) must be specified in the `prefix` key. For the
               `bgpvpn` type, the BGP VPN ID must be specified in the `bgpvpn_id` key.
        :param pulumi.Input[_builtins.str] bgpvpn_id: The ID of the BGP VPN to be advertised. Required
               if `type` is `bgpvpn`. Conflicts with `prefix`.
        :param pulumi.Input[_builtins.int] local_pref: The BGP LOCAL\\_PREF value of the routes that will
               be advertised.
        :param pulumi.Input[_builtins.str] prefix: The CIDR prefix (v4 or v6) to be advertised. Required
               if `type` is `prefix`. Conflicts with `bgpvpn_id`.
        """
        pulumi.set(__self__, "type", type)
        if bgpvpn_id is not None:
            pulumi.set(__self__, "bgpvpn_id", bgpvpn_id)
        if local_pref is not None:
            pulumi.set(__self__, "local_pref", local_pref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Can be `prefix` or `bgpvpn`. For the `prefix` type, the
        CIDR prefix (v4 or v6) must be specified in the `prefix` key. For the
        `bgpvpn` type, the BGP VPN ID must be specified in the `bgpvpn_id` key.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="bgpvpnId")
    def bgpvpn_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the BGP VPN to be advertised. Required
        if `type` is `bgpvpn`. Conflicts with `prefix`.
        """
        return pulumi.get(self, "bgpvpn_id")

    @bgpvpn_id.setter
    def bgpvpn_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bgpvpn_id", value)

    @_builtins.property
    @pulumi.getter(name="localPref")
    def local_pref(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The BGP LOCAL\\_PREF value of the routes that will
        be advertised.
        """
        return pulumi.get(self, "local_pref")

    @local_pref.setter
    def local_pref(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_pref", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR prefix (v4 or v6) to be advertised. Required
        if `type` is `prefix`. Conflicts with `bgpvpn_id`.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class TaasTapMirrorV2DirectionsArgsDict(TypedDict):
        in_: NotRequired[pulumi.Input[_builtins.int]]
        """
        Declares ingress traffic to the port will be mirrored. The value
        is the identifier of the ERSPAN or GRE session between the source and destination,
        this must be unique within the project.
        """
        out: NotRequired[pulumi.Input[_builtins.int]]
        """
        Declares egress traffic will be mirrored. The value is the
        identifier of the ERSPAN or GRE session between the source and destination,
        this must be unique within the project.
        """
elif False:
    TaasTapMirrorV2DirectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaasTapMirrorV2DirectionsArgs:
    def __init__(__self__, *,
                 in_: Optional[pulumi.Input[_builtins.int]] = None,
                 out: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] in_: Declares ingress traffic to the port will be mirrored. The value
               is the identifier of the ERSPAN or GRE session between the source and destination,
               this must be unique within the project.
        :param pulumi.Input[_builtins.int] out: Declares egress traffic will be mirrored. The value is the
               identifier of the ERSPAN or GRE session between the source and destination,
               this must be unique within the project.
        """
        if in_ is not None:
            pulumi.set(__self__, "in_", in_)
        if out is not None:
            pulumi.set(__self__, "out", out)

    @_builtins.property
    @pulumi.getter(name="in")
    def in_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Declares ingress traffic to the port will be mirrored. The value
        is the identifier of the ERSPAN or GRE session between the source and destination,
        this must be unique within the project.
        """
        return pulumi.get(self, "in_")

    @in_.setter
    def in_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "in_", value)

    @_builtins.property
    @pulumi.getter
    def out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Declares egress traffic will be mirrored. The value is the
        identifier of the ERSPAN or GRE session between the source and destination,
        this must be unique within the project.
        """
        return pulumi.get(self, "out")

    @out.setter
    def out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "out", value)


