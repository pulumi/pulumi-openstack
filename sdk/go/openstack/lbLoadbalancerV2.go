// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package openstack

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a V2 loadbalancer resource within OpenStack.
//
// > **Note:** This resource has attributes that depend on octavia minor versions.
// Please ensure your Openstack cloud supports the required minor version.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := openstack.NewLbLoadbalancerV2(ctx, "lb_1", &openstack.LbLoadbalancerV2Args{
//				VipSubnetId: pulumi.String("d9415786-5f1a-428b-b35f-2f1523e146d2"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Load Balancer can be imported using the Load Balancer ID, e.g.:
//
// ```sh
// $ pulumi import openstack:index/lbLoadbalancerV2:LbLoadbalancerV2 loadbalancer_1 19bcfdc7-c521-4a7e-9459-6750bd16df76
// ```
type LbLoadbalancerV2 struct {
	pulumi.CustomResourceState

	// The administrative state of the Loadbalancer.
	// A valid value is true (UP) or false (DOWN).
	AdminStateUp pulumi.BoolPtrOutput `pulumi:"adminStateUp"`
	// The availability zone of the Loadbalancer.
	// Changing this creates a new loadbalancer. Available only for Octavia
	// **minor version 2.14 or later**.
	AvailabilityZone pulumi.StringPtrOutput `pulumi:"availabilityZone"`
	// Human-readable description for the Loadbalancer.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The UUID of a flavor. Changing this creates a new
	// loadbalancer.
	FlavorId pulumi.StringOutput `pulumi:"flavorId"`
	// The name of the provider. Changing this
	// creates a new loadbalancer.
	LoadbalancerProvider pulumi.StringOutput `pulumi:"loadbalancerProvider"`
	// Human-readable name for the Loadbalancer. Does not have
	// to be unique.
	Name pulumi.StringOutput `pulumi:"name"`
	// The region in which to obtain the V2 Networking client.
	// A Networking client is needed to create an LB member. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// LB member.
	Region pulumi.StringOutput `pulumi:"region"`
	// A list of security group IDs to apply to the
	// loadbalancer. The security groups must be specified by ID and not name (as
	// opposed to how they are configured with the Compute Instance).
	SecurityGroupIds pulumi.StringArrayOutput `pulumi:"securityGroupIds"`
	// A list of simple strings assigned to the loadbalancer.
	// Available only for Octavia **minor version 2.5 or later**.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Required for admins. The UUID of the tenant who owns
	// the Loadbalancer.  Only administrative users can specify a tenant UUID
	// other than their own.  Changing this creates a new loadbalancer.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
	// The ip address of the load balancer.
	// Changing this creates a new loadbalancer.
	VipAddress pulumi.StringOutput `pulumi:"vipAddress"`
	// The network on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipNetworkId pulumi.StringOutput `pulumi:"vipNetworkId"`
	// The port UUID that the loadbalancer will use.
	// Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipPortId pulumi.StringOutput `pulumi:"vipPortId"`
	// The ID of the QoS Policy which will
	// be applied to the Virtual IP (VIP).
	VipQosPolicyId pulumi.StringPtrOutput `pulumi:"vipQosPolicyId"`
	// The subnet on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipSubnetId pulumi.StringOutput `pulumi:"vipSubnetId"`
}

// NewLbLoadbalancerV2 registers a new resource with the given unique name, arguments, and options.
func NewLbLoadbalancerV2(ctx *pulumi.Context,
	name string, args *LbLoadbalancerV2Args, opts ...pulumi.ResourceOption) (*LbLoadbalancerV2, error) {
	if args == nil {
		args = &LbLoadbalancerV2Args{}
	}

	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("openstack:loadbalancer/loadBalancer:LoadBalancer"),
		},
	})
	opts = append(opts, aliases)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LbLoadbalancerV2
	err := ctx.RegisterResource("openstack:index/lbLoadbalancerV2:LbLoadbalancerV2", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLbLoadbalancerV2 gets an existing LbLoadbalancerV2 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLbLoadbalancerV2(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LbLoadbalancerV2State, opts ...pulumi.ResourceOption) (*LbLoadbalancerV2, error) {
	var resource LbLoadbalancerV2
	err := ctx.ReadResource("openstack:index/lbLoadbalancerV2:LbLoadbalancerV2", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LbLoadbalancerV2 resources.
type lbLoadbalancerV2State struct {
	// The administrative state of the Loadbalancer.
	// A valid value is true (UP) or false (DOWN).
	AdminStateUp *bool `pulumi:"adminStateUp"`
	// The availability zone of the Loadbalancer.
	// Changing this creates a new loadbalancer. Available only for Octavia
	// **minor version 2.14 or later**.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// Human-readable description for the Loadbalancer.
	Description *string `pulumi:"description"`
	// The UUID of a flavor. Changing this creates a new
	// loadbalancer.
	FlavorId *string `pulumi:"flavorId"`
	// The name of the provider. Changing this
	// creates a new loadbalancer.
	LoadbalancerProvider *string `pulumi:"loadbalancerProvider"`
	// Human-readable name for the Loadbalancer. Does not have
	// to be unique.
	Name *string `pulumi:"name"`
	// The region in which to obtain the V2 Networking client.
	// A Networking client is needed to create an LB member. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// LB member.
	Region *string `pulumi:"region"`
	// A list of security group IDs to apply to the
	// loadbalancer. The security groups must be specified by ID and not name (as
	// opposed to how they are configured with the Compute Instance).
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// A list of simple strings assigned to the loadbalancer.
	// Available only for Octavia **minor version 2.5 or later**.
	Tags []string `pulumi:"tags"`
	// Required for admins. The UUID of the tenant who owns
	// the Loadbalancer.  Only administrative users can specify a tenant UUID
	// other than their own.  Changing this creates a new loadbalancer.
	TenantId *string `pulumi:"tenantId"`
	// The ip address of the load balancer.
	// Changing this creates a new loadbalancer.
	VipAddress *string `pulumi:"vipAddress"`
	// The network on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipNetworkId *string `pulumi:"vipNetworkId"`
	// The port UUID that the loadbalancer will use.
	// Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipPortId *string `pulumi:"vipPortId"`
	// The ID of the QoS Policy which will
	// be applied to the Virtual IP (VIP).
	VipQosPolicyId *string `pulumi:"vipQosPolicyId"`
	// The subnet on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipSubnetId *string `pulumi:"vipSubnetId"`
}

type LbLoadbalancerV2State struct {
	// The administrative state of the Loadbalancer.
	// A valid value is true (UP) or false (DOWN).
	AdminStateUp pulumi.BoolPtrInput
	// The availability zone of the Loadbalancer.
	// Changing this creates a new loadbalancer. Available only for Octavia
	// **minor version 2.14 or later**.
	AvailabilityZone pulumi.StringPtrInput
	// Human-readable description for the Loadbalancer.
	Description pulumi.StringPtrInput
	// The UUID of a flavor. Changing this creates a new
	// loadbalancer.
	FlavorId pulumi.StringPtrInput
	// The name of the provider. Changing this
	// creates a new loadbalancer.
	LoadbalancerProvider pulumi.StringPtrInput
	// Human-readable name for the Loadbalancer. Does not have
	// to be unique.
	Name pulumi.StringPtrInput
	// The region in which to obtain the V2 Networking client.
	// A Networking client is needed to create an LB member. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// LB member.
	Region pulumi.StringPtrInput
	// A list of security group IDs to apply to the
	// loadbalancer. The security groups must be specified by ID and not name (as
	// opposed to how they are configured with the Compute Instance).
	SecurityGroupIds pulumi.StringArrayInput
	// A list of simple strings assigned to the loadbalancer.
	// Available only for Octavia **minor version 2.5 or later**.
	Tags pulumi.StringArrayInput
	// Required for admins. The UUID of the tenant who owns
	// the Loadbalancer.  Only administrative users can specify a tenant UUID
	// other than their own.  Changing this creates a new loadbalancer.
	TenantId pulumi.StringPtrInput
	// The ip address of the load balancer.
	// Changing this creates a new loadbalancer.
	VipAddress pulumi.StringPtrInput
	// The network on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipNetworkId pulumi.StringPtrInput
	// The port UUID that the loadbalancer will use.
	// Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipPortId pulumi.StringPtrInput
	// The ID of the QoS Policy which will
	// be applied to the Virtual IP (VIP).
	VipQosPolicyId pulumi.StringPtrInput
	// The subnet on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipSubnetId pulumi.StringPtrInput
}

func (LbLoadbalancerV2State) ElementType() reflect.Type {
	return reflect.TypeOf((*lbLoadbalancerV2State)(nil)).Elem()
}

type lbLoadbalancerV2Args struct {
	// The administrative state of the Loadbalancer.
	// A valid value is true (UP) or false (DOWN).
	AdminStateUp *bool `pulumi:"adminStateUp"`
	// The availability zone of the Loadbalancer.
	// Changing this creates a new loadbalancer. Available only for Octavia
	// **minor version 2.14 or later**.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// Human-readable description for the Loadbalancer.
	Description *string `pulumi:"description"`
	// The UUID of a flavor. Changing this creates a new
	// loadbalancer.
	FlavorId *string `pulumi:"flavorId"`
	// The name of the provider. Changing this
	// creates a new loadbalancer.
	LoadbalancerProvider *string `pulumi:"loadbalancerProvider"`
	// Human-readable name for the Loadbalancer. Does not have
	// to be unique.
	Name *string `pulumi:"name"`
	// The region in which to obtain the V2 Networking client.
	// A Networking client is needed to create an LB member. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// LB member.
	Region *string `pulumi:"region"`
	// A list of security group IDs to apply to the
	// loadbalancer. The security groups must be specified by ID and not name (as
	// opposed to how they are configured with the Compute Instance).
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// A list of simple strings assigned to the loadbalancer.
	// Available only for Octavia **minor version 2.5 or later**.
	Tags []string `pulumi:"tags"`
	// Required for admins. The UUID of the tenant who owns
	// the Loadbalancer.  Only administrative users can specify a tenant UUID
	// other than their own.  Changing this creates a new loadbalancer.
	TenantId *string `pulumi:"tenantId"`
	// The ip address of the load balancer.
	// Changing this creates a new loadbalancer.
	VipAddress *string `pulumi:"vipAddress"`
	// The network on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipNetworkId *string `pulumi:"vipNetworkId"`
	// The port UUID that the loadbalancer will use.
	// Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipPortId *string `pulumi:"vipPortId"`
	// The ID of the QoS Policy which will
	// be applied to the Virtual IP (VIP).
	VipQosPolicyId *string `pulumi:"vipQosPolicyId"`
	// The subnet on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipSubnetId *string `pulumi:"vipSubnetId"`
}

// The set of arguments for constructing a LbLoadbalancerV2 resource.
type LbLoadbalancerV2Args struct {
	// The administrative state of the Loadbalancer.
	// A valid value is true (UP) or false (DOWN).
	AdminStateUp pulumi.BoolPtrInput
	// The availability zone of the Loadbalancer.
	// Changing this creates a new loadbalancer. Available only for Octavia
	// **minor version 2.14 or later**.
	AvailabilityZone pulumi.StringPtrInput
	// Human-readable description for the Loadbalancer.
	Description pulumi.StringPtrInput
	// The UUID of a flavor. Changing this creates a new
	// loadbalancer.
	FlavorId pulumi.StringPtrInput
	// The name of the provider. Changing this
	// creates a new loadbalancer.
	LoadbalancerProvider pulumi.StringPtrInput
	// Human-readable name for the Loadbalancer. Does not have
	// to be unique.
	Name pulumi.StringPtrInput
	// The region in which to obtain the V2 Networking client.
	// A Networking client is needed to create an LB member. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// LB member.
	Region pulumi.StringPtrInput
	// A list of security group IDs to apply to the
	// loadbalancer. The security groups must be specified by ID and not name (as
	// opposed to how they are configured with the Compute Instance).
	SecurityGroupIds pulumi.StringArrayInput
	// A list of simple strings assigned to the loadbalancer.
	// Available only for Octavia **minor version 2.5 or later**.
	Tags pulumi.StringArrayInput
	// Required for admins. The UUID of the tenant who owns
	// the Loadbalancer.  Only administrative users can specify a tenant UUID
	// other than their own.  Changing this creates a new loadbalancer.
	TenantId pulumi.StringPtrInput
	// The ip address of the load balancer.
	// Changing this creates a new loadbalancer.
	VipAddress pulumi.StringPtrInput
	// The network on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipNetworkId pulumi.StringPtrInput
	// The port UUID that the loadbalancer will use.
	// Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipPortId pulumi.StringPtrInput
	// The ID of the QoS Policy which will
	// be applied to the Virtual IP (VIP).
	VipQosPolicyId pulumi.StringPtrInput
	// The subnet on which to allocate the
	// Loadbalancer's address. A tenant can only create Loadbalancers on networks
	// authorized by policy (e.g. networks that belong to them or networks that
	// are shared).  Changing this creates a new loadbalancer. Exactly one of
	// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
	VipSubnetId pulumi.StringPtrInput
}

func (LbLoadbalancerV2Args) ElementType() reflect.Type {
	return reflect.TypeOf((*lbLoadbalancerV2Args)(nil)).Elem()
}

type LbLoadbalancerV2Input interface {
	pulumi.Input

	ToLbLoadbalancerV2Output() LbLoadbalancerV2Output
	ToLbLoadbalancerV2OutputWithContext(ctx context.Context) LbLoadbalancerV2Output
}

func (*LbLoadbalancerV2) ElementType() reflect.Type {
	return reflect.TypeOf((**LbLoadbalancerV2)(nil)).Elem()
}

func (i *LbLoadbalancerV2) ToLbLoadbalancerV2Output() LbLoadbalancerV2Output {
	return i.ToLbLoadbalancerV2OutputWithContext(context.Background())
}

func (i *LbLoadbalancerV2) ToLbLoadbalancerV2OutputWithContext(ctx context.Context) LbLoadbalancerV2Output {
	return pulumi.ToOutputWithContext(ctx, i).(LbLoadbalancerV2Output)
}

// LbLoadbalancerV2ArrayInput is an input type that accepts LbLoadbalancerV2Array and LbLoadbalancerV2ArrayOutput values.
// You can construct a concrete instance of `LbLoadbalancerV2ArrayInput` via:
//
//	LbLoadbalancerV2Array{ LbLoadbalancerV2Args{...} }
type LbLoadbalancerV2ArrayInput interface {
	pulumi.Input

	ToLbLoadbalancerV2ArrayOutput() LbLoadbalancerV2ArrayOutput
	ToLbLoadbalancerV2ArrayOutputWithContext(context.Context) LbLoadbalancerV2ArrayOutput
}

type LbLoadbalancerV2Array []LbLoadbalancerV2Input

func (LbLoadbalancerV2Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LbLoadbalancerV2)(nil)).Elem()
}

func (i LbLoadbalancerV2Array) ToLbLoadbalancerV2ArrayOutput() LbLoadbalancerV2ArrayOutput {
	return i.ToLbLoadbalancerV2ArrayOutputWithContext(context.Background())
}

func (i LbLoadbalancerV2Array) ToLbLoadbalancerV2ArrayOutputWithContext(ctx context.Context) LbLoadbalancerV2ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LbLoadbalancerV2ArrayOutput)
}

// LbLoadbalancerV2MapInput is an input type that accepts LbLoadbalancerV2Map and LbLoadbalancerV2MapOutput values.
// You can construct a concrete instance of `LbLoadbalancerV2MapInput` via:
//
//	LbLoadbalancerV2Map{ "key": LbLoadbalancerV2Args{...} }
type LbLoadbalancerV2MapInput interface {
	pulumi.Input

	ToLbLoadbalancerV2MapOutput() LbLoadbalancerV2MapOutput
	ToLbLoadbalancerV2MapOutputWithContext(context.Context) LbLoadbalancerV2MapOutput
}

type LbLoadbalancerV2Map map[string]LbLoadbalancerV2Input

func (LbLoadbalancerV2Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LbLoadbalancerV2)(nil)).Elem()
}

func (i LbLoadbalancerV2Map) ToLbLoadbalancerV2MapOutput() LbLoadbalancerV2MapOutput {
	return i.ToLbLoadbalancerV2MapOutputWithContext(context.Background())
}

func (i LbLoadbalancerV2Map) ToLbLoadbalancerV2MapOutputWithContext(ctx context.Context) LbLoadbalancerV2MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LbLoadbalancerV2MapOutput)
}

type LbLoadbalancerV2Output struct{ *pulumi.OutputState }

func (LbLoadbalancerV2Output) ElementType() reflect.Type {
	return reflect.TypeOf((**LbLoadbalancerV2)(nil)).Elem()
}

func (o LbLoadbalancerV2Output) ToLbLoadbalancerV2Output() LbLoadbalancerV2Output {
	return o
}

func (o LbLoadbalancerV2Output) ToLbLoadbalancerV2OutputWithContext(ctx context.Context) LbLoadbalancerV2Output {
	return o
}

// The administrative state of the Loadbalancer.
// A valid value is true (UP) or false (DOWN).
func (o LbLoadbalancerV2Output) AdminStateUp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.BoolPtrOutput { return v.AdminStateUp }).(pulumi.BoolPtrOutput)
}

// The availability zone of the Loadbalancer.
// Changing this creates a new loadbalancer. Available only for Octavia
// **minor version 2.14 or later**.
func (o LbLoadbalancerV2Output) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringPtrOutput { return v.AvailabilityZone }).(pulumi.StringPtrOutput)
}

// Human-readable description for the Loadbalancer.
func (o LbLoadbalancerV2Output) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The UUID of a flavor. Changing this creates a new
// loadbalancer.
func (o LbLoadbalancerV2Output) FlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.FlavorId }).(pulumi.StringOutput)
}

// The name of the provider. Changing this
// creates a new loadbalancer.
func (o LbLoadbalancerV2Output) LoadbalancerProvider() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.LoadbalancerProvider }).(pulumi.StringOutput)
}

// Human-readable name for the Loadbalancer. Does not have
// to be unique.
func (o LbLoadbalancerV2Output) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The region in which to obtain the V2 Networking client.
// A Networking client is needed to create an LB member. If omitted, the
// `region` argument of the provider is used. Changing this creates a new
// LB member.
func (o LbLoadbalancerV2Output) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// A list of security group IDs to apply to the
// loadbalancer. The security groups must be specified by ID and not name (as
// opposed to how they are configured with the Compute Instance).
func (o LbLoadbalancerV2Output) SecurityGroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringArrayOutput { return v.SecurityGroupIds }).(pulumi.StringArrayOutput)
}

// A list of simple strings assigned to the loadbalancer.
// Available only for Octavia **minor version 2.5 or later**.
func (o LbLoadbalancerV2Output) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Required for admins. The UUID of the tenant who owns
// the Loadbalancer.  Only administrative users can specify a tenant UUID
// other than their own.  Changing this creates a new loadbalancer.
func (o LbLoadbalancerV2Output) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

// The ip address of the load balancer.
// Changing this creates a new loadbalancer.
func (o LbLoadbalancerV2Output) VipAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.VipAddress }).(pulumi.StringOutput)
}

// The network on which to allocate the
// Loadbalancer's address. A tenant can only create Loadbalancers on networks
// authorized by policy (e.g. networks that belong to them or networks that
// are shared).  Changing this creates a new loadbalancer. Exactly one of
// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
func (o LbLoadbalancerV2Output) VipNetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.VipNetworkId }).(pulumi.StringOutput)
}

// The port UUID that the loadbalancer will use.
// Changing this creates a new loadbalancer. Exactly one of
// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
func (o LbLoadbalancerV2Output) VipPortId() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.VipPortId }).(pulumi.StringOutput)
}

// The ID of the QoS Policy which will
// be applied to the Virtual IP (VIP).
func (o LbLoadbalancerV2Output) VipQosPolicyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringPtrOutput { return v.VipQosPolicyId }).(pulumi.StringPtrOutput)
}

// The subnet on which to allocate the
// Loadbalancer's address. A tenant can only create Loadbalancers on networks
// authorized by policy (e.g. networks that belong to them or networks that
// are shared).  Changing this creates a new loadbalancer. Exactly one of
// `vipSubnetId`, `vipNetworkId` or `vipPortId` has to be defined.
func (o LbLoadbalancerV2Output) VipSubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v *LbLoadbalancerV2) pulumi.StringOutput { return v.VipSubnetId }).(pulumi.StringOutput)
}

type LbLoadbalancerV2ArrayOutput struct{ *pulumi.OutputState }

func (LbLoadbalancerV2ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LbLoadbalancerV2)(nil)).Elem()
}

func (o LbLoadbalancerV2ArrayOutput) ToLbLoadbalancerV2ArrayOutput() LbLoadbalancerV2ArrayOutput {
	return o
}

func (o LbLoadbalancerV2ArrayOutput) ToLbLoadbalancerV2ArrayOutputWithContext(ctx context.Context) LbLoadbalancerV2ArrayOutput {
	return o
}

func (o LbLoadbalancerV2ArrayOutput) Index(i pulumi.IntInput) LbLoadbalancerV2Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LbLoadbalancerV2 {
		return vs[0].([]*LbLoadbalancerV2)[vs[1].(int)]
	}).(LbLoadbalancerV2Output)
}

type LbLoadbalancerV2MapOutput struct{ *pulumi.OutputState }

func (LbLoadbalancerV2MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LbLoadbalancerV2)(nil)).Elem()
}

func (o LbLoadbalancerV2MapOutput) ToLbLoadbalancerV2MapOutput() LbLoadbalancerV2MapOutput {
	return o
}

func (o LbLoadbalancerV2MapOutput) ToLbLoadbalancerV2MapOutputWithContext(ctx context.Context) LbLoadbalancerV2MapOutput {
	return o
}

func (o LbLoadbalancerV2MapOutput) MapIndex(k pulumi.StringInput) LbLoadbalancerV2Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LbLoadbalancerV2 {
		return vs[0].(map[string]*LbLoadbalancerV2)[vs[1].(string)]
	}).(LbLoadbalancerV2Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LbLoadbalancerV2Input)(nil)).Elem(), &LbLoadbalancerV2{})
	pulumi.RegisterInputType(reflect.TypeOf((*LbLoadbalancerV2ArrayInput)(nil)).Elem(), LbLoadbalancerV2Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*LbLoadbalancerV2MapInput)(nil)).Elem(), LbLoadbalancerV2Map{})
	pulumi.RegisterOutputType(LbLoadbalancerV2Output{})
	pulumi.RegisterOutputType(LbLoadbalancerV2ArrayOutput{})
	pulumi.RegisterOutputType(LbLoadbalancerV2MapOutput{})
}
