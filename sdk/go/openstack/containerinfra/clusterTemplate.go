// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package containerinfra

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a V1 Magnum cluster template resource within OpenStack.
//
// ## Example Usage
// ### Create a Cluster template
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/containerinfra"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := containerinfra.NewClusterTemplate(ctx, "clustertemplate1", &containerinfra.ClusterTemplateArgs{
// 			Coe:                 pulumi.String("kubernetes"),
// 			DnsNameserver:       pulumi.String("1.1.1.1"),
// 			DockerStorageDriver: pulumi.String("devicemapper"),
// 			DockerVolumeSize:    pulumi.Int(10),
// 			Flavor:              pulumi.String("m1.small"),
// 			FloatingIpEnabled:   pulumi.Bool(false),
// 			Image:               pulumi.String("Fedora-Atomic-27"),
// 			Labels: pulumi.AnyMap{
// 				"influx_grafana_dashboard_enabled": pulumi.Any("true"),
// 				"kube_dashboard_enabled":           pulumi.Any("true"),
// 				"kube_tag":                         pulumi.Any("1.11.1"),
// 				"prometheus_monitoring":            pulumi.Any("true"),
// 			},
// 			MasterFlavor:    pulumi.String("m1.medium"),
// 			MasterLbEnabled: pulumi.Bool(true),
// 			NetworkDriver:   pulumi.String("flannel"),
// 			ServerType:      pulumi.String("vm"),
// 			VolumeDriver:    pulumi.String("cinder"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// The following arguments are supported:
//
// * `region` - (Optional) The region in which to obtain the V1 Container Infra
//   client. A Container Infra client is needed to create a cluster template. If
//   omitted,the `region` argument of the provider is used. Changing this
//   creates a new cluster template.
//
// * `name` - (Required) The name of the cluster template. Changing this updates
//   the name of the existing cluster template.
//
// * `projectId` - (Optional) The project of the cluster template. Required if
//   admin wants to create a cluster template in another project. Changing this
//   creates a new cluster template.
//
// * `userId` - (Optional) The user of the cluster template. Required if admin
//   wants to create a cluster template for another user. Changing this creates
//   a new cluster template.
//
// * `apiserverPort` - (Optional) The API server port for the Container
//   Orchestration Engine for this cluster template. Changing this updates the
//   API server port of the existing cluster template.
//
// * `coe` - (Required) The Container Orchestration Engine for this cluster
//   template. Changing this updates the engine of the existing cluster
//   template.
//
// * `clusterDistro` - (Optional) The distro for the cluster (fedora-atomic,
//   coreos, etc.). Changing this updates the cluster distro of the existing
//   cluster template.
//
// * `dnsNameserver` - (Optional) Address of the DNS nameserver that is used in
//   nodes of the cluster. Changing this updates the DNS nameserver of the
//   existing cluster template.
//
// * `dockerStorageDriver` - (Optional) Docker storage driver. Changing this
//   updates the Docker storage driver of the existing cluster template.
//
// * `dockerVolumeSize` - (Optional) The size (in GB) of the Docker volume.
//   Changing this updates the Docker volume size of the existing cluster
//   template.
//
// * `externalNetworkId` - (Optional) The ID of the external network that will
//   be used for the cluster. Changing this updates the external network ID of
//   the existing cluster template.
//
// * `fixedNetwork` - (Optional) The fixed network that will be attached to the
//   cluster. Changing this updates the fixed network of the existing cluster
//   template.
//
// * `fixedSubnet` - (Optional) The fixed subnet that will be attached to the
//   cluster. Changing this updates the fixed subnet of the existing cluster
//   template.
//
// * `flavor` - (Optional) The flavor for the nodes of the cluster. Can be set via
//   the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
//   flavor of the existing cluster template.
//
// * `masterFlavor` - (Optional) The flavor for the master nodes. Can be set via
//   the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
//   the master flavor of the existing cluster template.
//
// * `floatingIpEnabled` - (Optional) Indicates whether created cluster should
//   create floating IP for every node or not. Changing this updates the
//   floating IP enabled attribute of the existing cluster template.
//
// * `httpProxy` - (Optional) The address of a proxy for receiving all HTTP
//   requests and relay them. Changing this updates the HTTP proxy address of
//   the existing cluster template.
//
// * `httpsProxy` - (Optional) The address of a proxy for receiving all HTTPS
//   requests and relay them. Changing this updates the HTTPS proxy address of
//   the existing cluster template.
//
// * `image` - (Required) The reference to an image that is used for nodes of the
//   cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
//   Changing this updates the image attribute of the existing cluster template.
//
// * `insecureRegistry` - (Optional) The insecure registry URL for the cluster
//   template. Changing this updates the insecure registry attribute of the
//   existing cluster template.
//
// * `keypairId` - (Optional) The name of the Compute service SSH keypair.
//   Changing this updates the keypair of the existing cluster template.
//
// * `labels` - (Optional) The list of key value pairs representing additional
//   properties of the cluster template. Changing this updates the labels of the
//   existing cluster template.
//
// * `masterLbEnabled` - (Optional) Indicates whether created cluster should
//   has a loadbalancer for master nodes or not. Changing this updates the
//   attribute of the existing cluster template.
//
// * `networkDriver` - (Optional) The name of the driver for the container
//   network. Changing this updates the network driver of the existing cluster
//   template.
//
// * `noProxy` - (Optional) A comma-separated list of IP addresses that shouldn't
//   be used in the cluster. Changing this updates the no proxy list of the
//   existing cluster template.
//
// * `public` - (Optional) Indicates whether cluster template should be public.
//   Changing this updates the public attribute of the existing cluster
//   template.
//
// * `registryEnabled` - (Optional) Indicates whether Docker registry is enabled
//   in the cluster. Changing this updates the registry enabled attribute of the
//   existing cluster template.
//
// * `serverType` - (Optional) The server type for the cluster template. Changing
//   this updates the server type of the existing cluster template.
//
// * `tlsDisabled` - (Optional) Indicates whether the TLS should be disabled in
//   the cluster. Changing this updates the attribute of the existing cluster.
//
// * `volumeDriver` - (Optional) The name of the driver that is used for the
//   volumes of the cluster nodes. Changing this updates the volume driver of
//   the existing cluster template.
//
// ## Attributes reference
//
// The following attributes are exported:
//
// * `region` - See Argument Reference above.
// * `name` - See Argument Reference above.
// * `projectId` - See Argument Reference above.
// * `createdAt` - The time at which cluster template was created.
// * `updatedAt` - The time at which cluster template was created.
// * `apiserverPort` - See Argument Reference above.
// * `coe` - See Argument Reference above.
// * `clusterDistro` - See Argument Reference above.
// * `dnsNameserver` - See Argument Reference above.
// * `dockerStorageDriver` - See Argument Reference above.
// * `dockerVolumeSize` - See Argument Reference above.
// * `externalNetworkId` - See Argument Reference above.
// * `fixedNetwork` - See Argument Reference above.
// * `fixedSubnet` - See Argument Reference above.
// * `flavor` - See Argument Reference above.
// * `masterFlavor` - See Argument Reference above.
// * `floatingIpEnabled` - See Argument Reference above.
// * `httpProxy` - See Argument Reference above.
// * `httpsProxy` - See Argument Reference above.
// * `image` - See Argument Reference above.
// * `insecureRegistry` - See Argument Reference above.
// * `keypairId` - See Argument Reference above.
// * `labels` - See Argument Reference above.
// * `links` - A list containing associated cluster template links.
// * `masterLbEnabled` - See Argument Reference above.
// * `networkDriver` - See Argument Reference above.
// * `noProxy` - See Argument Reference above.
// * `public` - See Argument Reference above.
// * `registryEnabled` - See Argument Reference above.
// * `serverType` - See Argument Reference above.
// * `tlsDisabled` - See Argument Reference above.
// * `volumeDriver` - See Argument Reference above.
//
// ## Import
//
// Cluster templates can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import openstack:containerinfra/clusterTemplate:ClusterTemplate clustertemplate_1 b9a45c5c-cd03-4958-82aa-b80bf93cb922
// ```
type ClusterTemplate struct {
	pulumi.CustomResourceState

	ApiserverPort       pulumi.IntPtrOutput    `pulumi:"apiserverPort"`
	ClusterDistro       pulumi.StringOutput    `pulumi:"clusterDistro"`
	Coe                 pulumi.StringOutput    `pulumi:"coe"`
	CreatedAt           pulumi.StringOutput    `pulumi:"createdAt"`
	DnsNameserver       pulumi.StringPtrOutput `pulumi:"dnsNameserver"`
	DockerStorageDriver pulumi.StringPtrOutput `pulumi:"dockerStorageDriver"`
	DockerVolumeSize    pulumi.IntPtrOutput    `pulumi:"dockerVolumeSize"`
	ExternalNetworkId   pulumi.StringPtrOutput `pulumi:"externalNetworkId"`
	FixedNetwork        pulumi.StringPtrOutput `pulumi:"fixedNetwork"`
	FixedSubnet         pulumi.StringPtrOutput `pulumi:"fixedSubnet"`
	Flavor              pulumi.StringPtrOutput `pulumi:"flavor"`
	FloatingIpEnabled   pulumi.BoolPtrOutput   `pulumi:"floatingIpEnabled"`
	HttpProxy           pulumi.StringPtrOutput `pulumi:"httpProxy"`
	HttpsProxy          pulumi.StringPtrOutput `pulumi:"httpsProxy"`
	Image               pulumi.StringOutput    `pulumi:"image"`
	InsecureRegistry    pulumi.StringPtrOutput `pulumi:"insecureRegistry"`
	KeypairId           pulumi.StringPtrOutput `pulumi:"keypairId"`
	Labels              pulumi.MapOutput       `pulumi:"labels"`
	MasterFlavor        pulumi.StringPtrOutput `pulumi:"masterFlavor"`
	MasterLbEnabled     pulumi.BoolPtrOutput   `pulumi:"masterLbEnabled"`
	Name                pulumi.StringOutput    `pulumi:"name"`
	NetworkDriver       pulumi.StringOutput    `pulumi:"networkDriver"`
	NoProxy             pulumi.StringPtrOutput `pulumi:"noProxy"`
	ProjectId           pulumi.StringOutput    `pulumi:"projectId"`
	Public              pulumi.BoolPtrOutput   `pulumi:"public"`
	Region              pulumi.StringOutput    `pulumi:"region"`
	RegistryEnabled     pulumi.BoolPtrOutput   `pulumi:"registryEnabled"`
	ServerType          pulumi.StringOutput    `pulumi:"serverType"`
	TlsDisabled         pulumi.BoolPtrOutput   `pulumi:"tlsDisabled"`
	UpdatedAt           pulumi.StringOutput    `pulumi:"updatedAt"`
	UserId              pulumi.StringOutput    `pulumi:"userId"`
	VolumeDriver        pulumi.StringPtrOutput `pulumi:"volumeDriver"`
}

// NewClusterTemplate registers a new resource with the given unique name, arguments, and options.
func NewClusterTemplate(ctx *pulumi.Context,
	name string, args *ClusterTemplateArgs, opts ...pulumi.ResourceOption) (*ClusterTemplate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Coe == nil {
		return nil, errors.New("invalid value for required argument 'Coe'")
	}
	if args.Image == nil {
		return nil, errors.New("invalid value for required argument 'Image'")
	}
	var resource ClusterTemplate
	err := ctx.RegisterResource("openstack:containerinfra/clusterTemplate:ClusterTemplate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClusterTemplate gets an existing ClusterTemplate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterTemplate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterTemplateState, opts ...pulumi.ResourceOption) (*ClusterTemplate, error) {
	var resource ClusterTemplate
	err := ctx.ReadResource("openstack:containerinfra/clusterTemplate:ClusterTemplate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClusterTemplate resources.
type clusterTemplateState struct {
	ApiserverPort       *int                   `pulumi:"apiserverPort"`
	ClusterDistro       *string                `pulumi:"clusterDistro"`
	Coe                 *string                `pulumi:"coe"`
	CreatedAt           *string                `pulumi:"createdAt"`
	DnsNameserver       *string                `pulumi:"dnsNameserver"`
	DockerStorageDriver *string                `pulumi:"dockerStorageDriver"`
	DockerVolumeSize    *int                   `pulumi:"dockerVolumeSize"`
	ExternalNetworkId   *string                `pulumi:"externalNetworkId"`
	FixedNetwork        *string                `pulumi:"fixedNetwork"`
	FixedSubnet         *string                `pulumi:"fixedSubnet"`
	Flavor              *string                `pulumi:"flavor"`
	FloatingIpEnabled   *bool                  `pulumi:"floatingIpEnabled"`
	HttpProxy           *string                `pulumi:"httpProxy"`
	HttpsProxy          *string                `pulumi:"httpsProxy"`
	Image               *string                `pulumi:"image"`
	InsecureRegistry    *string                `pulumi:"insecureRegistry"`
	KeypairId           *string                `pulumi:"keypairId"`
	Labels              map[string]interface{} `pulumi:"labels"`
	MasterFlavor        *string                `pulumi:"masterFlavor"`
	MasterLbEnabled     *bool                  `pulumi:"masterLbEnabled"`
	Name                *string                `pulumi:"name"`
	NetworkDriver       *string                `pulumi:"networkDriver"`
	NoProxy             *string                `pulumi:"noProxy"`
	ProjectId           *string                `pulumi:"projectId"`
	Public              *bool                  `pulumi:"public"`
	Region              *string                `pulumi:"region"`
	RegistryEnabled     *bool                  `pulumi:"registryEnabled"`
	ServerType          *string                `pulumi:"serverType"`
	TlsDisabled         *bool                  `pulumi:"tlsDisabled"`
	UpdatedAt           *string                `pulumi:"updatedAt"`
	UserId              *string                `pulumi:"userId"`
	VolumeDriver        *string                `pulumi:"volumeDriver"`
}

type ClusterTemplateState struct {
	ApiserverPort       pulumi.IntPtrInput
	ClusterDistro       pulumi.StringPtrInput
	Coe                 pulumi.StringPtrInput
	CreatedAt           pulumi.StringPtrInput
	DnsNameserver       pulumi.StringPtrInput
	DockerStorageDriver pulumi.StringPtrInput
	DockerVolumeSize    pulumi.IntPtrInput
	ExternalNetworkId   pulumi.StringPtrInput
	FixedNetwork        pulumi.StringPtrInput
	FixedSubnet         pulumi.StringPtrInput
	Flavor              pulumi.StringPtrInput
	FloatingIpEnabled   pulumi.BoolPtrInput
	HttpProxy           pulumi.StringPtrInput
	HttpsProxy          pulumi.StringPtrInput
	Image               pulumi.StringPtrInput
	InsecureRegistry    pulumi.StringPtrInput
	KeypairId           pulumi.StringPtrInput
	Labels              pulumi.MapInput
	MasterFlavor        pulumi.StringPtrInput
	MasterLbEnabled     pulumi.BoolPtrInput
	Name                pulumi.StringPtrInput
	NetworkDriver       pulumi.StringPtrInput
	NoProxy             pulumi.StringPtrInput
	ProjectId           pulumi.StringPtrInput
	Public              pulumi.BoolPtrInput
	Region              pulumi.StringPtrInput
	RegistryEnabled     pulumi.BoolPtrInput
	ServerType          pulumi.StringPtrInput
	TlsDisabled         pulumi.BoolPtrInput
	UpdatedAt           pulumi.StringPtrInput
	UserId              pulumi.StringPtrInput
	VolumeDriver        pulumi.StringPtrInput
}

func (ClusterTemplateState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterTemplateState)(nil)).Elem()
}

type clusterTemplateArgs struct {
	ApiserverPort       *int                   `pulumi:"apiserverPort"`
	ClusterDistro       *string                `pulumi:"clusterDistro"`
	Coe                 string                 `pulumi:"coe"`
	DnsNameserver       *string                `pulumi:"dnsNameserver"`
	DockerStorageDriver *string                `pulumi:"dockerStorageDriver"`
	DockerVolumeSize    *int                   `pulumi:"dockerVolumeSize"`
	ExternalNetworkId   *string                `pulumi:"externalNetworkId"`
	FixedNetwork        *string                `pulumi:"fixedNetwork"`
	FixedSubnet         *string                `pulumi:"fixedSubnet"`
	Flavor              *string                `pulumi:"flavor"`
	FloatingIpEnabled   *bool                  `pulumi:"floatingIpEnabled"`
	HttpProxy           *string                `pulumi:"httpProxy"`
	HttpsProxy          *string                `pulumi:"httpsProxy"`
	Image               string                 `pulumi:"image"`
	InsecureRegistry    *string                `pulumi:"insecureRegistry"`
	KeypairId           *string                `pulumi:"keypairId"`
	Labels              map[string]interface{} `pulumi:"labels"`
	MasterFlavor        *string                `pulumi:"masterFlavor"`
	MasterLbEnabled     *bool                  `pulumi:"masterLbEnabled"`
	Name                *string                `pulumi:"name"`
	NetworkDriver       *string                `pulumi:"networkDriver"`
	NoProxy             *string                `pulumi:"noProxy"`
	Public              *bool                  `pulumi:"public"`
	Region              *string                `pulumi:"region"`
	RegistryEnabled     *bool                  `pulumi:"registryEnabled"`
	ServerType          *string                `pulumi:"serverType"`
	TlsDisabled         *bool                  `pulumi:"tlsDisabled"`
	VolumeDriver        *string                `pulumi:"volumeDriver"`
}

// The set of arguments for constructing a ClusterTemplate resource.
type ClusterTemplateArgs struct {
	ApiserverPort       pulumi.IntPtrInput
	ClusterDistro       pulumi.StringPtrInput
	Coe                 pulumi.StringInput
	DnsNameserver       pulumi.StringPtrInput
	DockerStorageDriver pulumi.StringPtrInput
	DockerVolumeSize    pulumi.IntPtrInput
	ExternalNetworkId   pulumi.StringPtrInput
	FixedNetwork        pulumi.StringPtrInput
	FixedSubnet         pulumi.StringPtrInput
	Flavor              pulumi.StringPtrInput
	FloatingIpEnabled   pulumi.BoolPtrInput
	HttpProxy           pulumi.StringPtrInput
	HttpsProxy          pulumi.StringPtrInput
	Image               pulumi.StringInput
	InsecureRegistry    pulumi.StringPtrInput
	KeypairId           pulumi.StringPtrInput
	Labels              pulumi.MapInput
	MasterFlavor        pulumi.StringPtrInput
	MasterLbEnabled     pulumi.BoolPtrInput
	Name                pulumi.StringPtrInput
	NetworkDriver       pulumi.StringPtrInput
	NoProxy             pulumi.StringPtrInput
	Public              pulumi.BoolPtrInput
	Region              pulumi.StringPtrInput
	RegistryEnabled     pulumi.BoolPtrInput
	ServerType          pulumi.StringPtrInput
	TlsDisabled         pulumi.BoolPtrInput
	VolumeDriver        pulumi.StringPtrInput
}

func (ClusterTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterTemplateArgs)(nil)).Elem()
}

type ClusterTemplateInput interface {
	pulumi.Input

	ToClusterTemplateOutput() ClusterTemplateOutput
	ToClusterTemplateOutputWithContext(ctx context.Context) ClusterTemplateOutput
}

func (*ClusterTemplate) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTemplate)(nil))
}

func (i *ClusterTemplate) ToClusterTemplateOutput() ClusterTemplateOutput {
	return i.ToClusterTemplateOutputWithContext(context.Background())
}

func (i *ClusterTemplate) ToClusterTemplateOutputWithContext(ctx context.Context) ClusterTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTemplateOutput)
}

func (i *ClusterTemplate) ToClusterTemplatePtrOutput() ClusterTemplatePtrOutput {
	return i.ToClusterTemplatePtrOutputWithContext(context.Background())
}

func (i *ClusterTemplate) ToClusterTemplatePtrOutputWithContext(ctx context.Context) ClusterTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTemplatePtrOutput)
}

type ClusterTemplatePtrInput interface {
	pulumi.Input

	ToClusterTemplatePtrOutput() ClusterTemplatePtrOutput
	ToClusterTemplatePtrOutputWithContext(ctx context.Context) ClusterTemplatePtrOutput
}

type clusterTemplatePtrType ClusterTemplateArgs

func (*clusterTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTemplate)(nil))
}

func (i *clusterTemplatePtrType) ToClusterTemplatePtrOutput() ClusterTemplatePtrOutput {
	return i.ToClusterTemplatePtrOutputWithContext(context.Background())
}

func (i *clusterTemplatePtrType) ToClusterTemplatePtrOutputWithContext(ctx context.Context) ClusterTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTemplatePtrOutput)
}

// ClusterTemplateArrayInput is an input type that accepts ClusterTemplateArray and ClusterTemplateArrayOutput values.
// You can construct a concrete instance of `ClusterTemplateArrayInput` via:
//
//          ClusterTemplateArray{ ClusterTemplateArgs{...} }
type ClusterTemplateArrayInput interface {
	pulumi.Input

	ToClusterTemplateArrayOutput() ClusterTemplateArrayOutput
	ToClusterTemplateArrayOutputWithContext(context.Context) ClusterTemplateArrayOutput
}

type ClusterTemplateArray []ClusterTemplateInput

func (ClusterTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterTemplate)(nil)).Elem()
}

func (i ClusterTemplateArray) ToClusterTemplateArrayOutput() ClusterTemplateArrayOutput {
	return i.ToClusterTemplateArrayOutputWithContext(context.Background())
}

func (i ClusterTemplateArray) ToClusterTemplateArrayOutputWithContext(ctx context.Context) ClusterTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTemplateArrayOutput)
}

// ClusterTemplateMapInput is an input type that accepts ClusterTemplateMap and ClusterTemplateMapOutput values.
// You can construct a concrete instance of `ClusterTemplateMapInput` via:
//
//          ClusterTemplateMap{ "key": ClusterTemplateArgs{...} }
type ClusterTemplateMapInput interface {
	pulumi.Input

	ToClusterTemplateMapOutput() ClusterTemplateMapOutput
	ToClusterTemplateMapOutputWithContext(context.Context) ClusterTemplateMapOutput
}

type ClusterTemplateMap map[string]ClusterTemplateInput

func (ClusterTemplateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterTemplate)(nil)).Elem()
}

func (i ClusterTemplateMap) ToClusterTemplateMapOutput() ClusterTemplateMapOutput {
	return i.ToClusterTemplateMapOutputWithContext(context.Background())
}

func (i ClusterTemplateMap) ToClusterTemplateMapOutputWithContext(ctx context.Context) ClusterTemplateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterTemplateMapOutput)
}

type ClusterTemplateOutput struct{ *pulumi.OutputState }

func (ClusterTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterTemplate)(nil))
}

func (o ClusterTemplateOutput) ToClusterTemplateOutput() ClusterTemplateOutput {
	return o
}

func (o ClusterTemplateOutput) ToClusterTemplateOutputWithContext(ctx context.Context) ClusterTemplateOutput {
	return o
}

func (o ClusterTemplateOutput) ToClusterTemplatePtrOutput() ClusterTemplatePtrOutput {
	return o.ToClusterTemplatePtrOutputWithContext(context.Background())
}

func (o ClusterTemplateOutput) ToClusterTemplatePtrOutputWithContext(ctx context.Context) ClusterTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterTemplate) *ClusterTemplate {
		return &v
	}).(ClusterTemplatePtrOutput)
}

type ClusterTemplatePtrOutput struct{ *pulumi.OutputState }

func (ClusterTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterTemplate)(nil))
}

func (o ClusterTemplatePtrOutput) ToClusterTemplatePtrOutput() ClusterTemplatePtrOutput {
	return o
}

func (o ClusterTemplatePtrOutput) ToClusterTemplatePtrOutputWithContext(ctx context.Context) ClusterTemplatePtrOutput {
	return o
}

func (o ClusterTemplatePtrOutput) Elem() ClusterTemplateOutput {
	return o.ApplyT(func(v *ClusterTemplate) ClusterTemplate {
		if v != nil {
			return *v
		}
		var ret ClusterTemplate
		return ret
	}).(ClusterTemplateOutput)
}

type ClusterTemplateArrayOutput struct{ *pulumi.OutputState }

func (ClusterTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterTemplate)(nil))
}

func (o ClusterTemplateArrayOutput) ToClusterTemplateArrayOutput() ClusterTemplateArrayOutput {
	return o
}

func (o ClusterTemplateArrayOutput) ToClusterTemplateArrayOutputWithContext(ctx context.Context) ClusterTemplateArrayOutput {
	return o
}

func (o ClusterTemplateArrayOutput) Index(i pulumi.IntInput) ClusterTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterTemplate {
		return vs[0].([]ClusterTemplate)[vs[1].(int)]
	}).(ClusterTemplateOutput)
}

type ClusterTemplateMapOutput struct{ *pulumi.OutputState }

func (ClusterTemplateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ClusterTemplate)(nil))
}

func (o ClusterTemplateMapOutput) ToClusterTemplateMapOutput() ClusterTemplateMapOutput {
	return o
}

func (o ClusterTemplateMapOutput) ToClusterTemplateMapOutputWithContext(ctx context.Context) ClusterTemplateMapOutput {
	return o
}

func (o ClusterTemplateMapOutput) MapIndex(k pulumi.StringInput) ClusterTemplateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ClusterTemplate {
		return vs[0].(map[string]ClusterTemplate)[vs[1].(string)]
	}).(ClusterTemplateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTemplateInput)(nil)).Elem(), &ClusterTemplate{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTemplatePtrInput)(nil)).Elem(), &ClusterTemplate{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTemplateArrayInput)(nil)).Elem(), ClusterTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterTemplateMapInput)(nil)).Elem(), ClusterTemplateMap{})
	pulumi.RegisterOutputType(ClusterTemplateOutput{})
	pulumi.RegisterOutputType(ClusterTemplatePtrOutput{})
	pulumi.RegisterOutputType(ClusterTemplateArrayOutput{})
	pulumi.RegisterOutputType(ClusterTemplateMapOutput{})
}
