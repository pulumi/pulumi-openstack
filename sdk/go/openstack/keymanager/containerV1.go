// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package keymanager

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a V1 Barbican container resource within OpenStack.
//
// ## Example Usage
//
// ### Simple secret
//
// The container with the TLS certificates, which can be used by the loadbalancer HTTPS listener.
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/keymanager"
//	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/loadbalancer"
//	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/networking"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "cert.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			certificate1, err := keymanager.NewSecretV1(ctx, "certificate_1", &keymanager.SecretV1Args{
//				Name:               pulumi.String("certificate"),
//				Payload:            invokeFile.Result,
//				SecretType:         pulumi.String("certificate"),
//				PayloadContentType: pulumi.String("text/plain"),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFile1, err := std.File(ctx, &std.FileArgs{
//				Input: "cert-key.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			privateKey1, err := keymanager.NewSecretV1(ctx, "private_key_1", &keymanager.SecretV1Args{
//				Name:               pulumi.String("private_key"),
//				Payload:            invokeFile1.Result,
//				SecretType:         pulumi.String("private"),
//				PayloadContentType: pulumi.String("text/plain"),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFile2, err := std.File(ctx, &std.FileArgs{
//				Input: "intermediate-ca.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			intermediate1, err := keymanager.NewSecretV1(ctx, "intermediate_1", &keymanager.SecretV1Args{
//				Name:               pulumi.String("intermediate"),
//				Payload:            invokeFile2.Result,
//				SecretType:         pulumi.String("certificate"),
//				PayloadContentType: pulumi.String("text/plain"),
//			})
//			if err != nil {
//				return err
//			}
//			tls1, err := keymanager.NewContainerV1(ctx, "tls_1", &keymanager.ContainerV1Args{
//				Name: pulumi.String("tls"),
//				Type: pulumi.String("certificate"),
//				SecretRefs: keymanager.ContainerV1SecretRefArray{
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("certificate"),
//						SecretRef: certificate1.SecretRef,
//					},
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("private_key"),
//						SecretRef: privateKey1.SecretRef,
//					},
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("intermediates"),
//						SecretRef: intermediate1.SecretRef,
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			subnet1, err := networking.LookupSubnet(ctx, &networking.LookupSubnetArgs{
//				Name: pulumi.StringRef("my-subnet"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			lb1, err := loadbalancer.NewLoadBalancer(ctx, "lb_1", &loadbalancer.LoadBalancerArgs{
//				Name:        pulumi.String("loadbalancer"),
//				VipSubnetId: pulumi.String(subnet1.Id),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = loadbalancer.NewListener(ctx, "listener_1", &loadbalancer.ListenerArgs{
//				Name:                   pulumi.String("https"),
//				Protocol:               pulumi.String("TERMINATED_HTTPS"),
//				ProtocolPort:           pulumi.Int(443),
//				LoadbalancerId:         lb1.ID(),
//				DefaultTlsContainerRef: tls1.ContainerRef,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ### Container with the ACL
//
// > **Note** Only read ACLs are supported
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v3/go/openstack/keymanager"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := keymanager.NewContainerV1(ctx, "tls_1", &keymanager.ContainerV1Args{
//				Name: pulumi.String("tls"),
//				Type: pulumi.String("certificate"),
//				SecretRefs: keymanager.ContainerV1SecretRefArray{
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("certificate"),
//						SecretRef: pulumi.Any(certificate1.SecretRef),
//					},
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("private_key"),
//						SecretRef: pulumi.Any(privateKey1.SecretRef),
//					},
//					&keymanager.ContainerV1SecretRefArgs{
//						Name:      pulumi.String("intermediates"),
//						SecretRef: pulumi.Any(intermediate1.SecretRef),
//					},
//				},
//				Acl: &keymanager.ContainerV1AclArgs{
//					Read: &keymanager.ContainerV1AclReadArgs{
//						ProjectAccess: pulumi.Bool(false),
//						Users: pulumi.StringArray{
//							pulumi.String("userid1"),
//							pulumi.String("userid2"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// Containers can be imported using the container id (the last part of the container reference), e.g.:
//
// ```sh
// $ pulumi import openstack:keymanager/containerV1:ContainerV1 container_1 0c6cd26a-c012-4d7b-8034-057c0f1c2953
// ```
type ContainerV1 struct {
	pulumi.CustomResourceState

	// Allows to control an access to a container. Currently only
	// the `read` operation is supported. If not specified, the container is
	// accessible project wide. The `read` structure is described below.
	Acl ContainerV1AclOutput `pulumi:"acl"`
	// The list of the container consumers. The structure is described below.
	Consumers ContainerV1ConsumerArrayOutput `pulumi:"consumers"`
	// The container reference / where to find the container.
	ContainerRef pulumi.StringOutput `pulumi:"containerRef"`
	// The date the container ACL was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The creator of the container.
	CreatorId pulumi.StringOutput `pulumi:"creatorId"`
	// Human-readable name for the Container. Does not have
	// to be unique.
	Name pulumi.StringOutput `pulumi:"name"`
	// The region in which to obtain the V1 KeyManager client.
	// A KeyManager client is needed to create a container. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// V1 container.
	Region pulumi.StringOutput `pulumi:"region"`
	// A set of dictionaries containing references to secrets. The structure is described
	// below.
	SecretRefs ContainerV1SecretRefArrayOutput `pulumi:"secretRefs"`
	// The status of the container.
	Status pulumi.StringOutput `pulumi:"status"`
	// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
	Type pulumi.StringOutput `pulumi:"type"`
	// The date the container ACL was last updated.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewContainerV1 registers a new resource with the given unique name, arguments, and options.
func NewContainerV1(ctx *pulumi.Context,
	name string, args *ContainerV1Args, opts ...pulumi.ResourceOption) (*ContainerV1, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ContainerV1
	err := ctx.RegisterResource("openstack:keymanager/containerV1:ContainerV1", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetContainerV1 gets an existing ContainerV1 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetContainerV1(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ContainerV1State, opts ...pulumi.ResourceOption) (*ContainerV1, error) {
	var resource ContainerV1
	err := ctx.ReadResource("openstack:keymanager/containerV1:ContainerV1", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ContainerV1 resources.
type containerV1State struct {
	// Allows to control an access to a container. Currently only
	// the `read` operation is supported. If not specified, the container is
	// accessible project wide. The `read` structure is described below.
	Acl *ContainerV1Acl `pulumi:"acl"`
	// The list of the container consumers. The structure is described below.
	Consumers []ContainerV1Consumer `pulumi:"consumers"`
	// The container reference / where to find the container.
	ContainerRef *string `pulumi:"containerRef"`
	// The date the container ACL was created.
	CreatedAt *string `pulumi:"createdAt"`
	// The creator of the container.
	CreatorId *string `pulumi:"creatorId"`
	// Human-readable name for the Container. Does not have
	// to be unique.
	Name *string `pulumi:"name"`
	// The region in which to obtain the V1 KeyManager client.
	// A KeyManager client is needed to create a container. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// V1 container.
	Region *string `pulumi:"region"`
	// A set of dictionaries containing references to secrets. The structure is described
	// below.
	SecretRefs []ContainerV1SecretRef `pulumi:"secretRefs"`
	// The status of the container.
	Status *string `pulumi:"status"`
	// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
	Type *string `pulumi:"type"`
	// The date the container ACL was last updated.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type ContainerV1State struct {
	// Allows to control an access to a container. Currently only
	// the `read` operation is supported. If not specified, the container is
	// accessible project wide. The `read` structure is described below.
	Acl ContainerV1AclPtrInput
	// The list of the container consumers. The structure is described below.
	Consumers ContainerV1ConsumerArrayInput
	// The container reference / where to find the container.
	ContainerRef pulumi.StringPtrInput
	// The date the container ACL was created.
	CreatedAt pulumi.StringPtrInput
	// The creator of the container.
	CreatorId pulumi.StringPtrInput
	// Human-readable name for the Container. Does not have
	// to be unique.
	Name pulumi.StringPtrInput
	// The region in which to obtain the V1 KeyManager client.
	// A KeyManager client is needed to create a container. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// V1 container.
	Region pulumi.StringPtrInput
	// A set of dictionaries containing references to secrets. The structure is described
	// below.
	SecretRefs ContainerV1SecretRefArrayInput
	// The status of the container.
	Status pulumi.StringPtrInput
	// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
	Type pulumi.StringPtrInput
	// The date the container ACL was last updated.
	UpdatedAt pulumi.StringPtrInput
}

func (ContainerV1State) ElementType() reflect.Type {
	return reflect.TypeOf((*containerV1State)(nil)).Elem()
}

type containerV1Args struct {
	// Allows to control an access to a container. Currently only
	// the `read` operation is supported. If not specified, the container is
	// accessible project wide. The `read` structure is described below.
	Acl *ContainerV1Acl `pulumi:"acl"`
	// Human-readable name for the Container. Does not have
	// to be unique.
	Name *string `pulumi:"name"`
	// The region in which to obtain the V1 KeyManager client.
	// A KeyManager client is needed to create a container. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// V1 container.
	Region *string `pulumi:"region"`
	// A set of dictionaries containing references to secrets. The structure is described
	// below.
	SecretRefs []ContainerV1SecretRef `pulumi:"secretRefs"`
	// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a ContainerV1 resource.
type ContainerV1Args struct {
	// Allows to control an access to a container. Currently only
	// the `read` operation is supported. If not specified, the container is
	// accessible project wide. The `read` structure is described below.
	Acl ContainerV1AclPtrInput
	// Human-readable name for the Container. Does not have
	// to be unique.
	Name pulumi.StringPtrInput
	// The region in which to obtain the V1 KeyManager client.
	// A KeyManager client is needed to create a container. If omitted, the
	// `region` argument of the provider is used. Changing this creates a new
	// V1 container.
	Region pulumi.StringPtrInput
	// A set of dictionaries containing references to secrets. The structure is described
	// below.
	SecretRefs ContainerV1SecretRefArrayInput
	// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
	Type pulumi.StringInput
}

func (ContainerV1Args) ElementType() reflect.Type {
	return reflect.TypeOf((*containerV1Args)(nil)).Elem()
}

type ContainerV1Input interface {
	pulumi.Input

	ToContainerV1Output() ContainerV1Output
	ToContainerV1OutputWithContext(ctx context.Context) ContainerV1Output
}

func (*ContainerV1) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerV1)(nil)).Elem()
}

func (i *ContainerV1) ToContainerV1Output() ContainerV1Output {
	return i.ToContainerV1OutputWithContext(context.Background())
}

func (i *ContainerV1) ToContainerV1OutputWithContext(ctx context.Context) ContainerV1Output {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerV1Output)
}

// ContainerV1ArrayInput is an input type that accepts ContainerV1Array and ContainerV1ArrayOutput values.
// You can construct a concrete instance of `ContainerV1ArrayInput` via:
//
//	ContainerV1Array{ ContainerV1Args{...} }
type ContainerV1ArrayInput interface {
	pulumi.Input

	ToContainerV1ArrayOutput() ContainerV1ArrayOutput
	ToContainerV1ArrayOutputWithContext(context.Context) ContainerV1ArrayOutput
}

type ContainerV1Array []ContainerV1Input

func (ContainerV1Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerV1)(nil)).Elem()
}

func (i ContainerV1Array) ToContainerV1ArrayOutput() ContainerV1ArrayOutput {
	return i.ToContainerV1ArrayOutputWithContext(context.Background())
}

func (i ContainerV1Array) ToContainerV1ArrayOutputWithContext(ctx context.Context) ContainerV1ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerV1ArrayOutput)
}

// ContainerV1MapInput is an input type that accepts ContainerV1Map and ContainerV1MapOutput values.
// You can construct a concrete instance of `ContainerV1MapInput` via:
//
//	ContainerV1Map{ "key": ContainerV1Args{...} }
type ContainerV1MapInput interface {
	pulumi.Input

	ToContainerV1MapOutput() ContainerV1MapOutput
	ToContainerV1MapOutputWithContext(context.Context) ContainerV1MapOutput
}

type ContainerV1Map map[string]ContainerV1Input

func (ContainerV1Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerV1)(nil)).Elem()
}

func (i ContainerV1Map) ToContainerV1MapOutput() ContainerV1MapOutput {
	return i.ToContainerV1MapOutputWithContext(context.Background())
}

func (i ContainerV1Map) ToContainerV1MapOutputWithContext(ctx context.Context) ContainerV1MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerV1MapOutput)
}

type ContainerV1Output struct{ *pulumi.OutputState }

func (ContainerV1Output) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerV1)(nil)).Elem()
}

func (o ContainerV1Output) ToContainerV1Output() ContainerV1Output {
	return o
}

func (o ContainerV1Output) ToContainerV1OutputWithContext(ctx context.Context) ContainerV1Output {
	return o
}

// Allows to control an access to a container. Currently only
// the `read` operation is supported. If not specified, the container is
// accessible project wide. The `read` structure is described below.
func (o ContainerV1Output) Acl() ContainerV1AclOutput {
	return o.ApplyT(func(v *ContainerV1) ContainerV1AclOutput { return v.Acl }).(ContainerV1AclOutput)
}

// The list of the container consumers. The structure is described below.
func (o ContainerV1Output) Consumers() ContainerV1ConsumerArrayOutput {
	return o.ApplyT(func(v *ContainerV1) ContainerV1ConsumerArrayOutput { return v.Consumers }).(ContainerV1ConsumerArrayOutput)
}

// The container reference / where to find the container.
func (o ContainerV1Output) ContainerRef() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.ContainerRef }).(pulumi.StringOutput)
}

// The date the container ACL was created.
func (o ContainerV1Output) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The creator of the container.
func (o ContainerV1Output) CreatorId() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.CreatorId }).(pulumi.StringOutput)
}

// Human-readable name for the Container. Does not have
// to be unique.
func (o ContainerV1Output) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The region in which to obtain the V1 KeyManager client.
// A KeyManager client is needed to create a container. If omitted, the
// `region` argument of the provider is used. Changing this creates a new
// V1 container.
func (o ContainerV1Output) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// A set of dictionaries containing references to secrets. The structure is described
// below.
func (o ContainerV1Output) SecretRefs() ContainerV1SecretRefArrayOutput {
	return o.ApplyT(func(v *ContainerV1) ContainerV1SecretRefArrayOutput { return v.SecretRefs }).(ContainerV1SecretRefArrayOutput)
}

// The status of the container.
func (o ContainerV1Output) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Used to indicate the type of container. Must be one of `generic`, `rsa` or `certificate`.
func (o ContainerV1Output) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The date the container ACL was last updated.
func (o ContainerV1Output) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ContainerV1) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type ContainerV1ArrayOutput struct{ *pulumi.OutputState }

func (ContainerV1ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerV1)(nil)).Elem()
}

func (o ContainerV1ArrayOutput) ToContainerV1ArrayOutput() ContainerV1ArrayOutput {
	return o
}

func (o ContainerV1ArrayOutput) ToContainerV1ArrayOutputWithContext(ctx context.Context) ContainerV1ArrayOutput {
	return o
}

func (o ContainerV1ArrayOutput) Index(i pulumi.IntInput) ContainerV1Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ContainerV1 {
		return vs[0].([]*ContainerV1)[vs[1].(int)]
	}).(ContainerV1Output)
}

type ContainerV1MapOutput struct{ *pulumi.OutputState }

func (ContainerV1MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerV1)(nil)).Elem()
}

func (o ContainerV1MapOutput) ToContainerV1MapOutput() ContainerV1MapOutput {
	return o
}

func (o ContainerV1MapOutput) ToContainerV1MapOutputWithContext(ctx context.Context) ContainerV1MapOutput {
	return o
}

func (o ContainerV1MapOutput) MapIndex(k pulumi.StringInput) ContainerV1Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ContainerV1 {
		return vs[0].(map[string]*ContainerV1)[vs[1].(string)]
	}).(ContainerV1Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerV1Input)(nil)).Elem(), &ContainerV1{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerV1ArrayInput)(nil)).Elem(), ContainerV1Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerV1MapInput)(nil)).Elem(), ContainerV1Map{})
	pulumi.RegisterOutputType(ContainerV1Output{})
	pulumi.RegisterOutputType(ContainerV1ArrayOutput{})
	pulumi.RegisterOutputType(ContainerV1MapOutput{})
}
