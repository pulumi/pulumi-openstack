// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a V2 VM instance resource within OpenStack.
//
// > **Note:** All arguments including the instance admin password will be stored
// in the raw state as plain-text. Read more about sensitive data in
// state.
//
// ## Example Usage
//
// ### Basic Instance
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "basic", &compute.InstanceArgs{
//				Name:     pulumi.String("basic"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				Metadata: pulumi.StringMap{
//					"this": pulumi.String("that"),
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance With Attached Volume
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/blockstorage"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myvol, err := blockstorage.NewVolume(ctx, "myvol", &blockstorage.VolumeArgs{
//				Name: pulumi.String("myvol"),
//				Size: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			myinstance, err := compute.NewInstance(ctx, "myinstance", &compute.InstanceArgs{
//				Name:     pulumi.String("myinstance"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVolumeAttach(ctx, "attached", &compute.VolumeAttachArgs{
//				InstanceId: myinstance.ID(),
//				VolumeId:   myvol.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Boot From Volume
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "boot-from-volume", &compute.InstanceArgs{
//				Name:     pulumi.String("boot-from-volume"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                pulumi.String("<image-id>"),
//						SourceType:          pulumi.String("image"),
//						VolumeSize:          pulumi.Int(5),
//						BootIndex:           pulumi.Int(0),
//						DestinationType:     pulumi.String("volume"),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Boot From an Existing Volume
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/blockstorage"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myvol, err := blockstorage.NewVolume(ctx, "myvol", &blockstorage.VolumeArgs{
//				Name:    pulumi.String("myvol"),
//				Size:    pulumi.Int(5),
//				ImageId: pulumi.String("<image-id>"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewInstance(ctx, "boot-from-volume", &compute.InstanceArgs{
//				Name:     pulumi.String("bootfromvolume"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                myvol.ID(),
//						SourceType:          pulumi.String("volume"),
//						BootIndex:           pulumi.Int(0),
//						DestinationType:     pulumi.String("volume"),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Boot Instance, Create Volume, and Attach Volume as a Block Device
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "instance_1", &compute.InstanceArgs{
//				Name:     pulumi.String("instance_1"),
//				ImageId:  pulumi.String("<image-id>"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                pulumi.String("<image-id>"),
//						SourceType:          pulumi.String("image"),
//						DestinationType:     pulumi.String("local"),
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						SourceType:          pulumi.String("blank"),
//						DestinationType:     pulumi.String("volume"),
//						VolumeSize:          pulumi.Int(1),
//						BootIndex:           pulumi.Int(1),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Boot Instance and Attach Existing Volume as a Block Device
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/blockstorage"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			volume1, err := blockstorage.NewVolume(ctx, "volume_1", &blockstorage.VolumeArgs{
//				Name: pulumi.String("volume_1"),
//				Size: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewInstance(ctx, "instance_1", &compute.InstanceArgs{
//				Name:     pulumi.String("instance_1"),
//				ImageId:  pulumi.String("<image-id>"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                pulumi.String("<image-id>"),
//						SourceType:          pulumi.String("image"),
//						DestinationType:     pulumi.String("local"),
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                volume1.ID(),
//						SourceType:          pulumi.String("volume"),
//						DestinationType:     pulumi.String("volume"),
//						BootIndex:           pulumi.Int(1),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance With Multiple Networks
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/networking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myip, err := networking.NewFloatingIp(ctx, "myip", &networking.FloatingIpArgs{
//				Pool: pulumi.String("my_pool"),
//			})
//			if err != nil {
//				return err
//			}
//			multi_net, err := compute.NewInstance(ctx, "multi-net", &compute.InstanceArgs{
//				Name:     pulumi.String("multi-net"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_first_network"),
//					},
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_second_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			vm_port := pulumi.All(multi_net.ID(), multi_net.Networks).ApplyT(func(_args []interface{}) (networking.GetPortResult, error) {
//				id := _args[0].(string)
//				networks := _args[1].([]compute.InstanceNetwork)
//				return networking.GetPortResult(interface{}(networking.LookupPort(ctx, &networking.LookupPortArgs{
//					DeviceId:  pulumi.StringRef(pulumi.StringRef(id)),
//					NetworkId: pulumi.StringRef(pulumi.StringRef(networks[1].Uuid)),
//				}, nil))), nil
//			}).(networking.GetPortResultOutput)
//			_, err = networking.NewFloatingIpAssociate(ctx, "fip_vm", &networking.FloatingIpAssociateArgs{
//				FloatingIp: myip.Address,
//				PortId: pulumi.String(vm_port.ApplyT(func(vm_port networking.GetPortResult) (*string, error) {
//					return &vm_port.Id, nil
//				}).(pulumi.StringPtrOutput)),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance With Personality
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "personality", &compute.InstanceArgs{
//				Name:     pulumi.String("personality"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				Personalities: compute.InstancePersonalityArray{
//					&compute.InstancePersonalityArgs{
//						File:    pulumi.String("/path/to/file/on/instance.txt"),
//						Content: pulumi.String("contents of file"),
//					},
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance with Multiple Ephemeral Disks
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "multi-eph", &compute.InstanceArgs{
//				Name:     pulumi.String("multi_eph"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("image"),
//						Uuid:                pulumi.String("<image-id>"),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(-1),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("blank"),
//						VolumeSize:          pulumi.Int(1),
//						GuestFormat:         pulumi.String("ext4"),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(-1),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("blank"),
//						VolumeSize:          pulumi.Int(1),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance with Boot Disk and Swap Disk
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			flavor_with_swap, err := compute.NewFlavor(ctx, "flavor-with-swap", &compute.FlavorArgs{
//				Name:  pulumi.String("flavor-with-swap"),
//				Ram:   pulumi.Int(8096),
//				Vcpus: pulumi.Int(2),
//				Disk:  pulumi.Int(20),
//				Swap:  pulumi.Int(4096),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewInstance(ctx, "vm-swap", &compute.InstanceArgs{
//				Name:     pulumi.String("vm_swap"),
//				FlavorId: flavor_with_swap.ID(),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("image"),
//						Uuid:                pulumi.String("<image-id>"),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(-1),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("blank"),
//						GuestFormat:         pulumi.String("swap"),
//						VolumeSize:          pulumi.Int(4),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instance with User Data (cloud-init)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "instance_1", &compute.InstanceArgs{
//				Name:     pulumi.String("basic"),
//				ImageId:  pulumi.String("ad091b52-742f-469e-8f3c-fd81cadf0743"),
//				FlavorId: pulumi.String("3"),
//				KeyPair:  pulumi.String("my_key_pair_name"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				UserData: pulumi.String("#cloud-config\nhostname: instance_1.example.com\nfqdn: instance_1.example.com"),
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("my_network"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// `userData` can come from a variety of sources: inline, read in from the `file`
// function, or the `templateCloudinitConfig` resource.
//
// ## Notes
//
// ### Multiple Ephemeral Disks
//
// It's possible to specify multiple `blockDevice` entries to create an instance
// with multiple ephemeral (local) disks. In order to create multiple ephemeral
// disks, the sum of the total amount of ephemeral space must be less than or
// equal to what the chosen flavor supports.
//
// The following example shows how to create an instance with multiple ephemeral
// disks:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "foo", &compute.InstanceArgs{
//				Name: pulumi.String("terraform-test"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("image"),
//						Uuid:                pulumi.String("<image uuid>"),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(-1),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("blank"),
//						VolumeSize:          pulumi.Int(1),
//					},
//					&compute.InstanceBlockDeviceArgs{
//						BootIndex:           pulumi.Int(-1),
//						DeleteOnTermination: pulumi.Bool(true),
//						DestinationType:     pulumi.String("local"),
//						SourceType:          pulumi.String("blank"),
//						VolumeSize:          pulumi.Int(1),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instances and Security Groups
//
// When referencing a security group resource in an instance resource, always
// use the _name_ of the security group. If you specify the ID of the security
// group, Terraform will remove and reapply the security group upon each call.
// This is because the OpenStack Compute API returns the names of the associated
// security groups and not their IDs.
//
// Note the following example:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/networking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			sg1, err := networking.NewSecGroup(ctx, "sg_1", &networking.SecGroupArgs{
//				Name: pulumi.String("sg_1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewInstance(ctx, "foo", &compute.InstanceArgs{
//				Name: pulumi.String("terraform-test"),
//				SecurityGroups: pulumi.StringArray{
//					sg1.Name,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instances and Ports
//
// Neutron Ports are a great feature and provide a lot of functionality. However,
// there are some notes to be aware of when mixing Instances and Ports:
//
// * In OpenStack environments prior to the Kilo release, deleting or recreating
// an Instance will cause the Instance's Port(s) to be deleted. One way of working
// around this is to taint any Port(s) used in Instances which are to be recreated.
// See [here](https://review.openstack.org/#/c/126309/) for further information.
//
// * When attaching an Instance to one or more networks using Ports, place the
// security groups on the Port and not the Instance. If you place the security
// groups on the Instance, the security groups will not be applied upon creation,
// but they will be applied upon a refresh. This is a known OpenStack bug.
//
// * Network IP information is not available within an instance for networks that
// are attached with Ports. This is mostly due to the flexibility Neutron Ports
// provide when it comes to IP addresses. For example, a Neutron Port can have
// multiple Fixed IP addresses associated with it. It's not possible to know which
// single IP address the user would want returned to the Instance's state
// information. Therefore, in order for a Provisioner to connect to an Instance
// via it's network Port, customize the `connection` information:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/networking"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			port1, err := networking.NewPort(ctx, "port_1", &networking.PortArgs{
//				Name:         pulumi.String("port_1"),
//				AdminStateUp: pulumi.Bool(true),
//				NetworkId:    pulumi.String("0a1d0a27-cffa-4de3-92c5-9d3fd3f2e74d"),
//				SecurityGroupIds: pulumi.StringArray{
//					pulumi.String("2f02d20a-8dca-49b7-b26f-b6ce9fddaf4f"),
//					pulumi.String("ca1e5ed7-dae8-4605-987b-fadaeeb30461"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewInstance(ctx, "instance_1", &compute.InstanceArgs{
//				Name: pulumi.String("instance_1"),
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Port: port1.ID(),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Instances and Networks
//
// Instances almost always require a network. Here are some notes to be aware of
// with how Instances and Networks relate:
//
// * In scenarios where you only have one network available, you can create an
// instance without specifying a `network` block. OpenStack will automatically
// launch the instance on this network.
//
// * If you have access to more than one network, you will need to specify a network
// with a `network` block. Not specifying a network will result in the following
// error:
//
//   - If you intend to use the `compute.InterfaceAttach` resource,
//     you still need to make sure one of the above points is satisfied. An instance
//     cannot be created without a valid network configuration even if you intend to
//     use `compute.InterfaceAttach` after the instance has been created.
//
// ## Importing instances
//
// Importing instances can be tricky, since the nova api does not offer all
// information provided at creation time for later retrieval.
// Network interface attachment order, and number and sizes of ephemeral
// disks are examples of this.
//
// ### Importing basic instance
// Assume you want to import an instance with one ephemeral root disk,
// and one network interface.
//
// Your configuration would look like the following:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "basic_instance", &compute.InstanceArgs{
//				Name:     pulumi.String("basic"),
//				FlavorId: pulumi.String("<flavor_id>"),
//				KeyPair:  pulumi.String("<keyname>"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				ImageId: pulumi.String("<image_id>"),
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("<network_name>"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// Then you execute
//
// ### Importing an instance with multiple emphemeral disks
//
// The importer cannot read the emphemeral disk configuration
// of an instance, so just specify imageId as in the configuration
// of the basic instance example.
//
// ### Importing instance with multiple network interfaces.
//
// Nova returns the network interfaces grouped by network, thus not in creation
// order.
// That means that if you have multiple network interfaces you must take
// care of the order of networks in your configuration.
//
// As example we want to import an instance with one ephemeral root disk,
// and 3 network interfaces.
//
// # Examples
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := compute.NewInstance(ctx, "boot-from-volume", &compute.InstanceArgs{
//				Name:     pulumi.String("boot-from-volume"),
//				FlavorId: pulumi.String("<flavor_id"),
//				KeyPair:  pulumi.String("<keyname>"),
//				ImageId:  pulumi.String("<image_id>"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("<network1>"),
//					},
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("<network2>"),
//					},
//					&compute.InstanceNetworkArgs{
//						Name:      pulumi.String("<network1>"),
//						FixedIpV4: pulumi.String("<fixed_ip_v4>"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// In the above configuration the networks are out of order compared to what nova
// and thus the import code returns, which means the plan will not
// be empty after import.
//
// So either with care check the plan and modify configuration, or read the
// network order in the state file after import and modify your
// configuration accordingly.
//
//   - A note on ports. If you have created a neutron port independent of an
//     instance, then the import code has no way to detect that the port is created
//     idenpendently, and therefore on deletion of imported instances you might have
//     port resources in your project, which you expected to be created by the
//     instance and thus to also be deleted with the instance.
//
// ### Importing instances with multiple block storage volumes.
//
// We have an instance with two block storage volumes, one bootable and one
// non-bootable.
// Note that we only configure the bootable device as block_device.
// The other volumes can be specified as `blockstorage.Volume`
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/blockstorage"
//	"github.com/pulumi/pulumi-openstack/sdk/v5/go/openstack/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			instance2, err := compute.NewInstance(ctx, "instance_2", &compute.InstanceArgs{
//				Name:     pulumi.String("instance_2"),
//				ImageId:  pulumi.String("<image_id>"),
//				FlavorId: pulumi.String("<flavor_id>"),
//				KeyPair:  pulumi.String("<keyname>"),
//				SecurityGroups: pulumi.StringArray{
//					pulumi.String("default"),
//				},
//				BlockDevices: compute.InstanceBlockDeviceArray{
//					&compute.InstanceBlockDeviceArgs{
//						Uuid:                pulumi.String("<image_id>"),
//						SourceType:          pulumi.String("image"),
//						DestinationType:     pulumi.String("volume"),
//						BootIndex:           pulumi.Int(0),
//						DeleteOnTermination: pulumi.Bool(true),
//					},
//				},
//				Networks: compute.InstanceNetworkArray{
//					&compute.InstanceNetworkArgs{
//						Name: pulumi.String("<network_name>"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			volume1, err := blockstorage.NewVolume(ctx, "volume_1", &blockstorage.VolumeArgs{
//				Size: pulumi.Int(1),
//				Name: pulumi.String("<vol_name>"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVolumeAttach(ctx, "va_1", &compute.VolumeAttachArgs{
//				VolumeId:   volume1.ID(),
//				InstanceId: instance2.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// To import the instance outlined in the above configuration
// do the following:
//
//   - A note on block storage volumes, the importer does not read
//     deleteOnTermination flag, and always assumes true. If you
//     import an instance created with deleteOnTermination false,
//     you end up with "orphaned" volumes after destruction of
//     instances.
type Instance struct {
	pulumi.CustomResourceState

	// The first detected Fixed IPv4 address.
	AccessIpV4 pulumi.StringOutput `pulumi:"accessIpV4"`
	// The first detected Fixed IPv6 address.
	AccessIpV6 pulumi.StringOutput `pulumi:"accessIpV6"`
	// The administrative password to assign to the server.
	// Changing this changes the root password on the existing server.
	AdminPass pulumi.StringPtrOutput `pulumi:"adminPass"`
	// Contains all instance metadata, even metadata not set
	// by Terraform.
	AllMetadata pulumi.StringMapOutput `pulumi:"allMetadata"`
	// The collection of tags assigned on the instance, which have
	// been explicitly and implicitly added.
	AllTags pulumi.StringArrayOutput `pulumi:"allTags"`
	// The availability zone in which to create
	// the server. Conflicts with `availabilityZoneHints`. Changing this creates
	// a new server.
	AvailabilityZone pulumi.StringOutput `pulumi:"availabilityZone"`
	// The availability zone in which to
	// create the server. This argument is preferred to `availabilityZone`, when
	// scheduling the server on a
	// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
	// host or node. Conflicts with `availabilityZone`. Changing this creates a
	// new server.
	AvailabilityZoneHints pulumi.StringPtrOutput `pulumi:"availabilityZoneHints"`
	// Configuration of block devices. The blockDevice
	// structure is documented below. Changing this creates a new server.
	// You can specify multiple block devices which will create an instance with
	// multiple disks. This configuration is very flexible, so please see the
	// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
	// for more information.
	BlockDevices InstanceBlockDeviceArrayOutput `pulumi:"blockDevices"`
	// Whether to use the configDrive feature to
	// configure the instance. Changing this creates a new server.
	ConfigDrive pulumi.BoolPtrOutput `pulumi:"configDrive"`
	// The creation time of the instance.
	Created pulumi.StringOutput `pulumi:"created"`
	// The flavor ID of
	// the desired flavor for the server. Changing this resizes the existing server.
	FlavorId pulumi.StringOutput `pulumi:"flavorId"`
	// The name of the
	// desired flavor for the server. Changing this resizes the existing server.
	FlavorName pulumi.StringOutput `pulumi:"flavorName"`
	// Whether to force the OpenStack instance to be
	// forcefully deleted. This is useful for environments that have reclaim / soft
	// deletion enabled.
	ForceDelete pulumi.BoolPtrOutput `pulumi:"forceDelete"`
	// Specifies the exact hypervisor hostname on
	// which to create the instance. When provided, this parameter is included in
	// the request to Nova, directing the scheduler to launch the instance on the
	// specified host. Note: This option requires administrative privileges and a
	// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
	// this value forces a new instance to be created.
	HypervisorHostname pulumi.StringOutput `pulumi:"hypervisorHostname"`
	// (Optional; Required if `imageName` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The image ID of
	// the desired image for the server. Changing this rebuilds the existing
	// server.
	ImageId pulumi.StringOutput `pulumi:"imageId"`
	// (Optional; Required if `imageId` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The name of the
	// desired image for the server. Changing this rebuilds the existing server.
	ImageName pulumi.StringOutput `pulumi:"imageName"`
	// The name of a key pair to put on the server. The key
	// pair must already be created and associated with the tenant's account.
	// Changing this creates a new server.
	KeyPair pulumi.StringPtrOutput `pulumi:"keyPair"`
	// Metadata key/value pairs to make available from
	// within the instance. Changing this updates the existing server metadata.
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// A unique name for the resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Special string for `network` option to create
	// the server. `networkMode` can be `"auto"` or `"none"`.
	// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
	NetworkMode pulumi.StringPtrOutput `pulumi:"networkMode"`
	// An array of one or more networks to attach to the
	// instance. The network object structure is documented below. Changing this
	// creates a new server.
	Networks InstanceNetworkArrayOutput `pulumi:"networks"`
	// Customize the personality of an instance by
	// defining one or more files and their contents. The personality structure is
	// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
	// the existing server.
	Personalities InstancePersonalityArrayOutput `pulumi:"personalities"`
	// Provide the VM state. Only 'active', 'shutoff', 'paused'
	// and 'shelved_offloaded' are supported values.
	// *Note*: If the initial powerState is the shutoff or paused
	// the VM will be stopped immediately after build and the provisioners like
	// remote-exec or files are not supported.
	PowerState pulumi.StringPtrOutput `pulumi:"powerState"`
	// The region in which to create the server instance. If
	// omitted, the `region` argument of the provider is used. Changing this
	// creates a new server.
	Region pulumi.StringOutput `pulumi:"region"`
	// Provide the Nova scheduler with hints on how
	// the instance should be launched. The available hints are described below.
	SchedulerHints InstanceSchedulerHintArrayOutput `pulumi:"schedulerHints"`
	// An array of one or more security group names
	// to associate with the server. Changing this results in adding/removing
	// security groups from the existing server. *Note*: When attaching the
	// instance to networks using Ports, place the security groups on the Port
	// and not the instance. *Note*: Names should be used and not ids, as ids
	// trigger unnecessary updates.
	SecurityGroups pulumi.StringArrayOutput `pulumi:"securityGroups"`
	// Whether to try stop instance gracefully
	// before destroying it, thus giving chance for guest OS daemons to stop correctly.
	// If instance doesn't stop within timeout, it will be destroyed anyway.
	StopBeforeDestroy pulumi.BoolPtrOutput `pulumi:"stopBeforeDestroy"`
	// A set of string tags for the instance. Changing this
	// updates the existing instance tags.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The time when the instance was last updated.
	Updated pulumi.StringOutput `pulumi:"updated"`
	// The user data to provide when launching the instance.
	// Changing this creates a new server.
	UserData pulumi.StringPtrOutput `pulumi:"userData"`
	// Map of additional vendor-specific options.
	// Supported options are described below.
	VendorOptions InstanceVendorOptionsPtrOutput `pulumi:"vendorOptions"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil {
		args = &InstanceArgs{}
	}

	if args.AdminPass != nil {
		args.AdminPass = pulumi.ToSecret(args.AdminPass).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"adminPass",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Instance
	err := ctx.RegisterResource("openstack:compute/instance:Instance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	var resource Instance
	err := ctx.ReadResource("openstack:compute/instance:Instance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type instanceState struct {
	// The first detected Fixed IPv4 address.
	AccessIpV4 *string `pulumi:"accessIpV4"`
	// The first detected Fixed IPv6 address.
	AccessIpV6 *string `pulumi:"accessIpV6"`
	// The administrative password to assign to the server.
	// Changing this changes the root password on the existing server.
	AdminPass *string `pulumi:"adminPass"`
	// Contains all instance metadata, even metadata not set
	// by Terraform.
	AllMetadata map[string]string `pulumi:"allMetadata"`
	// The collection of tags assigned on the instance, which have
	// been explicitly and implicitly added.
	AllTags []string `pulumi:"allTags"`
	// The availability zone in which to create
	// the server. Conflicts with `availabilityZoneHints`. Changing this creates
	// a new server.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The availability zone in which to
	// create the server. This argument is preferred to `availabilityZone`, when
	// scheduling the server on a
	// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
	// host or node. Conflicts with `availabilityZone`. Changing this creates a
	// new server.
	AvailabilityZoneHints *string `pulumi:"availabilityZoneHints"`
	// Configuration of block devices. The blockDevice
	// structure is documented below. Changing this creates a new server.
	// You can specify multiple block devices which will create an instance with
	// multiple disks. This configuration is very flexible, so please see the
	// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
	// for more information.
	BlockDevices []InstanceBlockDevice `pulumi:"blockDevices"`
	// Whether to use the configDrive feature to
	// configure the instance. Changing this creates a new server.
	ConfigDrive *bool `pulumi:"configDrive"`
	// The creation time of the instance.
	Created *string `pulumi:"created"`
	// The flavor ID of
	// the desired flavor for the server. Changing this resizes the existing server.
	FlavorId *string `pulumi:"flavorId"`
	// The name of the
	// desired flavor for the server. Changing this resizes the existing server.
	FlavorName *string `pulumi:"flavorName"`
	// Whether to force the OpenStack instance to be
	// forcefully deleted. This is useful for environments that have reclaim / soft
	// deletion enabled.
	ForceDelete *bool `pulumi:"forceDelete"`
	// Specifies the exact hypervisor hostname on
	// which to create the instance. When provided, this parameter is included in
	// the request to Nova, directing the scheduler to launch the instance on the
	// specified host. Note: This option requires administrative privileges and a
	// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
	// this value forces a new instance to be created.
	HypervisorHostname *string `pulumi:"hypervisorHostname"`
	// (Optional; Required if `imageName` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The image ID of
	// the desired image for the server. Changing this rebuilds the existing
	// server.
	ImageId *string `pulumi:"imageId"`
	// (Optional; Required if `imageId` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The name of the
	// desired image for the server. Changing this rebuilds the existing server.
	ImageName *string `pulumi:"imageName"`
	// The name of a key pair to put on the server. The key
	// pair must already be created and associated with the tenant's account.
	// Changing this creates a new server.
	KeyPair *string `pulumi:"keyPair"`
	// Metadata key/value pairs to make available from
	// within the instance. Changing this updates the existing server metadata.
	Metadata map[string]string `pulumi:"metadata"`
	// A unique name for the resource.
	Name *string `pulumi:"name"`
	// Special string for `network` option to create
	// the server. `networkMode` can be `"auto"` or `"none"`.
	// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
	NetworkMode *string `pulumi:"networkMode"`
	// An array of one or more networks to attach to the
	// instance. The network object structure is documented below. Changing this
	// creates a new server.
	Networks []InstanceNetwork `pulumi:"networks"`
	// Customize the personality of an instance by
	// defining one or more files and their contents. The personality structure is
	// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
	// the existing server.
	Personalities []InstancePersonality `pulumi:"personalities"`
	// Provide the VM state. Only 'active', 'shutoff', 'paused'
	// and 'shelved_offloaded' are supported values.
	// *Note*: If the initial powerState is the shutoff or paused
	// the VM will be stopped immediately after build and the provisioners like
	// remote-exec or files are not supported.
	PowerState *string `pulumi:"powerState"`
	// The region in which to create the server instance. If
	// omitted, the `region` argument of the provider is used. Changing this
	// creates a new server.
	Region *string `pulumi:"region"`
	// Provide the Nova scheduler with hints on how
	// the instance should be launched. The available hints are described below.
	SchedulerHints []InstanceSchedulerHint `pulumi:"schedulerHints"`
	// An array of one or more security group names
	// to associate with the server. Changing this results in adding/removing
	// security groups from the existing server. *Note*: When attaching the
	// instance to networks using Ports, place the security groups on the Port
	// and not the instance. *Note*: Names should be used and not ids, as ids
	// trigger unnecessary updates.
	SecurityGroups []string `pulumi:"securityGroups"`
	// Whether to try stop instance gracefully
	// before destroying it, thus giving chance for guest OS daemons to stop correctly.
	// If instance doesn't stop within timeout, it will be destroyed anyway.
	StopBeforeDestroy *bool `pulumi:"stopBeforeDestroy"`
	// A set of string tags for the instance. Changing this
	// updates the existing instance tags.
	Tags []string `pulumi:"tags"`
	// The time when the instance was last updated.
	Updated *string `pulumi:"updated"`
	// The user data to provide when launching the instance.
	// Changing this creates a new server.
	UserData *string `pulumi:"userData"`
	// Map of additional vendor-specific options.
	// Supported options are described below.
	VendorOptions *InstanceVendorOptions `pulumi:"vendorOptions"`
}

type InstanceState struct {
	// The first detected Fixed IPv4 address.
	AccessIpV4 pulumi.StringPtrInput
	// The first detected Fixed IPv6 address.
	AccessIpV6 pulumi.StringPtrInput
	// The administrative password to assign to the server.
	// Changing this changes the root password on the existing server.
	AdminPass pulumi.StringPtrInput
	// Contains all instance metadata, even metadata not set
	// by Terraform.
	AllMetadata pulumi.StringMapInput
	// The collection of tags assigned on the instance, which have
	// been explicitly and implicitly added.
	AllTags pulumi.StringArrayInput
	// The availability zone in which to create
	// the server. Conflicts with `availabilityZoneHints`. Changing this creates
	// a new server.
	AvailabilityZone pulumi.StringPtrInput
	// The availability zone in which to
	// create the server. This argument is preferred to `availabilityZone`, when
	// scheduling the server on a
	// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
	// host or node. Conflicts with `availabilityZone`. Changing this creates a
	// new server.
	AvailabilityZoneHints pulumi.StringPtrInput
	// Configuration of block devices. The blockDevice
	// structure is documented below. Changing this creates a new server.
	// You can specify multiple block devices which will create an instance with
	// multiple disks. This configuration is very flexible, so please see the
	// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
	// for more information.
	BlockDevices InstanceBlockDeviceArrayInput
	// Whether to use the configDrive feature to
	// configure the instance. Changing this creates a new server.
	ConfigDrive pulumi.BoolPtrInput
	// The creation time of the instance.
	Created pulumi.StringPtrInput
	// The flavor ID of
	// the desired flavor for the server. Changing this resizes the existing server.
	FlavorId pulumi.StringPtrInput
	// The name of the
	// desired flavor for the server. Changing this resizes the existing server.
	FlavorName pulumi.StringPtrInput
	// Whether to force the OpenStack instance to be
	// forcefully deleted. This is useful for environments that have reclaim / soft
	// deletion enabled.
	ForceDelete pulumi.BoolPtrInput
	// Specifies the exact hypervisor hostname on
	// which to create the instance. When provided, this parameter is included in
	// the request to Nova, directing the scheduler to launch the instance on the
	// specified host. Note: This option requires administrative privileges and a
	// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
	// this value forces a new instance to be created.
	HypervisorHostname pulumi.StringPtrInput
	// (Optional; Required if `imageName` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The image ID of
	// the desired image for the server. Changing this rebuilds the existing
	// server.
	ImageId pulumi.StringPtrInput
	// (Optional; Required if `imageId` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The name of the
	// desired image for the server. Changing this rebuilds the existing server.
	ImageName pulumi.StringPtrInput
	// The name of a key pair to put on the server. The key
	// pair must already be created and associated with the tenant's account.
	// Changing this creates a new server.
	KeyPair pulumi.StringPtrInput
	// Metadata key/value pairs to make available from
	// within the instance. Changing this updates the existing server metadata.
	Metadata pulumi.StringMapInput
	// A unique name for the resource.
	Name pulumi.StringPtrInput
	// Special string for `network` option to create
	// the server. `networkMode` can be `"auto"` or `"none"`.
	// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
	NetworkMode pulumi.StringPtrInput
	// An array of one or more networks to attach to the
	// instance. The network object structure is documented below. Changing this
	// creates a new server.
	Networks InstanceNetworkArrayInput
	// Customize the personality of an instance by
	// defining one or more files and their contents. The personality structure is
	// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
	// the existing server.
	Personalities InstancePersonalityArrayInput
	// Provide the VM state. Only 'active', 'shutoff', 'paused'
	// and 'shelved_offloaded' are supported values.
	// *Note*: If the initial powerState is the shutoff or paused
	// the VM will be stopped immediately after build and the provisioners like
	// remote-exec or files are not supported.
	PowerState pulumi.StringPtrInput
	// The region in which to create the server instance. If
	// omitted, the `region` argument of the provider is used. Changing this
	// creates a new server.
	Region pulumi.StringPtrInput
	// Provide the Nova scheduler with hints on how
	// the instance should be launched. The available hints are described below.
	SchedulerHints InstanceSchedulerHintArrayInput
	// An array of one or more security group names
	// to associate with the server. Changing this results in adding/removing
	// security groups from the existing server. *Note*: When attaching the
	// instance to networks using Ports, place the security groups on the Port
	// and not the instance. *Note*: Names should be used and not ids, as ids
	// trigger unnecessary updates.
	SecurityGroups pulumi.StringArrayInput
	// Whether to try stop instance gracefully
	// before destroying it, thus giving chance for guest OS daemons to stop correctly.
	// If instance doesn't stop within timeout, it will be destroyed anyway.
	StopBeforeDestroy pulumi.BoolPtrInput
	// A set of string tags for the instance. Changing this
	// updates the existing instance tags.
	Tags pulumi.StringArrayInput
	// The time when the instance was last updated.
	Updated pulumi.StringPtrInput
	// The user data to provide when launching the instance.
	// Changing this creates a new server.
	UserData pulumi.StringPtrInput
	// Map of additional vendor-specific options.
	// Supported options are described below.
	VendorOptions InstanceVendorOptionsPtrInput
}

func (InstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceState)(nil)).Elem()
}

type instanceArgs struct {
	// The administrative password to assign to the server.
	// Changing this changes the root password on the existing server.
	AdminPass *string `pulumi:"adminPass"`
	// The availability zone in which to create
	// the server. Conflicts with `availabilityZoneHints`. Changing this creates
	// a new server.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The availability zone in which to
	// create the server. This argument is preferred to `availabilityZone`, when
	// scheduling the server on a
	// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
	// host or node. Conflicts with `availabilityZone`. Changing this creates a
	// new server.
	AvailabilityZoneHints *string `pulumi:"availabilityZoneHints"`
	// Configuration of block devices. The blockDevice
	// structure is documented below. Changing this creates a new server.
	// You can specify multiple block devices which will create an instance with
	// multiple disks. This configuration is very flexible, so please see the
	// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
	// for more information.
	BlockDevices []InstanceBlockDevice `pulumi:"blockDevices"`
	// Whether to use the configDrive feature to
	// configure the instance. Changing this creates a new server.
	ConfigDrive *bool `pulumi:"configDrive"`
	// The flavor ID of
	// the desired flavor for the server. Changing this resizes the existing server.
	FlavorId *string `pulumi:"flavorId"`
	// The name of the
	// desired flavor for the server. Changing this resizes the existing server.
	FlavorName *string `pulumi:"flavorName"`
	// Whether to force the OpenStack instance to be
	// forcefully deleted. This is useful for environments that have reclaim / soft
	// deletion enabled.
	ForceDelete *bool `pulumi:"forceDelete"`
	// Specifies the exact hypervisor hostname on
	// which to create the instance. When provided, this parameter is included in
	// the request to Nova, directing the scheduler to launch the instance on the
	// specified host. Note: This option requires administrative privileges and a
	// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
	// this value forces a new instance to be created.
	HypervisorHostname *string `pulumi:"hypervisorHostname"`
	// (Optional; Required if `imageName` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The image ID of
	// the desired image for the server. Changing this rebuilds the existing
	// server.
	ImageId *string `pulumi:"imageId"`
	// (Optional; Required if `imageId` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The name of the
	// desired image for the server. Changing this rebuilds the existing server.
	ImageName *string `pulumi:"imageName"`
	// The name of a key pair to put on the server. The key
	// pair must already be created and associated with the tenant's account.
	// Changing this creates a new server.
	KeyPair *string `pulumi:"keyPair"`
	// Metadata key/value pairs to make available from
	// within the instance. Changing this updates the existing server metadata.
	Metadata map[string]string `pulumi:"metadata"`
	// A unique name for the resource.
	Name *string `pulumi:"name"`
	// Special string for `network` option to create
	// the server. `networkMode` can be `"auto"` or `"none"`.
	// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
	NetworkMode *string `pulumi:"networkMode"`
	// An array of one or more networks to attach to the
	// instance. The network object structure is documented below. Changing this
	// creates a new server.
	Networks []InstanceNetwork `pulumi:"networks"`
	// Customize the personality of an instance by
	// defining one or more files and their contents. The personality structure is
	// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
	// the existing server.
	Personalities []InstancePersonality `pulumi:"personalities"`
	// Provide the VM state. Only 'active', 'shutoff', 'paused'
	// and 'shelved_offloaded' are supported values.
	// *Note*: If the initial powerState is the shutoff or paused
	// the VM will be stopped immediately after build and the provisioners like
	// remote-exec or files are not supported.
	PowerState *string `pulumi:"powerState"`
	// The region in which to create the server instance. If
	// omitted, the `region` argument of the provider is used. Changing this
	// creates a new server.
	Region *string `pulumi:"region"`
	// Provide the Nova scheduler with hints on how
	// the instance should be launched. The available hints are described below.
	SchedulerHints []InstanceSchedulerHint `pulumi:"schedulerHints"`
	// An array of one or more security group names
	// to associate with the server. Changing this results in adding/removing
	// security groups from the existing server. *Note*: When attaching the
	// instance to networks using Ports, place the security groups on the Port
	// and not the instance. *Note*: Names should be used and not ids, as ids
	// trigger unnecessary updates.
	SecurityGroups []string `pulumi:"securityGroups"`
	// Whether to try stop instance gracefully
	// before destroying it, thus giving chance for guest OS daemons to stop correctly.
	// If instance doesn't stop within timeout, it will be destroyed anyway.
	StopBeforeDestroy *bool `pulumi:"stopBeforeDestroy"`
	// A set of string tags for the instance. Changing this
	// updates the existing instance tags.
	Tags []string `pulumi:"tags"`
	// The user data to provide when launching the instance.
	// Changing this creates a new server.
	UserData *string `pulumi:"userData"`
	// Map of additional vendor-specific options.
	// Supported options are described below.
	VendorOptions *InstanceVendorOptions `pulumi:"vendorOptions"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	// The administrative password to assign to the server.
	// Changing this changes the root password on the existing server.
	AdminPass pulumi.StringPtrInput
	// The availability zone in which to create
	// the server. Conflicts with `availabilityZoneHints`. Changing this creates
	// a new server.
	AvailabilityZone pulumi.StringPtrInput
	// The availability zone in which to
	// create the server. This argument is preferred to `availabilityZone`, when
	// scheduling the server on a
	// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
	// host or node. Conflicts with `availabilityZone`. Changing this creates a
	// new server.
	AvailabilityZoneHints pulumi.StringPtrInput
	// Configuration of block devices. The blockDevice
	// structure is documented below. Changing this creates a new server.
	// You can specify multiple block devices which will create an instance with
	// multiple disks. This configuration is very flexible, so please see the
	// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
	// for more information.
	BlockDevices InstanceBlockDeviceArrayInput
	// Whether to use the configDrive feature to
	// configure the instance. Changing this creates a new server.
	ConfigDrive pulumi.BoolPtrInput
	// The flavor ID of
	// the desired flavor for the server. Changing this resizes the existing server.
	FlavorId pulumi.StringPtrInput
	// The name of the
	// desired flavor for the server. Changing this resizes the existing server.
	FlavorName pulumi.StringPtrInput
	// Whether to force the OpenStack instance to be
	// forcefully deleted. This is useful for environments that have reclaim / soft
	// deletion enabled.
	ForceDelete pulumi.BoolPtrInput
	// Specifies the exact hypervisor hostname on
	// which to create the instance. When provided, this parameter is included in
	// the request to Nova, directing the scheduler to launch the instance on the
	// specified host. Note: This option requires administrative privileges and a
	// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
	// this value forces a new instance to be created.
	HypervisorHostname pulumi.StringPtrInput
	// (Optional; Required if `imageName` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The image ID of
	// the desired image for the server. Changing this rebuilds the existing
	// server.
	ImageId pulumi.StringPtrInput
	// (Optional; Required if `imageId` is empty and not booting
	// from a volume. Do not specify if booting from a volume.) The name of the
	// desired image for the server. Changing this rebuilds the existing server.
	ImageName pulumi.StringPtrInput
	// The name of a key pair to put on the server. The key
	// pair must already be created and associated with the tenant's account.
	// Changing this creates a new server.
	KeyPair pulumi.StringPtrInput
	// Metadata key/value pairs to make available from
	// within the instance. Changing this updates the existing server metadata.
	Metadata pulumi.StringMapInput
	// A unique name for the resource.
	Name pulumi.StringPtrInput
	// Special string for `network` option to create
	// the server. `networkMode` can be `"auto"` or `"none"`.
	// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
	NetworkMode pulumi.StringPtrInput
	// An array of one or more networks to attach to the
	// instance. The network object structure is documented below. Changing this
	// creates a new server.
	Networks InstanceNetworkArrayInput
	// Customize the personality of an instance by
	// defining one or more files and their contents. The personality structure is
	// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
	// the existing server.
	Personalities InstancePersonalityArrayInput
	// Provide the VM state. Only 'active', 'shutoff', 'paused'
	// and 'shelved_offloaded' are supported values.
	// *Note*: If the initial powerState is the shutoff or paused
	// the VM will be stopped immediately after build and the provisioners like
	// remote-exec or files are not supported.
	PowerState pulumi.StringPtrInput
	// The region in which to create the server instance. If
	// omitted, the `region` argument of the provider is used. Changing this
	// creates a new server.
	Region pulumi.StringPtrInput
	// Provide the Nova scheduler with hints on how
	// the instance should be launched. The available hints are described below.
	SchedulerHints InstanceSchedulerHintArrayInput
	// An array of one or more security group names
	// to associate with the server. Changing this results in adding/removing
	// security groups from the existing server. *Note*: When attaching the
	// instance to networks using Ports, place the security groups on the Port
	// and not the instance. *Note*: Names should be used and not ids, as ids
	// trigger unnecessary updates.
	SecurityGroups pulumi.StringArrayInput
	// Whether to try stop instance gracefully
	// before destroying it, thus giving chance for guest OS daemons to stop correctly.
	// If instance doesn't stop within timeout, it will be destroyed anyway.
	StopBeforeDestroy pulumi.BoolPtrInput
	// A set of string tags for the instance. Changing this
	// updates the existing instance tags.
	Tags pulumi.StringArrayInput
	// The user data to provide when launching the instance.
	// Changing this creates a new server.
	UserData pulumi.StringPtrInput
	// Map of additional vendor-specific options.
	// Supported options are described below.
	VendorOptions InstanceVendorOptionsPtrInput
}

func (InstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceArgs)(nil)).Elem()
}

type InstanceInput interface {
	pulumi.Input

	ToInstanceOutput() InstanceOutput
	ToInstanceOutputWithContext(ctx context.Context) InstanceOutput
}

func (*Instance) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (i *Instance) ToInstanceOutput() InstanceOutput {
	return i.ToInstanceOutputWithContext(context.Background())
}

func (i *Instance) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceOutput)
}

// InstanceArrayInput is an input type that accepts InstanceArray and InstanceArrayOutput values.
// You can construct a concrete instance of `InstanceArrayInput` via:
//
//	InstanceArray{ InstanceArgs{...} }
type InstanceArrayInput interface {
	pulumi.Input

	ToInstanceArrayOutput() InstanceArrayOutput
	ToInstanceArrayOutputWithContext(context.Context) InstanceArrayOutput
}

type InstanceArray []InstanceInput

func (InstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (i InstanceArray) ToInstanceArrayOutput() InstanceArrayOutput {
	return i.ToInstanceArrayOutputWithContext(context.Background())
}

func (i InstanceArray) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceArrayOutput)
}

// InstanceMapInput is an input type that accepts InstanceMap and InstanceMapOutput values.
// You can construct a concrete instance of `InstanceMapInput` via:
//
//	InstanceMap{ "key": InstanceArgs{...} }
type InstanceMapInput interface {
	pulumi.Input

	ToInstanceMapOutput() InstanceMapOutput
	ToInstanceMapOutputWithContext(context.Context) InstanceMapOutput
}

type InstanceMap map[string]InstanceInput

func (InstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (i InstanceMap) ToInstanceMapOutput() InstanceMapOutput {
	return i.ToInstanceMapOutputWithContext(context.Background())
}

func (i InstanceMap) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceMapOutput)
}

type InstanceOutput struct{ *pulumi.OutputState }

func (InstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (o InstanceOutput) ToInstanceOutput() InstanceOutput {
	return o
}

func (o InstanceOutput) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return o
}

// The first detected Fixed IPv4 address.
func (o InstanceOutput) AccessIpV4() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.AccessIpV4 }).(pulumi.StringOutput)
}

// The first detected Fixed IPv6 address.
func (o InstanceOutput) AccessIpV6() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.AccessIpV6 }).(pulumi.StringOutput)
}

// The administrative password to assign to the server.
// Changing this changes the root password on the existing server.
func (o InstanceOutput) AdminPass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.AdminPass }).(pulumi.StringPtrOutput)
}

// Contains all instance metadata, even metadata not set
// by Terraform.
func (o InstanceOutput) AllMetadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.AllMetadata }).(pulumi.StringMapOutput)
}

// The collection of tags assigned on the instance, which have
// been explicitly and implicitly added.
func (o InstanceOutput) AllTags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringArrayOutput { return v.AllTags }).(pulumi.StringArrayOutput)
}

// The availability zone in which to create
// the server. Conflicts with `availabilityZoneHints`. Changing this creates
// a new server.
func (o InstanceOutput) AvailabilityZone() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.AvailabilityZone }).(pulumi.StringOutput)
}

// The availability zone in which to
// create the server. This argument is preferred to `availabilityZone`, when
// scheduling the server on a
// [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
// host or node. Conflicts with `availabilityZone`. Changing this creates a
// new server.
func (o InstanceOutput) AvailabilityZoneHints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.AvailabilityZoneHints }).(pulumi.StringPtrOutput)
}

// Configuration of block devices. The blockDevice
// structure is documented below. Changing this creates a new server.
// You can specify multiple block devices which will create an instance with
// multiple disks. This configuration is very flexible, so please see the
// following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
// for more information.
func (o InstanceOutput) BlockDevices() InstanceBlockDeviceArrayOutput {
	return o.ApplyT(func(v *Instance) InstanceBlockDeviceArrayOutput { return v.BlockDevices }).(InstanceBlockDeviceArrayOutput)
}

// Whether to use the configDrive feature to
// configure the instance. Changing this creates a new server.
func (o InstanceOutput) ConfigDrive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.ConfigDrive }).(pulumi.BoolPtrOutput)
}

// The creation time of the instance.
func (o InstanceOutput) Created() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Created }).(pulumi.StringOutput)
}

// The flavor ID of
// the desired flavor for the server. Changing this resizes the existing server.
func (o InstanceOutput) FlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.FlavorId }).(pulumi.StringOutput)
}

// The name of the
// desired flavor for the server. Changing this resizes the existing server.
func (o InstanceOutput) FlavorName() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.FlavorName }).(pulumi.StringOutput)
}

// Whether to force the OpenStack instance to be
// forcefully deleted. This is useful for environments that have reclaim / soft
// deletion enabled.
func (o InstanceOutput) ForceDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.ForceDelete }).(pulumi.BoolPtrOutput)
}

// Specifies the exact hypervisor hostname on
// which to create the instance. When provided, this parameter is included in
// the request to Nova, directing the scheduler to launch the instance on the
// specified host. Note: This option requires administrative privileges and a
// Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
// this value forces a new instance to be created.
func (o InstanceOutput) HypervisorHostname() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.HypervisorHostname }).(pulumi.StringOutput)
}

// (Optional; Required if `imageName` is empty and not booting
// from a volume. Do not specify if booting from a volume.) The image ID of
// the desired image for the server. Changing this rebuilds the existing
// server.
func (o InstanceOutput) ImageId() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.ImageId }).(pulumi.StringOutput)
}

// (Optional; Required if `imageId` is empty and not booting
// from a volume. Do not specify if booting from a volume.) The name of the
// desired image for the server. Changing this rebuilds the existing server.
func (o InstanceOutput) ImageName() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.ImageName }).(pulumi.StringOutput)
}

// The name of a key pair to put on the server. The key
// pair must already be created and associated with the tenant's account.
// Changing this creates a new server.
func (o InstanceOutput) KeyPair() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.KeyPair }).(pulumi.StringPtrOutput)
}

// Metadata key/value pairs to make available from
// within the instance. Changing this updates the existing server metadata.
func (o InstanceOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// A unique name for the resource.
func (o InstanceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Special string for `network` option to create
// the server. `networkMode` can be `"auto"` or `"none"`.
// Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
func (o InstanceOutput) NetworkMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.NetworkMode }).(pulumi.StringPtrOutput)
}

// An array of one or more networks to attach to the
// instance. The network object structure is documented below. Changing this
// creates a new server.
func (o InstanceOutput) Networks() InstanceNetworkArrayOutput {
	return o.ApplyT(func(v *Instance) InstanceNetworkArrayOutput { return v.Networks }).(InstanceNetworkArrayOutput)
}

// Customize the personality of an instance by
// defining one or more files and their contents. The personality structure is
// described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
// the existing server.
func (o InstanceOutput) Personalities() InstancePersonalityArrayOutput {
	return o.ApplyT(func(v *Instance) InstancePersonalityArrayOutput { return v.Personalities }).(InstancePersonalityArrayOutput)
}

// Provide the VM state. Only 'active', 'shutoff', 'paused'
// and 'shelved_offloaded' are supported values.
// *Note*: If the initial powerState is the shutoff or paused
// the VM will be stopped immediately after build and the provisioners like
// remote-exec or files are not supported.
func (o InstanceOutput) PowerState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.PowerState }).(pulumi.StringPtrOutput)
}

// The region in which to create the server instance. If
// omitted, the `region` argument of the provider is used. Changing this
// creates a new server.
func (o InstanceOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Provide the Nova scheduler with hints on how
// the instance should be launched. The available hints are described below.
func (o InstanceOutput) SchedulerHints() InstanceSchedulerHintArrayOutput {
	return o.ApplyT(func(v *Instance) InstanceSchedulerHintArrayOutput { return v.SchedulerHints }).(InstanceSchedulerHintArrayOutput)
}

// An array of one or more security group names
// to associate with the server. Changing this results in adding/removing
// security groups from the existing server. *Note*: When attaching the
// instance to networks using Ports, place the security groups on the Port
// and not the instance. *Note*: Names should be used and not ids, as ids
// trigger unnecessary updates.
func (o InstanceOutput) SecurityGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringArrayOutput { return v.SecurityGroups }).(pulumi.StringArrayOutput)
}

// Whether to try stop instance gracefully
// before destroying it, thus giving chance for guest OS daemons to stop correctly.
// If instance doesn't stop within timeout, it will be destroyed anyway.
func (o InstanceOutput) StopBeforeDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolPtrOutput { return v.StopBeforeDestroy }).(pulumi.BoolPtrOutput)
}

// A set of string tags for the instance. Changing this
// updates the existing instance tags.
func (o InstanceOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The time when the instance was last updated.
func (o InstanceOutput) Updated() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Updated }).(pulumi.StringOutput)
}

// The user data to provide when launching the instance.
// Changing this creates a new server.
func (o InstanceOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.UserData }).(pulumi.StringPtrOutput)
}

// Map of additional vendor-specific options.
// Supported options are described below.
func (o InstanceOutput) VendorOptions() InstanceVendorOptionsPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceVendorOptionsPtrOutput { return v.VendorOptions }).(InstanceVendorOptionsPtrOutput)
}

type InstanceArrayOutput struct{ *pulumi.OutputState }

func (InstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (o InstanceArrayOutput) ToInstanceArrayOutput() InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) Index(i pulumi.IntInput) InstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].([]*Instance)[vs[1].(int)]
	}).(InstanceOutput)
}

type InstanceMapOutput struct{ *pulumi.OutputState }

func (InstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (o InstanceMapOutput) ToInstanceMapOutput() InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) MapIndex(k pulumi.StringInput) InstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].(map[string]*Instance)[vs[1].(string)]
	}).(InstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceInput)(nil)).Elem(), &Instance{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceArrayInput)(nil)).Elem(), InstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceMapInput)(nil)).Elem(), InstanceMap{})
	pulumi.RegisterOutputType(InstanceOutput{})
	pulumi.RegisterOutputType(InstanceArrayOutput{})
	pulumi.RegisterOutputType(InstanceMapOutput{})
}
