// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type InstanceBlockDevice struct {
	// The boot index of the volume. It defaults to 0.
	// Changing this creates a new server.
	BootIndex *int `pulumi:"bootIndex"`
	// Delete the volume / block device upon
	// termination of the instance. Defaults to false. Changing this creates a
	// new server.
	DeleteOnTermination *bool `pulumi:"deleteOnTermination"`
	// The type that gets created. Possible values
	// are "volume" and "local". Changing this creates a new server.
	DestinationType *string `pulumi:"destinationType"`
	// The low-level device type that will be used. Most
	// common thing is to leave this empty. Changing this creates a new server.
	DeviceType *string `pulumi:"deviceType"`
	// The low-level disk bus that will be used. Most common
	// thing is to leave this empty. Changing this creates a new server.
	DiskBus *string `pulumi:"diskBus"`
	// Specifies the guest server disk file system format,
	// such as `ext2`, `ext3`, `ext4`, `xfs` or `swap`. Swap block device mappings
	// have the following restrictions: sourceType must be blank and destinationType
	// must be local and only one swap disk per server and the size of the swap disk
	// must be less than or equal to the swap size of the flavor. Changing this
	// creates a new server.
	GuestFormat *string `pulumi:"guestFormat"`
	// The source type of the device. Must be one of
	// "blank", "image", "volume", or "snapshot". Changing this creates a new
	// server.
	SourceType string `pulumi:"sourceType"`
	// The UUID of
	// the image, volume, or snapshot. Changing this creates a new server.
	Uuid *string `pulumi:"uuid"`
	// The size of the volume to create (in gigabytes). Required
	// in the following combinations: source=image and destination=volume,
	// source=blank and destination=local, and source=blank and destination=volume.
	// Changing this creates a new server.
	VolumeSize *int `pulumi:"volumeSize"`
	// The volume type that will be used, for example SSD
	// or HDD storage. The available options depend on how your specific OpenStack
	// cloud is configured and what classes of storage are provided. Changing this
	// creates a new server.
	VolumeType *string `pulumi:"volumeType"`
}

// InstanceBlockDeviceInput is an input type that accepts InstanceBlockDeviceArgs and InstanceBlockDeviceOutput values.
// You can construct a concrete instance of `InstanceBlockDeviceInput` via:
//
//          InstanceBlockDeviceArgs{...}
type InstanceBlockDeviceInput interface {
	pulumi.Input

	ToInstanceBlockDeviceOutput() InstanceBlockDeviceOutput
	ToInstanceBlockDeviceOutputWithContext(context.Context) InstanceBlockDeviceOutput
}

type InstanceBlockDeviceArgs struct {
	// The boot index of the volume. It defaults to 0.
	// Changing this creates a new server.
	BootIndex pulumi.IntPtrInput `pulumi:"bootIndex"`
	// Delete the volume / block device upon
	// termination of the instance. Defaults to false. Changing this creates a
	// new server.
	DeleteOnTermination pulumi.BoolPtrInput `pulumi:"deleteOnTermination"`
	// The type that gets created. Possible values
	// are "volume" and "local". Changing this creates a new server.
	DestinationType pulumi.StringPtrInput `pulumi:"destinationType"`
	// The low-level device type that will be used. Most
	// common thing is to leave this empty. Changing this creates a new server.
	DeviceType pulumi.StringPtrInput `pulumi:"deviceType"`
	// The low-level disk bus that will be used. Most common
	// thing is to leave this empty. Changing this creates a new server.
	DiskBus pulumi.StringPtrInput `pulumi:"diskBus"`
	// Specifies the guest server disk file system format,
	// such as `ext2`, `ext3`, `ext4`, `xfs` or `swap`. Swap block device mappings
	// have the following restrictions: sourceType must be blank and destinationType
	// must be local and only one swap disk per server and the size of the swap disk
	// must be less than or equal to the swap size of the flavor. Changing this
	// creates a new server.
	GuestFormat pulumi.StringPtrInput `pulumi:"guestFormat"`
	// The source type of the device. Must be one of
	// "blank", "image", "volume", or "snapshot". Changing this creates a new
	// server.
	SourceType pulumi.StringInput `pulumi:"sourceType"`
	// The UUID of
	// the image, volume, or snapshot. Changing this creates a new server.
	Uuid pulumi.StringPtrInput `pulumi:"uuid"`
	// The size of the volume to create (in gigabytes). Required
	// in the following combinations: source=image and destination=volume,
	// source=blank and destination=local, and source=blank and destination=volume.
	// Changing this creates a new server.
	VolumeSize pulumi.IntPtrInput `pulumi:"volumeSize"`
	// The volume type that will be used, for example SSD
	// or HDD storage. The available options depend on how your specific OpenStack
	// cloud is configured and what classes of storage are provided. Changing this
	// creates a new server.
	VolumeType pulumi.StringPtrInput `pulumi:"volumeType"`
}

func (InstanceBlockDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceBlockDevice)(nil)).Elem()
}

func (i InstanceBlockDeviceArgs) ToInstanceBlockDeviceOutput() InstanceBlockDeviceOutput {
	return i.ToInstanceBlockDeviceOutputWithContext(context.Background())
}

func (i InstanceBlockDeviceArgs) ToInstanceBlockDeviceOutputWithContext(ctx context.Context) InstanceBlockDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceBlockDeviceOutput)
}

// InstanceBlockDeviceArrayInput is an input type that accepts InstanceBlockDeviceArray and InstanceBlockDeviceArrayOutput values.
// You can construct a concrete instance of `InstanceBlockDeviceArrayInput` via:
//
//          InstanceBlockDeviceArray{ InstanceBlockDeviceArgs{...} }
type InstanceBlockDeviceArrayInput interface {
	pulumi.Input

	ToInstanceBlockDeviceArrayOutput() InstanceBlockDeviceArrayOutput
	ToInstanceBlockDeviceArrayOutputWithContext(context.Context) InstanceBlockDeviceArrayOutput
}

type InstanceBlockDeviceArray []InstanceBlockDeviceInput

func (InstanceBlockDeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceBlockDevice)(nil)).Elem()
}

func (i InstanceBlockDeviceArray) ToInstanceBlockDeviceArrayOutput() InstanceBlockDeviceArrayOutput {
	return i.ToInstanceBlockDeviceArrayOutputWithContext(context.Background())
}

func (i InstanceBlockDeviceArray) ToInstanceBlockDeviceArrayOutputWithContext(ctx context.Context) InstanceBlockDeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceBlockDeviceArrayOutput)
}

type InstanceBlockDeviceOutput struct{ *pulumi.OutputState }

func (InstanceBlockDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceBlockDevice)(nil)).Elem()
}

func (o InstanceBlockDeviceOutput) ToInstanceBlockDeviceOutput() InstanceBlockDeviceOutput {
	return o
}

func (o InstanceBlockDeviceOutput) ToInstanceBlockDeviceOutputWithContext(ctx context.Context) InstanceBlockDeviceOutput {
	return o
}

// The boot index of the volume. It defaults to 0.
// Changing this creates a new server.
func (o InstanceBlockDeviceOutput) BootIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *int { return v.BootIndex }).(pulumi.IntPtrOutput)
}

// Delete the volume / block device upon
// termination of the instance. Defaults to false. Changing this creates a
// new server.
func (o InstanceBlockDeviceOutput) DeleteOnTermination() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *bool { return v.DeleteOnTermination }).(pulumi.BoolPtrOutput)
}

// The type that gets created. Possible values
// are "volume" and "local". Changing this creates a new server.
func (o InstanceBlockDeviceOutput) DestinationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.DestinationType }).(pulumi.StringPtrOutput)
}

// The low-level device type that will be used. Most
// common thing is to leave this empty. Changing this creates a new server.
func (o InstanceBlockDeviceOutput) DeviceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.DeviceType }).(pulumi.StringPtrOutput)
}

// The low-level disk bus that will be used. Most common
// thing is to leave this empty. Changing this creates a new server.
func (o InstanceBlockDeviceOutput) DiskBus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.DiskBus }).(pulumi.StringPtrOutput)
}

// Specifies the guest server disk file system format,
// such as `ext2`, `ext3`, `ext4`, `xfs` or `swap`. Swap block device mappings
// have the following restrictions: sourceType must be blank and destinationType
// must be local and only one swap disk per server and the size of the swap disk
// must be less than or equal to the swap size of the flavor. Changing this
// creates a new server.
func (o InstanceBlockDeviceOutput) GuestFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.GuestFormat }).(pulumi.StringPtrOutput)
}

// The source type of the device. Must be one of
// "blank", "image", "volume", or "snapshot". Changing this creates a new
// server.
func (o InstanceBlockDeviceOutput) SourceType() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceBlockDevice) string { return v.SourceType }).(pulumi.StringOutput)
}

// The UUID of
// the image, volume, or snapshot. Changing this creates a new server.
func (o InstanceBlockDeviceOutput) Uuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.Uuid }).(pulumi.StringPtrOutput)
}

// The size of the volume to create (in gigabytes). Required
// in the following combinations: source=image and destination=volume,
// source=blank and destination=local, and source=blank and destination=volume.
// Changing this creates a new server.
func (o InstanceBlockDeviceOutput) VolumeSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *int { return v.VolumeSize }).(pulumi.IntPtrOutput)
}

// The volume type that will be used, for example SSD
// or HDD storage. The available options depend on how your specific OpenStack
// cloud is configured and what classes of storage are provided. Changing this
// creates a new server.
func (o InstanceBlockDeviceOutput) VolumeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceBlockDevice) *string { return v.VolumeType }).(pulumi.StringPtrOutput)
}

type InstanceBlockDeviceArrayOutput struct{ *pulumi.OutputState }

func (InstanceBlockDeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceBlockDevice)(nil)).Elem()
}

func (o InstanceBlockDeviceArrayOutput) ToInstanceBlockDeviceArrayOutput() InstanceBlockDeviceArrayOutput {
	return o
}

func (o InstanceBlockDeviceArrayOutput) ToInstanceBlockDeviceArrayOutputWithContext(ctx context.Context) InstanceBlockDeviceArrayOutput {
	return o
}

func (o InstanceBlockDeviceArrayOutput) Index(i pulumi.IntInput) InstanceBlockDeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceBlockDevice {
		return vs[0].([]InstanceBlockDevice)[vs[1].(int)]
	}).(InstanceBlockDeviceOutput)
}

type InstanceNetwork struct {
	// Specifies if this network should be used for
	// provisioning access. Accepts true or false. Defaults to false.
	AccessNetwork *bool `pulumi:"accessNetwork"`
	// Specifies a fixed IPv4 address to be used on this
	// network. Changing this creates a new server.
	FixedIpV4  *string `pulumi:"fixedIpV4"`
	FixedIpV6  *string `pulumi:"fixedIpV6"`
	FloatingIp *string `pulumi:"floatingIp"`
	Mac        *string `pulumi:"mac"`
	// The human-readable
	// name of the network. Changing this creates a new server.
	Name *string `pulumi:"name"`
	// The port UUID of a
	// network to attach to the server. Changing this creates a new server.
	Port *string `pulumi:"port"`
	// The UUID of
	// the image, volume, or snapshot. Changing this creates a new server.
	Uuid *string `pulumi:"uuid"`
}

// InstanceNetworkInput is an input type that accepts InstanceNetworkArgs and InstanceNetworkOutput values.
// You can construct a concrete instance of `InstanceNetworkInput` via:
//
//          InstanceNetworkArgs{...}
type InstanceNetworkInput interface {
	pulumi.Input

	ToInstanceNetworkOutput() InstanceNetworkOutput
	ToInstanceNetworkOutputWithContext(context.Context) InstanceNetworkOutput
}

type InstanceNetworkArgs struct {
	// Specifies if this network should be used for
	// provisioning access. Accepts true or false. Defaults to false.
	AccessNetwork pulumi.BoolPtrInput `pulumi:"accessNetwork"`
	// Specifies a fixed IPv4 address to be used on this
	// network. Changing this creates a new server.
	FixedIpV4  pulumi.StringPtrInput `pulumi:"fixedIpV4"`
	FixedIpV6  pulumi.StringPtrInput `pulumi:"fixedIpV6"`
	FloatingIp pulumi.StringPtrInput `pulumi:"floatingIp"`
	Mac        pulumi.StringPtrInput `pulumi:"mac"`
	// The human-readable
	// name of the network. Changing this creates a new server.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port UUID of a
	// network to attach to the server. Changing this creates a new server.
	Port pulumi.StringPtrInput `pulumi:"port"`
	// The UUID of
	// the image, volume, or snapshot. Changing this creates a new server.
	Uuid pulumi.StringPtrInput `pulumi:"uuid"`
}

func (InstanceNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetwork)(nil)).Elem()
}

func (i InstanceNetworkArgs) ToInstanceNetworkOutput() InstanceNetworkOutput {
	return i.ToInstanceNetworkOutputWithContext(context.Background())
}

func (i InstanceNetworkArgs) ToInstanceNetworkOutputWithContext(ctx context.Context) InstanceNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkOutput)
}

// InstanceNetworkArrayInput is an input type that accepts InstanceNetworkArray and InstanceNetworkArrayOutput values.
// You can construct a concrete instance of `InstanceNetworkArrayInput` via:
//
//          InstanceNetworkArray{ InstanceNetworkArgs{...} }
type InstanceNetworkArrayInput interface {
	pulumi.Input

	ToInstanceNetworkArrayOutput() InstanceNetworkArrayOutput
	ToInstanceNetworkArrayOutputWithContext(context.Context) InstanceNetworkArrayOutput
}

type InstanceNetworkArray []InstanceNetworkInput

func (InstanceNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceNetwork)(nil)).Elem()
}

func (i InstanceNetworkArray) ToInstanceNetworkArrayOutput() InstanceNetworkArrayOutput {
	return i.ToInstanceNetworkArrayOutputWithContext(context.Background())
}

func (i InstanceNetworkArray) ToInstanceNetworkArrayOutputWithContext(ctx context.Context) InstanceNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceNetworkArrayOutput)
}

type InstanceNetworkOutput struct{ *pulumi.OutputState }

func (InstanceNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceNetwork)(nil)).Elem()
}

func (o InstanceNetworkOutput) ToInstanceNetworkOutput() InstanceNetworkOutput {
	return o
}

func (o InstanceNetworkOutput) ToInstanceNetworkOutputWithContext(ctx context.Context) InstanceNetworkOutput {
	return o
}

// Specifies if this network should be used for
// provisioning access. Accepts true or false. Defaults to false.
func (o InstanceNetworkOutput) AccessNetwork() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *bool { return v.AccessNetwork }).(pulumi.BoolPtrOutput)
}

// Specifies a fixed IPv4 address to be used on this
// network. Changing this creates a new server.
func (o InstanceNetworkOutput) FixedIpV4() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.FixedIpV4 }).(pulumi.StringPtrOutput)
}

func (o InstanceNetworkOutput) FixedIpV6() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.FixedIpV6 }).(pulumi.StringPtrOutput)
}

func (o InstanceNetworkOutput) FloatingIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.FloatingIp }).(pulumi.StringPtrOutput)
}

func (o InstanceNetworkOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

// The human-readable
// name of the network. Changing this creates a new server.
func (o InstanceNetworkOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port UUID of a
// network to attach to the server. Changing this creates a new server.
func (o InstanceNetworkOutput) Port() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.Port }).(pulumi.StringPtrOutput)
}

// The UUID of
// the image, volume, or snapshot. Changing this creates a new server.
func (o InstanceNetworkOutput) Uuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceNetwork) *string { return v.Uuid }).(pulumi.StringPtrOutput)
}

type InstanceNetworkArrayOutput struct{ *pulumi.OutputState }

func (InstanceNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceNetwork)(nil)).Elem()
}

func (o InstanceNetworkArrayOutput) ToInstanceNetworkArrayOutput() InstanceNetworkArrayOutput {
	return o
}

func (o InstanceNetworkArrayOutput) ToInstanceNetworkArrayOutputWithContext(ctx context.Context) InstanceNetworkArrayOutput {
	return o
}

func (o InstanceNetworkArrayOutput) Index(i pulumi.IntInput) InstanceNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceNetwork {
		return vs[0].([]InstanceNetwork)[vs[1].(int)]
	}).(InstanceNetworkOutput)
}

type InstancePersonality struct {
	// The contents of the file. Limited to 255 bytes.
	Content string `pulumi:"content"`
	// The absolute path of the destination file.
	File string `pulumi:"file"`
}

// InstancePersonalityInput is an input type that accepts InstancePersonalityArgs and InstancePersonalityOutput values.
// You can construct a concrete instance of `InstancePersonalityInput` via:
//
//          InstancePersonalityArgs{...}
type InstancePersonalityInput interface {
	pulumi.Input

	ToInstancePersonalityOutput() InstancePersonalityOutput
	ToInstancePersonalityOutputWithContext(context.Context) InstancePersonalityOutput
}

type InstancePersonalityArgs struct {
	// The contents of the file. Limited to 255 bytes.
	Content pulumi.StringInput `pulumi:"content"`
	// The absolute path of the destination file.
	File pulumi.StringInput `pulumi:"file"`
}

func (InstancePersonalityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePersonality)(nil)).Elem()
}

func (i InstancePersonalityArgs) ToInstancePersonalityOutput() InstancePersonalityOutput {
	return i.ToInstancePersonalityOutputWithContext(context.Background())
}

func (i InstancePersonalityArgs) ToInstancePersonalityOutputWithContext(ctx context.Context) InstancePersonalityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePersonalityOutput)
}

// InstancePersonalityArrayInput is an input type that accepts InstancePersonalityArray and InstancePersonalityArrayOutput values.
// You can construct a concrete instance of `InstancePersonalityArrayInput` via:
//
//          InstancePersonalityArray{ InstancePersonalityArgs{...} }
type InstancePersonalityArrayInput interface {
	pulumi.Input

	ToInstancePersonalityArrayOutput() InstancePersonalityArrayOutput
	ToInstancePersonalityArrayOutputWithContext(context.Context) InstancePersonalityArrayOutput
}

type InstancePersonalityArray []InstancePersonalityInput

func (InstancePersonalityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstancePersonality)(nil)).Elem()
}

func (i InstancePersonalityArray) ToInstancePersonalityArrayOutput() InstancePersonalityArrayOutput {
	return i.ToInstancePersonalityArrayOutputWithContext(context.Background())
}

func (i InstancePersonalityArray) ToInstancePersonalityArrayOutputWithContext(ctx context.Context) InstancePersonalityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePersonalityArrayOutput)
}

type InstancePersonalityOutput struct{ *pulumi.OutputState }

func (InstancePersonalityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePersonality)(nil)).Elem()
}

func (o InstancePersonalityOutput) ToInstancePersonalityOutput() InstancePersonalityOutput {
	return o
}

func (o InstancePersonalityOutput) ToInstancePersonalityOutputWithContext(ctx context.Context) InstancePersonalityOutput {
	return o
}

// The contents of the file. Limited to 255 bytes.
func (o InstancePersonalityOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePersonality) string { return v.Content }).(pulumi.StringOutput)
}

// The absolute path of the destination file.
func (o InstancePersonalityOutput) File() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePersonality) string { return v.File }).(pulumi.StringOutput)
}

type InstancePersonalityArrayOutput struct{ *pulumi.OutputState }

func (InstancePersonalityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstancePersonality)(nil)).Elem()
}

func (o InstancePersonalityArrayOutput) ToInstancePersonalityArrayOutput() InstancePersonalityArrayOutput {
	return o
}

func (o InstancePersonalityArrayOutput) ToInstancePersonalityArrayOutputWithContext(ctx context.Context) InstancePersonalityArrayOutput {
	return o
}

func (o InstancePersonalityArrayOutput) Index(i pulumi.IntInput) InstancePersonalityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstancePersonality {
		return vs[0].([]InstancePersonality)[vs[1].(int)]
	}).(InstancePersonalityOutput)
}

type InstanceSchedulerHint struct {
	// Arbitrary key/value pairs of additional
	// properties to pass to the scheduler.
	AdditionalProperties map[string]interface{} `pulumi:"additionalProperties"`
	// An IP Address in CIDR form. The instance
	// will be placed on a compute node that is in the same subnet.
	BuildNearHostIp *string `pulumi:"buildNearHostIp"`
	// The names of cells where not to build the instance.
	DifferentCells []string `pulumi:"differentCells"`
	// A list of instance UUIDs. The instance will
	// be scheduled on a different host than all other instances.
	DifferentHosts []string `pulumi:"differentHosts"`
	// A UUID of a Server Group. The instance will be placed
	// into that group.
	Group *string `pulumi:"group"`
	// A conditional query that a compute node must pass in
	// order to host an instance. The query must use the `JsonFilter` syntax
	// which is described
	// [here](https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html#jsonfilter).
	// At this time, only simple queries are supported. Compound queries using
	// `and`, `or`, or `not` are not supported. An example of a simple query is:
	Queries []string `pulumi:"queries"`
	// A list of instance UUIDs. The instance will be
	// scheduled on the same host of those specified.
	SameHosts []string `pulumi:"sameHosts"`
	// The name of a cell to host the instance.
	TargetCell *string `pulumi:"targetCell"`
}

// InstanceSchedulerHintInput is an input type that accepts InstanceSchedulerHintArgs and InstanceSchedulerHintOutput values.
// You can construct a concrete instance of `InstanceSchedulerHintInput` via:
//
//          InstanceSchedulerHintArgs{...}
type InstanceSchedulerHintInput interface {
	pulumi.Input

	ToInstanceSchedulerHintOutput() InstanceSchedulerHintOutput
	ToInstanceSchedulerHintOutputWithContext(context.Context) InstanceSchedulerHintOutput
}

type InstanceSchedulerHintArgs struct {
	// Arbitrary key/value pairs of additional
	// properties to pass to the scheduler.
	AdditionalProperties pulumi.MapInput `pulumi:"additionalProperties"`
	// An IP Address in CIDR form. The instance
	// will be placed on a compute node that is in the same subnet.
	BuildNearHostIp pulumi.StringPtrInput `pulumi:"buildNearHostIp"`
	// The names of cells where not to build the instance.
	DifferentCells pulumi.StringArrayInput `pulumi:"differentCells"`
	// A list of instance UUIDs. The instance will
	// be scheduled on a different host than all other instances.
	DifferentHosts pulumi.StringArrayInput `pulumi:"differentHosts"`
	// A UUID of a Server Group. The instance will be placed
	// into that group.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// A conditional query that a compute node must pass in
	// order to host an instance. The query must use the `JsonFilter` syntax
	// which is described
	// [here](https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html#jsonfilter).
	// At this time, only simple queries are supported. Compound queries using
	// `and`, `or`, or `not` are not supported. An example of a simple query is:
	Queries pulumi.StringArrayInput `pulumi:"queries"`
	// A list of instance UUIDs. The instance will be
	// scheduled on the same host of those specified.
	SameHosts pulumi.StringArrayInput `pulumi:"sameHosts"`
	// The name of a cell to host the instance.
	TargetCell pulumi.StringPtrInput `pulumi:"targetCell"`
}

func (InstanceSchedulerHintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceSchedulerHint)(nil)).Elem()
}

func (i InstanceSchedulerHintArgs) ToInstanceSchedulerHintOutput() InstanceSchedulerHintOutput {
	return i.ToInstanceSchedulerHintOutputWithContext(context.Background())
}

func (i InstanceSchedulerHintArgs) ToInstanceSchedulerHintOutputWithContext(ctx context.Context) InstanceSchedulerHintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSchedulerHintOutput)
}

// InstanceSchedulerHintArrayInput is an input type that accepts InstanceSchedulerHintArray and InstanceSchedulerHintArrayOutput values.
// You can construct a concrete instance of `InstanceSchedulerHintArrayInput` via:
//
//          InstanceSchedulerHintArray{ InstanceSchedulerHintArgs{...} }
type InstanceSchedulerHintArrayInput interface {
	pulumi.Input

	ToInstanceSchedulerHintArrayOutput() InstanceSchedulerHintArrayOutput
	ToInstanceSchedulerHintArrayOutputWithContext(context.Context) InstanceSchedulerHintArrayOutput
}

type InstanceSchedulerHintArray []InstanceSchedulerHintInput

func (InstanceSchedulerHintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceSchedulerHint)(nil)).Elem()
}

func (i InstanceSchedulerHintArray) ToInstanceSchedulerHintArrayOutput() InstanceSchedulerHintArrayOutput {
	return i.ToInstanceSchedulerHintArrayOutputWithContext(context.Background())
}

func (i InstanceSchedulerHintArray) ToInstanceSchedulerHintArrayOutputWithContext(ctx context.Context) InstanceSchedulerHintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSchedulerHintArrayOutput)
}

type InstanceSchedulerHintOutput struct{ *pulumi.OutputState }

func (InstanceSchedulerHintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceSchedulerHint)(nil)).Elem()
}

func (o InstanceSchedulerHintOutput) ToInstanceSchedulerHintOutput() InstanceSchedulerHintOutput {
	return o
}

func (o InstanceSchedulerHintOutput) ToInstanceSchedulerHintOutputWithContext(ctx context.Context) InstanceSchedulerHintOutput {
	return o
}

// Arbitrary key/value pairs of additional
// properties to pass to the scheduler.
func (o InstanceSchedulerHintOutput) AdditionalProperties() pulumi.MapOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) map[string]interface{} { return v.AdditionalProperties }).(pulumi.MapOutput)
}

// An IP Address in CIDR form. The instance
// will be placed on a compute node that is in the same subnet.
func (o InstanceSchedulerHintOutput) BuildNearHostIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) *string { return v.BuildNearHostIp }).(pulumi.StringPtrOutput)
}

// The names of cells where not to build the instance.
func (o InstanceSchedulerHintOutput) DifferentCells() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) []string { return v.DifferentCells }).(pulumi.StringArrayOutput)
}

// A list of instance UUIDs. The instance will
// be scheduled on a different host than all other instances.
func (o InstanceSchedulerHintOutput) DifferentHosts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) []string { return v.DifferentHosts }).(pulumi.StringArrayOutput)
}

// A UUID of a Server Group. The instance will be placed
// into that group.
func (o InstanceSchedulerHintOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// A conditional query that a compute node must pass in
// order to host an instance. The query must use the `JsonFilter` syntax
// which is described
// [here](https://docs.openstack.org/nova/latest/admin/configuration/schedulers.html#jsonfilter).
// At this time, only simple queries are supported. Compound queries using
// `and`, `or`, or `not` are not supported. An example of a simple query is:
func (o InstanceSchedulerHintOutput) Queries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) []string { return v.Queries }).(pulumi.StringArrayOutput)
}

// A list of instance UUIDs. The instance will be
// scheduled on the same host of those specified.
func (o InstanceSchedulerHintOutput) SameHosts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) []string { return v.SameHosts }).(pulumi.StringArrayOutput)
}

// The name of a cell to host the instance.
func (o InstanceSchedulerHintOutput) TargetCell() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSchedulerHint) *string { return v.TargetCell }).(pulumi.StringPtrOutput)
}

type InstanceSchedulerHintArrayOutput struct{ *pulumi.OutputState }

func (InstanceSchedulerHintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceSchedulerHint)(nil)).Elem()
}

func (o InstanceSchedulerHintArrayOutput) ToInstanceSchedulerHintArrayOutput() InstanceSchedulerHintArrayOutput {
	return o
}

func (o InstanceSchedulerHintArrayOutput) ToInstanceSchedulerHintArrayOutputWithContext(ctx context.Context) InstanceSchedulerHintArrayOutput {
	return o
}

func (o InstanceSchedulerHintArrayOutput) Index(i pulumi.IntInput) InstanceSchedulerHintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceSchedulerHint {
		return vs[0].([]InstanceSchedulerHint)[vs[1].(int)]
	}).(InstanceSchedulerHintOutput)
}

type InstanceVendorOptions struct {
	// Whether to try to detach all attached
	// ports to the vm before destroying it to make sure the port state is correct
	// after the vm destruction. This is helpful when the port is not deleted.
	DetachPortsBeforeDestroy *bool `pulumi:"detachPortsBeforeDestroy"`
	// Boolean to control whether
	// to ignore manual confirmation of the instance resizing. This can be helpful
	// to work with some OpenStack clouds which automatically confirm resizing of
	// instances after some timeout.
	IgnoreResizeConfirmation *bool `pulumi:"ignoreResizeConfirmation"`
}

// InstanceVendorOptionsInput is an input type that accepts InstanceVendorOptionsArgs and InstanceVendorOptionsOutput values.
// You can construct a concrete instance of `InstanceVendorOptionsInput` via:
//
//          InstanceVendorOptionsArgs{...}
type InstanceVendorOptionsInput interface {
	pulumi.Input

	ToInstanceVendorOptionsOutput() InstanceVendorOptionsOutput
	ToInstanceVendorOptionsOutputWithContext(context.Context) InstanceVendorOptionsOutput
}

type InstanceVendorOptionsArgs struct {
	// Whether to try to detach all attached
	// ports to the vm before destroying it to make sure the port state is correct
	// after the vm destruction. This is helpful when the port is not deleted.
	DetachPortsBeforeDestroy pulumi.BoolPtrInput `pulumi:"detachPortsBeforeDestroy"`
	// Boolean to control whether
	// to ignore manual confirmation of the instance resizing. This can be helpful
	// to work with some OpenStack clouds which automatically confirm resizing of
	// instances after some timeout.
	IgnoreResizeConfirmation pulumi.BoolPtrInput `pulumi:"ignoreResizeConfirmation"`
}

func (InstanceVendorOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceVendorOptions)(nil)).Elem()
}

func (i InstanceVendorOptionsArgs) ToInstanceVendorOptionsOutput() InstanceVendorOptionsOutput {
	return i.ToInstanceVendorOptionsOutputWithContext(context.Background())
}

func (i InstanceVendorOptionsArgs) ToInstanceVendorOptionsOutputWithContext(ctx context.Context) InstanceVendorOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceVendorOptionsOutput)
}

func (i InstanceVendorOptionsArgs) ToInstanceVendorOptionsPtrOutput() InstanceVendorOptionsPtrOutput {
	return i.ToInstanceVendorOptionsPtrOutputWithContext(context.Background())
}

func (i InstanceVendorOptionsArgs) ToInstanceVendorOptionsPtrOutputWithContext(ctx context.Context) InstanceVendorOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceVendorOptionsOutput).ToInstanceVendorOptionsPtrOutputWithContext(ctx)
}

// InstanceVendorOptionsPtrInput is an input type that accepts InstanceVendorOptionsArgs, InstanceVendorOptionsPtr and InstanceVendorOptionsPtrOutput values.
// You can construct a concrete instance of `InstanceVendorOptionsPtrInput` via:
//
//          InstanceVendorOptionsArgs{...}
//
//  or:
//
//          nil
type InstanceVendorOptionsPtrInput interface {
	pulumi.Input

	ToInstanceVendorOptionsPtrOutput() InstanceVendorOptionsPtrOutput
	ToInstanceVendorOptionsPtrOutputWithContext(context.Context) InstanceVendorOptionsPtrOutput
}

type instanceVendorOptionsPtrType InstanceVendorOptionsArgs

func InstanceVendorOptionsPtr(v *InstanceVendorOptionsArgs) InstanceVendorOptionsPtrInput {
	return (*instanceVendorOptionsPtrType)(v)
}

func (*instanceVendorOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceVendorOptions)(nil)).Elem()
}

func (i *instanceVendorOptionsPtrType) ToInstanceVendorOptionsPtrOutput() InstanceVendorOptionsPtrOutput {
	return i.ToInstanceVendorOptionsPtrOutputWithContext(context.Background())
}

func (i *instanceVendorOptionsPtrType) ToInstanceVendorOptionsPtrOutputWithContext(ctx context.Context) InstanceVendorOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceVendorOptionsPtrOutput)
}

type InstanceVendorOptionsOutput struct{ *pulumi.OutputState }

func (InstanceVendorOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceVendorOptions)(nil)).Elem()
}

func (o InstanceVendorOptionsOutput) ToInstanceVendorOptionsOutput() InstanceVendorOptionsOutput {
	return o
}

func (o InstanceVendorOptionsOutput) ToInstanceVendorOptionsOutputWithContext(ctx context.Context) InstanceVendorOptionsOutput {
	return o
}

func (o InstanceVendorOptionsOutput) ToInstanceVendorOptionsPtrOutput() InstanceVendorOptionsPtrOutput {
	return o.ToInstanceVendorOptionsPtrOutputWithContext(context.Background())
}

func (o InstanceVendorOptionsOutput) ToInstanceVendorOptionsPtrOutputWithContext(ctx context.Context) InstanceVendorOptionsPtrOutput {
	return o.ApplyT(func(v InstanceVendorOptions) *InstanceVendorOptions {
		return &v
	}).(InstanceVendorOptionsPtrOutput)
}

// Whether to try to detach all attached
// ports to the vm before destroying it to make sure the port state is correct
// after the vm destruction. This is helpful when the port is not deleted.
func (o InstanceVendorOptionsOutput) DetachPortsBeforeDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InstanceVendorOptions) *bool { return v.DetachPortsBeforeDestroy }).(pulumi.BoolPtrOutput)
}

// Boolean to control whether
// to ignore manual confirmation of the instance resizing. This can be helpful
// to work with some OpenStack clouds which automatically confirm resizing of
// instances after some timeout.
func (o InstanceVendorOptionsOutput) IgnoreResizeConfirmation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InstanceVendorOptions) *bool { return v.IgnoreResizeConfirmation }).(pulumi.BoolPtrOutput)
}

type InstanceVendorOptionsPtrOutput struct{ *pulumi.OutputState }

func (InstanceVendorOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceVendorOptions)(nil)).Elem()
}

func (o InstanceVendorOptionsPtrOutput) ToInstanceVendorOptionsPtrOutput() InstanceVendorOptionsPtrOutput {
	return o
}

func (o InstanceVendorOptionsPtrOutput) ToInstanceVendorOptionsPtrOutputWithContext(ctx context.Context) InstanceVendorOptionsPtrOutput {
	return o
}

func (o InstanceVendorOptionsPtrOutput) Elem() InstanceVendorOptionsOutput {
	return o.ApplyT(func(v *InstanceVendorOptions) InstanceVendorOptions { return *v }).(InstanceVendorOptionsOutput)
}

// Whether to try to detach all attached
// ports to the vm before destroying it to make sure the port state is correct
// after the vm destruction. This is helpful when the port is not deleted.
func (o InstanceVendorOptionsPtrOutput) DetachPortsBeforeDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceVendorOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DetachPortsBeforeDestroy
	}).(pulumi.BoolPtrOutput)
}

// Boolean to control whether
// to ignore manual confirmation of the instance resizing. This can be helpful
// to work with some OpenStack clouds which automatically confirm resizing of
// instances after some timeout.
func (o InstanceVendorOptionsPtrOutput) IgnoreResizeConfirmation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceVendorOptions) *bool {
		if v == nil {
			return nil
		}
		return v.IgnoreResizeConfirmation
	}).(pulumi.BoolPtrOutput)
}

type SecGroupRule struct {
	// Required if `fromGroupId` or `self` is empty. The IP range
	// that will be the source of network traffic to the security group. Use 0.0.0.0/0
	// to allow all IP addresses. Changing this creates a new security group rule. Cannot
	// be combined with `fromGroupId` or `self`.
	Cidr *string `pulumi:"cidr"`
	// Required if `cidr` or `self` is empty. The ID of a
	// group from which to forward traffic to the parent group. Changing this creates a
	// new security group rule. Cannot be combined with `cidr` or `self`.
	FromGroupId *string `pulumi:"fromGroupId"`
	// An integer representing the lower bound of the port
	// range to open. Changing this creates a new security group rule.
	FromPort int     `pulumi:"fromPort"`
	Id       *string `pulumi:"id"`
	// The protocol type that will be allowed. Changing
	// this creates a new security group rule.
	IpProtocol string `pulumi:"ipProtocol"`
	// Required if `cidr` and `fromGroupId` is empty. If true,
	// the security group itself will be added as a source to this ingress rule. Cannot
	// be combined with `cidr` or `fromGroupId`.
	Self *bool `pulumi:"self"`
	// An integer representing the upper bound of the port
	// range to open. Changing this creates a new security group rule.
	ToPort int `pulumi:"toPort"`
}

// SecGroupRuleInput is an input type that accepts SecGroupRuleArgs and SecGroupRuleOutput values.
// You can construct a concrete instance of `SecGroupRuleInput` via:
//
//          SecGroupRuleArgs{...}
type SecGroupRuleInput interface {
	pulumi.Input

	ToSecGroupRuleOutput() SecGroupRuleOutput
	ToSecGroupRuleOutputWithContext(context.Context) SecGroupRuleOutput
}

type SecGroupRuleArgs struct {
	// Required if `fromGroupId` or `self` is empty. The IP range
	// that will be the source of network traffic to the security group. Use 0.0.0.0/0
	// to allow all IP addresses. Changing this creates a new security group rule. Cannot
	// be combined with `fromGroupId` or `self`.
	Cidr pulumi.StringPtrInput `pulumi:"cidr"`
	// Required if `cidr` or `self` is empty. The ID of a
	// group from which to forward traffic to the parent group. Changing this creates a
	// new security group rule. Cannot be combined with `cidr` or `self`.
	FromGroupId pulumi.StringPtrInput `pulumi:"fromGroupId"`
	// An integer representing the lower bound of the port
	// range to open. Changing this creates a new security group rule.
	FromPort pulumi.IntInput       `pulumi:"fromPort"`
	Id       pulumi.StringPtrInput `pulumi:"id"`
	// The protocol type that will be allowed. Changing
	// this creates a new security group rule.
	IpProtocol pulumi.StringInput `pulumi:"ipProtocol"`
	// Required if `cidr` and `fromGroupId` is empty. If true,
	// the security group itself will be added as a source to this ingress rule. Cannot
	// be combined with `cidr` or `fromGroupId`.
	Self pulumi.BoolPtrInput `pulumi:"self"`
	// An integer representing the upper bound of the port
	// range to open. Changing this creates a new security group rule.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (SecGroupRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecGroupRule)(nil)).Elem()
}

func (i SecGroupRuleArgs) ToSecGroupRuleOutput() SecGroupRuleOutput {
	return i.ToSecGroupRuleOutputWithContext(context.Background())
}

func (i SecGroupRuleArgs) ToSecGroupRuleOutputWithContext(ctx context.Context) SecGroupRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecGroupRuleOutput)
}

// SecGroupRuleArrayInput is an input type that accepts SecGroupRuleArray and SecGroupRuleArrayOutput values.
// You can construct a concrete instance of `SecGroupRuleArrayInput` via:
//
//          SecGroupRuleArray{ SecGroupRuleArgs{...} }
type SecGroupRuleArrayInput interface {
	pulumi.Input

	ToSecGroupRuleArrayOutput() SecGroupRuleArrayOutput
	ToSecGroupRuleArrayOutputWithContext(context.Context) SecGroupRuleArrayOutput
}

type SecGroupRuleArray []SecGroupRuleInput

func (SecGroupRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SecGroupRule)(nil)).Elem()
}

func (i SecGroupRuleArray) ToSecGroupRuleArrayOutput() SecGroupRuleArrayOutput {
	return i.ToSecGroupRuleArrayOutputWithContext(context.Background())
}

func (i SecGroupRuleArray) ToSecGroupRuleArrayOutputWithContext(ctx context.Context) SecGroupRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecGroupRuleArrayOutput)
}

type SecGroupRuleOutput struct{ *pulumi.OutputState }

func (SecGroupRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecGroupRule)(nil)).Elem()
}

func (o SecGroupRuleOutput) ToSecGroupRuleOutput() SecGroupRuleOutput {
	return o
}

func (o SecGroupRuleOutput) ToSecGroupRuleOutputWithContext(ctx context.Context) SecGroupRuleOutput {
	return o
}

// Required if `fromGroupId` or `self` is empty. The IP range
// that will be the source of network traffic to the security group. Use 0.0.0.0/0
// to allow all IP addresses. Changing this creates a new security group rule. Cannot
// be combined with `fromGroupId` or `self`.
func (o SecGroupRuleOutput) Cidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecGroupRule) *string { return v.Cidr }).(pulumi.StringPtrOutput)
}

// Required if `cidr` or `self` is empty. The ID of a
// group from which to forward traffic to the parent group. Changing this creates a
// new security group rule. Cannot be combined with `cidr` or `self`.
func (o SecGroupRuleOutput) FromGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecGroupRule) *string { return v.FromGroupId }).(pulumi.StringPtrOutput)
}

// An integer representing the lower bound of the port
// range to open. Changing this creates a new security group rule.
func (o SecGroupRuleOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v SecGroupRule) int { return v.FromPort }).(pulumi.IntOutput)
}

func (o SecGroupRuleOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecGroupRule) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The protocol type that will be allowed. Changing
// this creates a new security group rule.
func (o SecGroupRuleOutput) IpProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v SecGroupRule) string { return v.IpProtocol }).(pulumi.StringOutput)
}

// Required if `cidr` and `fromGroupId` is empty. If true,
// the security group itself will be added as a source to this ingress rule. Cannot
// be combined with `cidr` or `fromGroupId`.
func (o SecGroupRuleOutput) Self() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecGroupRule) *bool { return v.Self }).(pulumi.BoolPtrOutput)
}

// An integer representing the upper bound of the port
// range to open. Changing this creates a new security group rule.
func (o SecGroupRuleOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v SecGroupRule) int { return v.ToPort }).(pulumi.IntOutput)
}

type SecGroupRuleArrayOutput struct{ *pulumi.OutputState }

func (SecGroupRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SecGroupRule)(nil)).Elem()
}

func (o SecGroupRuleArrayOutput) ToSecGroupRuleArrayOutput() SecGroupRuleArrayOutput {
	return o
}

func (o SecGroupRuleArrayOutput) ToSecGroupRuleArrayOutputWithContext(ctx context.Context) SecGroupRuleArrayOutput {
	return o
}

func (o SecGroupRuleArrayOutput) Index(i pulumi.IntInput) SecGroupRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SecGroupRule {
		return vs[0].([]SecGroupRule)[vs[1].(int)]
	}).(SecGroupRuleOutput)
}

type VolumeAttachVendorOptions struct {
	// Boolean to control whether
	// to ignore volume status confirmation of the attached volume. This can be helpful
	// to work with some OpenStack clouds which don't have the Block Storage V3 API available.
	IgnoreVolumeConfirmation *bool `pulumi:"ignoreVolumeConfirmation"`
}

// VolumeAttachVendorOptionsInput is an input type that accepts VolumeAttachVendorOptionsArgs and VolumeAttachVendorOptionsOutput values.
// You can construct a concrete instance of `VolumeAttachVendorOptionsInput` via:
//
//          VolumeAttachVendorOptionsArgs{...}
type VolumeAttachVendorOptionsInput interface {
	pulumi.Input

	ToVolumeAttachVendorOptionsOutput() VolumeAttachVendorOptionsOutput
	ToVolumeAttachVendorOptionsOutputWithContext(context.Context) VolumeAttachVendorOptionsOutput
}

type VolumeAttachVendorOptionsArgs struct {
	// Boolean to control whether
	// to ignore volume status confirmation of the attached volume. This can be helpful
	// to work with some OpenStack clouds which don't have the Block Storage V3 API available.
	IgnoreVolumeConfirmation pulumi.BoolPtrInput `pulumi:"ignoreVolumeConfirmation"`
}

func (VolumeAttachVendorOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeAttachVendorOptions)(nil)).Elem()
}

func (i VolumeAttachVendorOptionsArgs) ToVolumeAttachVendorOptionsOutput() VolumeAttachVendorOptionsOutput {
	return i.ToVolumeAttachVendorOptionsOutputWithContext(context.Background())
}

func (i VolumeAttachVendorOptionsArgs) ToVolumeAttachVendorOptionsOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttachVendorOptionsOutput)
}

func (i VolumeAttachVendorOptionsArgs) ToVolumeAttachVendorOptionsPtrOutput() VolumeAttachVendorOptionsPtrOutput {
	return i.ToVolumeAttachVendorOptionsPtrOutputWithContext(context.Background())
}

func (i VolumeAttachVendorOptionsArgs) ToVolumeAttachVendorOptionsPtrOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttachVendorOptionsOutput).ToVolumeAttachVendorOptionsPtrOutputWithContext(ctx)
}

// VolumeAttachVendorOptionsPtrInput is an input type that accepts VolumeAttachVendorOptionsArgs, VolumeAttachVendorOptionsPtr and VolumeAttachVendorOptionsPtrOutput values.
// You can construct a concrete instance of `VolumeAttachVendorOptionsPtrInput` via:
//
//          VolumeAttachVendorOptionsArgs{...}
//
//  or:
//
//          nil
type VolumeAttachVendorOptionsPtrInput interface {
	pulumi.Input

	ToVolumeAttachVendorOptionsPtrOutput() VolumeAttachVendorOptionsPtrOutput
	ToVolumeAttachVendorOptionsPtrOutputWithContext(context.Context) VolumeAttachVendorOptionsPtrOutput
}

type volumeAttachVendorOptionsPtrType VolumeAttachVendorOptionsArgs

func VolumeAttachVendorOptionsPtr(v *VolumeAttachVendorOptionsArgs) VolumeAttachVendorOptionsPtrInput {
	return (*volumeAttachVendorOptionsPtrType)(v)
}

func (*volumeAttachVendorOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeAttachVendorOptions)(nil)).Elem()
}

func (i *volumeAttachVendorOptionsPtrType) ToVolumeAttachVendorOptionsPtrOutput() VolumeAttachVendorOptionsPtrOutput {
	return i.ToVolumeAttachVendorOptionsPtrOutputWithContext(context.Background())
}

func (i *volumeAttachVendorOptionsPtrType) ToVolumeAttachVendorOptionsPtrOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeAttachVendorOptionsPtrOutput)
}

type VolumeAttachVendorOptionsOutput struct{ *pulumi.OutputState }

func (VolumeAttachVendorOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeAttachVendorOptions)(nil)).Elem()
}

func (o VolumeAttachVendorOptionsOutput) ToVolumeAttachVendorOptionsOutput() VolumeAttachVendorOptionsOutput {
	return o
}

func (o VolumeAttachVendorOptionsOutput) ToVolumeAttachVendorOptionsOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsOutput {
	return o
}

func (o VolumeAttachVendorOptionsOutput) ToVolumeAttachVendorOptionsPtrOutput() VolumeAttachVendorOptionsPtrOutput {
	return o.ToVolumeAttachVendorOptionsPtrOutputWithContext(context.Background())
}

func (o VolumeAttachVendorOptionsOutput) ToVolumeAttachVendorOptionsPtrOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsPtrOutput {
	return o.ApplyT(func(v VolumeAttachVendorOptions) *VolumeAttachVendorOptions {
		return &v
	}).(VolumeAttachVendorOptionsPtrOutput)
}

// Boolean to control whether
// to ignore volume status confirmation of the attached volume. This can be helpful
// to work with some OpenStack clouds which don't have the Block Storage V3 API available.
func (o VolumeAttachVendorOptionsOutput) IgnoreVolumeConfirmation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VolumeAttachVendorOptions) *bool { return v.IgnoreVolumeConfirmation }).(pulumi.BoolPtrOutput)
}

type VolumeAttachVendorOptionsPtrOutput struct{ *pulumi.OutputState }

func (VolumeAttachVendorOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeAttachVendorOptions)(nil)).Elem()
}

func (o VolumeAttachVendorOptionsPtrOutput) ToVolumeAttachVendorOptionsPtrOutput() VolumeAttachVendorOptionsPtrOutput {
	return o
}

func (o VolumeAttachVendorOptionsPtrOutput) ToVolumeAttachVendorOptionsPtrOutputWithContext(ctx context.Context) VolumeAttachVendorOptionsPtrOutput {
	return o
}

func (o VolumeAttachVendorOptionsPtrOutput) Elem() VolumeAttachVendorOptionsOutput {
	return o.ApplyT(func(v *VolumeAttachVendorOptions) VolumeAttachVendorOptions { return *v }).(VolumeAttachVendorOptionsOutput)
}

// Boolean to control whether
// to ignore volume status confirmation of the attached volume. This can be helpful
// to work with some OpenStack clouds which don't have the Block Storage V3 API available.
func (o VolumeAttachVendorOptionsPtrOutput) IgnoreVolumeConfirmation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VolumeAttachVendorOptions) *bool {
		if v == nil {
			return nil
		}
		return v.IgnoreVolumeConfirmation
	}).(pulumi.BoolPtrOutput)
}

type GetInstanceV2Network struct {
	// The IPv4 address assigned to this network port.
	FixedIpV4 string `pulumi:"fixedIpV4"`
	// The IPv6 address assigned to this network port.
	FixedIpV6 string `pulumi:"fixedIpV6"`
	// The MAC address assigned to this network interface.
	Mac string `pulumi:"mac"`
	// The name of the network
	Name string `pulumi:"name"`
	// The port UUID for this network
	Port string `pulumi:"port"`
	// The UUID of the network
	Uuid string `pulumi:"uuid"`
}

// GetInstanceV2NetworkInput is an input type that accepts GetInstanceV2NetworkArgs and GetInstanceV2NetworkOutput values.
// You can construct a concrete instance of `GetInstanceV2NetworkInput` via:
//
//          GetInstanceV2NetworkArgs{...}
type GetInstanceV2NetworkInput interface {
	pulumi.Input

	ToGetInstanceV2NetworkOutput() GetInstanceV2NetworkOutput
	ToGetInstanceV2NetworkOutputWithContext(context.Context) GetInstanceV2NetworkOutput
}

type GetInstanceV2NetworkArgs struct {
	// The IPv4 address assigned to this network port.
	FixedIpV4 pulumi.StringInput `pulumi:"fixedIpV4"`
	// The IPv6 address assigned to this network port.
	FixedIpV6 pulumi.StringInput `pulumi:"fixedIpV6"`
	// The MAC address assigned to this network interface.
	Mac pulumi.StringInput `pulumi:"mac"`
	// The name of the network
	Name pulumi.StringInput `pulumi:"name"`
	// The port UUID for this network
	Port pulumi.StringInput `pulumi:"port"`
	// The UUID of the network
	Uuid pulumi.StringInput `pulumi:"uuid"`
}

func (GetInstanceV2NetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetInstanceV2Network)(nil)).Elem()
}

func (i GetInstanceV2NetworkArgs) ToGetInstanceV2NetworkOutput() GetInstanceV2NetworkOutput {
	return i.ToGetInstanceV2NetworkOutputWithContext(context.Background())
}

func (i GetInstanceV2NetworkArgs) ToGetInstanceV2NetworkOutputWithContext(ctx context.Context) GetInstanceV2NetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetInstanceV2NetworkOutput)
}

// GetInstanceV2NetworkArrayInput is an input type that accepts GetInstanceV2NetworkArray and GetInstanceV2NetworkArrayOutput values.
// You can construct a concrete instance of `GetInstanceV2NetworkArrayInput` via:
//
//          GetInstanceV2NetworkArray{ GetInstanceV2NetworkArgs{...} }
type GetInstanceV2NetworkArrayInput interface {
	pulumi.Input

	ToGetInstanceV2NetworkArrayOutput() GetInstanceV2NetworkArrayOutput
	ToGetInstanceV2NetworkArrayOutputWithContext(context.Context) GetInstanceV2NetworkArrayOutput
}

type GetInstanceV2NetworkArray []GetInstanceV2NetworkInput

func (GetInstanceV2NetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetInstanceV2Network)(nil)).Elem()
}

func (i GetInstanceV2NetworkArray) ToGetInstanceV2NetworkArrayOutput() GetInstanceV2NetworkArrayOutput {
	return i.ToGetInstanceV2NetworkArrayOutputWithContext(context.Background())
}

func (i GetInstanceV2NetworkArray) ToGetInstanceV2NetworkArrayOutputWithContext(ctx context.Context) GetInstanceV2NetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetInstanceV2NetworkArrayOutput)
}

type GetInstanceV2NetworkOutput struct{ *pulumi.OutputState }

func (GetInstanceV2NetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetInstanceV2Network)(nil)).Elem()
}

func (o GetInstanceV2NetworkOutput) ToGetInstanceV2NetworkOutput() GetInstanceV2NetworkOutput {
	return o
}

func (o GetInstanceV2NetworkOutput) ToGetInstanceV2NetworkOutputWithContext(ctx context.Context) GetInstanceV2NetworkOutput {
	return o
}

// The IPv4 address assigned to this network port.
func (o GetInstanceV2NetworkOutput) FixedIpV4() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.FixedIpV4 }).(pulumi.StringOutput)
}

// The IPv6 address assigned to this network port.
func (o GetInstanceV2NetworkOutput) FixedIpV6() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.FixedIpV6 }).(pulumi.StringOutput)
}

// The MAC address assigned to this network interface.
func (o GetInstanceV2NetworkOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.Mac }).(pulumi.StringOutput)
}

// The name of the network
func (o GetInstanceV2NetworkOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.Name }).(pulumi.StringOutput)
}

// The port UUID for this network
func (o GetInstanceV2NetworkOutput) Port() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.Port }).(pulumi.StringOutput)
}

// The UUID of the network
func (o GetInstanceV2NetworkOutput) Uuid() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceV2Network) string { return v.Uuid }).(pulumi.StringOutput)
}

type GetInstanceV2NetworkArrayOutput struct{ *pulumi.OutputState }

func (GetInstanceV2NetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetInstanceV2Network)(nil)).Elem()
}

func (o GetInstanceV2NetworkArrayOutput) ToGetInstanceV2NetworkArrayOutput() GetInstanceV2NetworkArrayOutput {
	return o
}

func (o GetInstanceV2NetworkArrayOutput) ToGetInstanceV2NetworkArrayOutputWithContext(ctx context.Context) GetInstanceV2NetworkArrayOutput {
	return o
}

func (o GetInstanceV2NetworkArrayOutput) Index(i pulumi.IntInput) GetInstanceV2NetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetInstanceV2Network {
		return vs[0].([]GetInstanceV2Network)[vs[1].(int)]
	}).(GetInstanceV2NetworkOutput)
}

func init() {
	pulumi.RegisterOutputType(InstanceBlockDeviceOutput{})
	pulumi.RegisterOutputType(InstanceBlockDeviceArrayOutput{})
	pulumi.RegisterOutputType(InstanceNetworkOutput{})
	pulumi.RegisterOutputType(InstanceNetworkArrayOutput{})
	pulumi.RegisterOutputType(InstancePersonalityOutput{})
	pulumi.RegisterOutputType(InstancePersonalityArrayOutput{})
	pulumi.RegisterOutputType(InstanceSchedulerHintOutput{})
	pulumi.RegisterOutputType(InstanceSchedulerHintArrayOutput{})
	pulumi.RegisterOutputType(InstanceVendorOptionsOutput{})
	pulumi.RegisterOutputType(InstanceVendorOptionsPtrOutput{})
	pulumi.RegisterOutputType(SecGroupRuleOutput{})
	pulumi.RegisterOutputType(SecGroupRuleArrayOutput{})
	pulumi.RegisterOutputType(VolumeAttachVendorOptionsOutput{})
	pulumi.RegisterOutputType(VolumeAttachVendorOptionsPtrOutput{})
	pulumi.RegisterOutputType(GetInstanceV2NetworkOutput{})
	pulumi.RegisterOutputType(GetInstanceV2NetworkArrayOutput{})
}
