// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.openstack.objectstorage;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ContainerObjectArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerObjectArgs Empty = new ContainerObjectArgs();

    /**
     * A unique (within an account) name for the container.
     * The container name must be from 1 to 256 characters long and can start
     * with any character and contain any pattern. Character set must be UTF-8.
     * The container name cannot contain a slash (/) character because this
     * character delimits the container and object name. For example, the path
     * /v1/account/www/pages specifies the www container, not the www/pages container.
     * 
     */
    @Import(name="containerName", required=true)
    private Output<String> containerName;

    /**
     * @return A unique (within an account) name for the container.
     * The container name must be from 1 to 256 characters long and can start
     * with any character and contain any pattern. Character set must be UTF-8.
     * The container name cannot contain a slash (/) character because this
     * character delimits the container and object name. For example, the path
     * /v1/account/www/pages specifies the www container, not the www/pages container.
     * 
     */
    public Output<String> containerName() {
        return this.containerName;
    }

    /**
     * A string representing the content of the object. Conflicts with
     * `source` and `copy_from`.
     * 
     */
    @Import(name="content")
    private @Nullable Output<String> content;

    /**
     * @return A string representing the content of the object. Conflicts with
     * `source` and `copy_from`.
     * 
     */
    public Optional<Output<String>> content() {
        return Optional.ofNullable(this.content);
    }

    /**
     * A string which specifies the override behavior for
     * the browser. For example, this header might specify that the browser use a download
     * program to save this file rather than show the file, which is the default.
     * 
     */
    @Import(name="contentDisposition")
    private @Nullable Output<String> contentDisposition;

    /**
     * @return A string which specifies the override behavior for
     * the browser. For example, this header might specify that the browser use a download
     * program to save this file rather than show the file, which is the default.
     * 
     */
    public Optional<Output<String>> contentDisposition() {
        return Optional.ofNullable(this.contentDisposition);
    }

    /**
     * A string representing the value of the Content-Encoding
     * metadata.
     * 
     */
    @Import(name="contentEncoding")
    private @Nullable Output<String> contentEncoding;

    /**
     * @return A string representing the value of the Content-Encoding
     * metadata.
     * 
     */
    public Optional<Output<String>> contentEncoding() {
        return Optional.ofNullable(this.contentEncoding);
    }

    /**
     * A string which sets the MIME type for the object.
     * 
     */
    @Import(name="contentType")
    private @Nullable Output<String> contentType;

    /**
     * @return A string which sets the MIME type for the object.
     * 
     */
    public Optional<Output<String>> contentType() {
        return Optional.ofNullable(this.contentType);
    }

    /**
     * A string representing the name of an object
     * used to create the new object by copying the `copy_from` object. The value is in form
     * {container}/{object}. You must UTF-8-encode and then URL-encode the names of the
     * container and object before you include them in the header. Conflicts with `source` and
     * `content`.
     * 
     */
    @Import(name="copyFrom")
    private @Nullable Output<String> copyFrom;

    /**
     * @return A string representing the name of an object
     * used to create the new object by copying the `copy_from` object. The value is in form
     * {container}/{object}. You must UTF-8-encode and then URL-encode the names of the
     * container and object before you include them in the header. Conflicts with `source` and
     * `content`.
     * 
     */
    public Optional<Output<String>> copyFrom() {
        return Optional.ofNullable(this.copyFrom);
    }

    /**
     * An integer representing the number of seconds after which the
     * system removes the object. Internally, the Object Storage system stores this value in
     * the X-Delete-At metadata item.
     * 
     */
    @Import(name="deleteAfter")
    private @Nullable Output<Integer> deleteAfter;

    /**
     * @return An integer representing the number of seconds after which the
     * system removes the object. Internally, the Object Storage system stores this value in
     * the X-Delete-At metadata item.
     * 
     */
    public Optional<Output<Integer>> deleteAfter() {
        return Optional.ofNullable(this.deleteAfter);
    }

    /**
     * An string representing the date when the system removes the object.
     * For example, &#34;2015-08-26&#34; is equivalent to Mon, Wed, 26 Aug 2015 00:00:00 GMT.
     * 
     */
    @Import(name="deleteAt")
    private @Nullable Output<String> deleteAt;

    /**
     * @return An string representing the date when the system removes the object.
     * For example, &#34;2015-08-26&#34; is equivalent to Mon, Wed, 26 Aug 2015 00:00:00 GMT.
     * 
     */
    public Optional<Output<String>> deleteAt() {
        return Optional.ofNullable(this.deleteAt);
    }

    /**
     * If set to true, Object Storage guesses the content
     * type based on the file extension and ignores the value sent in the Content-Type
     * header, if present.
     * 
     */
    @Import(name="detectContentType")
    private @Nullable Output<Boolean> detectContentType;

    /**
     * @return If set to true, Object Storage guesses the content
     * type based on the file extension and ignores the value sent in the Content-Type
     * header, if present.
     * 
     */
    public Optional<Output<Boolean>> detectContentType() {
        return Optional.ofNullable(this.detectContentType);
    }

    /**
     * Used to trigger updates. The only meaningful value is ${md5(file(&#34;path/to/file&#34;))}.
     * 
     */
    @Import(name="etag")
    private @Nullable Output<String> etag;

    /**
     * @return Used to trigger updates. The only meaningful value is ${md5(file(&#34;path/to/file&#34;))}.
     * 
     */
    public Optional<Output<String>> etag() {
        return Optional.ofNullable(this.etag);
    }

    @Import(name="metadata")
    private @Nullable Output<Map<String,Object>> metadata;

    public Optional<Output<Map<String,Object>>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * A unique name for the object.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return A unique name for the object.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * A string set to specify that this is a dynamic large
     * object manifest object. The value is the container and object name prefix of the
     * segment objects in the form container/prefix. You must UTF-8-encode and then
     * URL-encode the names of the container and prefix before you include them in this
     * header.
     * 
     */
    @Import(name="objectManifest")
    private @Nullable Output<String> objectManifest;

    /**
     * @return A string set to specify that this is a dynamic large
     * object manifest object. The value is the container and object name prefix of the
     * segment objects in the form container/prefix. You must UTF-8-encode and then
     * URL-encode the names of the container and prefix before you include them in this
     * header.
     * 
     */
    public Optional<Output<String>> objectManifest() {
        return Optional.ofNullable(this.objectManifest);
    }

    /**
     * The region in which to create the container. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new container.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region in which to create the container. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new container.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * A string representing the local path of a file which will be used
     * as the object&#39;s content. Conflicts with `source` and `copy_from`.
     * 
     */
    @Import(name="source")
    private @Nullable Output<String> source;

    /**
     * @return A string representing the local path of a file which will be used
     * as the object&#39;s content. Conflicts with `source` and `copy_from`.
     * 
     */
    public Optional<Output<String>> source() {
        return Optional.ofNullable(this.source);
    }

    private ContainerObjectArgs() {}

    private ContainerObjectArgs(ContainerObjectArgs $) {
        this.containerName = $.containerName;
        this.content = $.content;
        this.contentDisposition = $.contentDisposition;
        this.contentEncoding = $.contentEncoding;
        this.contentType = $.contentType;
        this.copyFrom = $.copyFrom;
        this.deleteAfter = $.deleteAfter;
        this.deleteAt = $.deleteAt;
        this.detectContentType = $.detectContentType;
        this.etag = $.etag;
        this.metadata = $.metadata;
        this.name = $.name;
        this.objectManifest = $.objectManifest;
        this.region = $.region;
        this.source = $.source;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ContainerObjectArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ContainerObjectArgs $;

        public Builder() {
            $ = new ContainerObjectArgs();
        }

        public Builder(ContainerObjectArgs defaults) {
            $ = new ContainerObjectArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param containerName A unique (within an account) name for the container.
         * The container name must be from 1 to 256 characters long and can start
         * with any character and contain any pattern. Character set must be UTF-8.
         * The container name cannot contain a slash (/) character because this
         * character delimits the container and object name. For example, the path
         * /v1/account/www/pages specifies the www container, not the www/pages container.
         * 
         * @return builder
         * 
         */
        public Builder containerName(Output<String> containerName) {
            $.containerName = containerName;
            return this;
        }

        /**
         * @param containerName A unique (within an account) name for the container.
         * The container name must be from 1 to 256 characters long and can start
         * with any character and contain any pattern. Character set must be UTF-8.
         * The container name cannot contain a slash (/) character because this
         * character delimits the container and object name. For example, the path
         * /v1/account/www/pages specifies the www container, not the www/pages container.
         * 
         * @return builder
         * 
         */
        public Builder containerName(String containerName) {
            return containerName(Output.of(containerName));
        }

        /**
         * @param content A string representing the content of the object. Conflicts with
         * `source` and `copy_from`.
         * 
         * @return builder
         * 
         */
        public Builder content(@Nullable Output<String> content) {
            $.content = content;
            return this;
        }

        /**
         * @param content A string representing the content of the object. Conflicts with
         * `source` and `copy_from`.
         * 
         * @return builder
         * 
         */
        public Builder content(String content) {
            return content(Output.of(content));
        }

        /**
         * @param contentDisposition A string which specifies the override behavior for
         * the browser. For example, this header might specify that the browser use a download
         * program to save this file rather than show the file, which is the default.
         * 
         * @return builder
         * 
         */
        public Builder contentDisposition(@Nullable Output<String> contentDisposition) {
            $.contentDisposition = contentDisposition;
            return this;
        }

        /**
         * @param contentDisposition A string which specifies the override behavior for
         * the browser. For example, this header might specify that the browser use a download
         * program to save this file rather than show the file, which is the default.
         * 
         * @return builder
         * 
         */
        public Builder contentDisposition(String contentDisposition) {
            return contentDisposition(Output.of(contentDisposition));
        }

        /**
         * @param contentEncoding A string representing the value of the Content-Encoding
         * metadata.
         * 
         * @return builder
         * 
         */
        public Builder contentEncoding(@Nullable Output<String> contentEncoding) {
            $.contentEncoding = contentEncoding;
            return this;
        }

        /**
         * @param contentEncoding A string representing the value of the Content-Encoding
         * metadata.
         * 
         * @return builder
         * 
         */
        public Builder contentEncoding(String contentEncoding) {
            return contentEncoding(Output.of(contentEncoding));
        }

        /**
         * @param contentType A string which sets the MIME type for the object.
         * 
         * @return builder
         * 
         */
        public Builder contentType(@Nullable Output<String> contentType) {
            $.contentType = contentType;
            return this;
        }

        /**
         * @param contentType A string which sets the MIME type for the object.
         * 
         * @return builder
         * 
         */
        public Builder contentType(String contentType) {
            return contentType(Output.of(contentType));
        }

        /**
         * @param copyFrom A string representing the name of an object
         * used to create the new object by copying the `copy_from` object. The value is in form
         * {container}/{object}. You must UTF-8-encode and then URL-encode the names of the
         * container and object before you include them in the header. Conflicts with `source` and
         * `content`.
         * 
         * @return builder
         * 
         */
        public Builder copyFrom(@Nullable Output<String> copyFrom) {
            $.copyFrom = copyFrom;
            return this;
        }

        /**
         * @param copyFrom A string representing the name of an object
         * used to create the new object by copying the `copy_from` object. The value is in form
         * {container}/{object}. You must UTF-8-encode and then URL-encode the names of the
         * container and object before you include them in the header. Conflicts with `source` and
         * `content`.
         * 
         * @return builder
         * 
         */
        public Builder copyFrom(String copyFrom) {
            return copyFrom(Output.of(copyFrom));
        }

        /**
         * @param deleteAfter An integer representing the number of seconds after which the
         * system removes the object. Internally, the Object Storage system stores this value in
         * the X-Delete-At metadata item.
         * 
         * @return builder
         * 
         */
        public Builder deleteAfter(@Nullable Output<Integer> deleteAfter) {
            $.deleteAfter = deleteAfter;
            return this;
        }

        /**
         * @param deleteAfter An integer representing the number of seconds after which the
         * system removes the object. Internally, the Object Storage system stores this value in
         * the X-Delete-At metadata item.
         * 
         * @return builder
         * 
         */
        public Builder deleteAfter(Integer deleteAfter) {
            return deleteAfter(Output.of(deleteAfter));
        }

        /**
         * @param deleteAt An string representing the date when the system removes the object.
         * For example, &#34;2015-08-26&#34; is equivalent to Mon, Wed, 26 Aug 2015 00:00:00 GMT.
         * 
         * @return builder
         * 
         */
        public Builder deleteAt(@Nullable Output<String> deleteAt) {
            $.deleteAt = deleteAt;
            return this;
        }

        /**
         * @param deleteAt An string representing the date when the system removes the object.
         * For example, &#34;2015-08-26&#34; is equivalent to Mon, Wed, 26 Aug 2015 00:00:00 GMT.
         * 
         * @return builder
         * 
         */
        public Builder deleteAt(String deleteAt) {
            return deleteAt(Output.of(deleteAt));
        }

        /**
         * @param detectContentType If set to true, Object Storage guesses the content
         * type based on the file extension and ignores the value sent in the Content-Type
         * header, if present.
         * 
         * @return builder
         * 
         */
        public Builder detectContentType(@Nullable Output<Boolean> detectContentType) {
            $.detectContentType = detectContentType;
            return this;
        }

        /**
         * @param detectContentType If set to true, Object Storage guesses the content
         * type based on the file extension and ignores the value sent in the Content-Type
         * header, if present.
         * 
         * @return builder
         * 
         */
        public Builder detectContentType(Boolean detectContentType) {
            return detectContentType(Output.of(detectContentType));
        }

        /**
         * @param etag Used to trigger updates. The only meaningful value is ${md5(file(&#34;path/to/file&#34;))}.
         * 
         * @return builder
         * 
         */
        public Builder etag(@Nullable Output<String> etag) {
            $.etag = etag;
            return this;
        }

        /**
         * @param etag Used to trigger updates. The only meaningful value is ${md5(file(&#34;path/to/file&#34;))}.
         * 
         * @return builder
         * 
         */
        public Builder etag(String etag) {
            return etag(Output.of(etag));
        }

        public Builder metadata(@Nullable Output<Map<String,Object>> metadata) {
            $.metadata = metadata;
            return this;
        }

        public Builder metadata(Map<String,Object> metadata) {
            return metadata(Output.of(metadata));
        }

        /**
         * @param name A unique name for the object.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique name for the object.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param objectManifest A string set to specify that this is a dynamic large
         * object manifest object. The value is the container and object name prefix of the
         * segment objects in the form container/prefix. You must UTF-8-encode and then
         * URL-encode the names of the container and prefix before you include them in this
         * header.
         * 
         * @return builder
         * 
         */
        public Builder objectManifest(@Nullable Output<String> objectManifest) {
            $.objectManifest = objectManifest;
            return this;
        }

        /**
         * @param objectManifest A string set to specify that this is a dynamic large
         * object manifest object. The value is the container and object name prefix of the
         * segment objects in the form container/prefix. You must UTF-8-encode and then
         * URL-encode the names of the container and prefix before you include them in this
         * header.
         * 
         * @return builder
         * 
         */
        public Builder objectManifest(String objectManifest) {
            return objectManifest(Output.of(objectManifest));
        }

        /**
         * @param region The region in which to create the container. If
         * omitted, the `region` argument of the provider is used. Changing this
         * creates a new container.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region in which to create the container. If
         * omitted, the `region` argument of the provider is used. Changing this
         * creates a new container.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param source A string representing the local path of a file which will be used
         * as the object&#39;s content. Conflicts with `source` and `copy_from`.
         * 
         * @return builder
         * 
         */
        public Builder source(@Nullable Output<String> source) {
            $.source = source;
            return this;
        }

        /**
         * @param source A string representing the local path of a file which will be used
         * as the object&#39;s content. Conflicts with `source` and `copy_from`.
         * 
         * @return builder
         * 
         */
        public Builder source(String source) {
            return source(Output.of(source));
        }

        public ContainerObjectArgs build() {
            if ($.containerName == null) {
                throw new MissingRequiredPropertyException("ContainerObjectArgs", "containerName");
            }
            return $;
        }
    }

}
