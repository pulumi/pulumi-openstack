// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.openstack.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.openstack.Utilities;
import com.pulumi.openstack.compute.InstanceArgs;
import com.pulumi.openstack.compute.inputs.InstanceState;
import com.pulumi.openstack.compute.outputs.InstanceBlockDevice;
import com.pulumi.openstack.compute.outputs.InstanceNetwork;
import com.pulumi.openstack.compute.outputs.InstancePersonality;
import com.pulumi.openstack.compute.outputs.InstanceSchedulerHint;
import com.pulumi.openstack.compute.outputs.InstanceVendorOptions;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a V2 VM instance resource within OpenStack.
 * 
 * &gt; **Note:** All arguments including the instance admin password will be stored
 * in the raw state as plain-text. Read more about sensitive data in
 * state.
 * 
 * ## Example Usage
 * 
 * ### Basic Instance
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var basic = new Instance("basic", InstanceArgs.builder()
 *             .name("basic")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .metadata(Map.of("this", "that"))
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance With Attached Volume
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.blockstorage.Volume;
 * import com.pulumi.openstack.blockstorage.VolumeArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import com.pulumi.openstack.compute.VolumeAttach;
 * import com.pulumi.openstack.compute.VolumeAttachArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var myvol = new Volume("myvol", VolumeArgs.builder()
 *             .name("myvol")
 *             .size(1)
 *             .build());
 * 
 *         var myinstance = new Instance("myinstance", InstanceArgs.builder()
 *             .name("myinstance")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *         var attached = new VolumeAttach("attached", VolumeAttachArgs.builder()
 *             .instanceId(myinstance.id())
 *             .volumeId(myvol.id())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Boot From Volume
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var boot_from_volume = new Instance("boot-from-volume", InstanceArgs.builder()
 *             .name("boot-from-volume")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(InstanceBlockDeviceArgs.builder()
 *                 .uuid("<image-id>")
 *                 .sourceType("image")
 *                 .volumeSize(5)
 *                 .bootIndex(0)
 *                 .destinationType("volume")
 *                 .deleteOnTermination(true)
 *                 .build())
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Boot From an Existing Volume
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.blockstorage.Volume;
 * import com.pulumi.openstack.blockstorage.VolumeArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var myvol = new Volume("myvol", VolumeArgs.builder()
 *             .name("myvol")
 *             .size(5)
 *             .imageId("<image-id>")
 *             .build());
 * 
 *         var boot_from_volume = new Instance("boot-from-volume", InstanceArgs.builder()
 *             .name("bootfromvolume")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(InstanceBlockDeviceArgs.builder()
 *                 .uuid(myvol.id())
 *                 .sourceType("volume")
 *                 .bootIndex(0)
 *                 .destinationType("volume")
 *                 .deleteOnTermination(true)
 *                 .build())
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Boot Instance, Create Volume, and Attach Volume as a Block Device
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance1 = new Instance("instance1", InstanceArgs.builder()
 *             .name("instance_1")
 *             .imageId("<image-id>")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(            
 *                 InstanceBlockDeviceArgs.builder()
 *                     .uuid("<image-id>")
 *                     .sourceType("image")
 *                     .destinationType("local")
 *                     .bootIndex(0)
 *                     .deleteOnTermination(true)
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .sourceType("blank")
 *                     .destinationType("volume")
 *                     .volumeSize(1)
 *                     .bootIndex(1)
 *                     .deleteOnTermination(true)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Boot Instance and Attach Existing Volume as a Block Device
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.blockstorage.Volume;
 * import com.pulumi.openstack.blockstorage.VolumeArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var volume1 = new Volume("volume1", VolumeArgs.builder()
 *             .name("volume_1")
 *             .size(1)
 *             .build());
 * 
 *         var instance1 = new Instance("instance1", InstanceArgs.builder()
 *             .name("instance_1")
 *             .imageId("<image-id>")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(            
 *                 InstanceBlockDeviceArgs.builder()
 *                     .uuid("<image-id>")
 *                     .sourceType("image")
 *                     .destinationType("local")
 *                     .bootIndex(0)
 *                     .deleteOnTermination(true)
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .uuid(volume1.id())
 *                     .sourceType("volume")
 *                     .destinationType("volume")
 *                     .bootIndex(1)
 *                     .deleteOnTermination(true)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance With Multiple Networks
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.networking.FloatingIp;
 * import com.pulumi.openstack.networking.FloatingIpArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import com.pulumi.openstack.networking.NetworkingFunctions;
 * import com.pulumi.openstack.networking.inputs.GetPortArgs;
 * import com.pulumi.openstack.networking.FloatingIpAssociate;
 * import com.pulumi.openstack.networking.FloatingIpAssociateArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var myip = new FloatingIp("myip", FloatingIpArgs.builder()
 *             .pool("my_pool")
 *             .build());
 * 
 *         var multi_net = new Instance("multi-net", InstanceArgs.builder()
 *             .name("multi-net")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .networks(            
 *                 InstanceNetworkArgs.builder()
 *                     .name("my_first_network")
 *                     .build(),
 *                 InstanceNetworkArgs.builder()
 *                     .name("my_second_network")
 *                     .build())
 *             .build());
 * 
 *         final var vm-port = Output.tuple(multi_net.id(), multi_net.networks()).applyValue(values -> {
 *             var id = values.t1;
 *             var networks = values.t2;
 *             return NetworkingFunctions.getPort(GetPortArgs.builder()
 *                 .deviceId(id)
 *                 .networkId(networks[1].uuid())
 *                 .build());
 *         });
 * 
 *         var fipVm = new FloatingIpAssociate("fipVm", FloatingIpAssociateArgs.builder()
 *             .floatingIp(myip.address())
 *             .portId(vm_port.applyValue(_vm_port -> _vm_port.id()))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance With Personality
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstancePersonalityArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var personality = new Instance("personality", InstanceArgs.builder()
 *             .name("personality")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .personalities(InstancePersonalityArgs.builder()
 *                 .file("/path/to/file/on/instance.txt")
 *                 .content("contents of file")
 *                 .build())
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance with Multiple Ephemeral Disks
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var multi_eph = new Instance("multi-eph", InstanceArgs.builder()
 *             .name("multi_eph")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(            
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(0)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("image")
 *                     .uuid("<image-id>")
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(-1)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("blank")
 *                     .volumeSize(1)
 *                     .guestFormat("ext4")
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(-1)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("blank")
 *                     .volumeSize(1)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance with Boot Disk and Swap Disk
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Flavor;
 * import com.pulumi.openstack.compute.FlavorArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var flavor_with_swap = new Flavor("flavor-with-swap", FlavorArgs.builder()
 *             .name("flavor-with-swap")
 *             .ram(8096)
 *             .vcpus(2)
 *             .disk(20)
 *             .swap(4096)
 *             .build());
 * 
 *         var vm_swap = new Instance("vm-swap", InstanceArgs.builder()
 *             .name("vm_swap")
 *             .flavorId(flavor_with_swap.id())
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .blockDevices(            
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(0)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("image")
 *                     .uuid("<image-id>")
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(-1)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("blank")
 *                     .guestFormat("swap")
 *                     .volumeSize(4)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instance with User Data (cloud-init)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance1 = new Instance("instance1", InstanceArgs.builder()
 *             .name("basic")
 *             .imageId("ad091b52-742f-469e-8f3c-fd81cadf0743")
 *             .flavorId("3")
 *             .keyPair("my_key_pair_name")
 *             .securityGroups("default")
 *             .userData("""
 * #cloud-config
 * hostname: instance_1.example.com
 * fqdn: instance_1.example.com            """)
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("my_network")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * `userData` can come from a variety of sources: inline, read in from the `file`
 * function, or the `templateCloudinitConfig` resource.
 * 
 * ## Notes
 * 
 * ### Multiple Ephemeral Disks
 * 
 * It&#39;s possible to specify multiple `blockDevice` entries to create an instance
 * with multiple ephemeral (local) disks. In order to create multiple ephemeral
 * disks, the sum of the total amount of ephemeral space must be less than or
 * equal to what the chosen flavor supports.
 * 
 * The following example shows how to create an instance with multiple ephemeral
 * disks:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var foo = new Instance("foo", InstanceArgs.builder()
 *             .name("terraform-test")
 *             .securityGroups("default")
 *             .blockDevices(            
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(0)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("image")
 *                     .uuid("<image uuid>")
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(-1)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("blank")
 *                     .volumeSize(1)
 *                     .build(),
 *                 InstanceBlockDeviceArgs.builder()
 *                     .bootIndex(-1)
 *                     .deleteOnTermination(true)
 *                     .destinationType("local")
 *                     .sourceType("blank")
 *                     .volumeSize(1)
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instances and Security Groups
 * 
 * When referencing a security group resource in an instance resource, always
 * use the _name_ of the security group. If you specify the ID of the security
 * group, Terraform will remove and reapply the security group upon each call.
 * This is because the OpenStack Compute API returns the names of the associated
 * security groups and not their IDs.
 * 
 * Note the following example:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.networking.SecGroup;
 * import com.pulumi.openstack.networking.SecGroupArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var sg1 = new SecGroup("sg1", SecGroupArgs.builder()
 *             .name("sg_1")
 *             .build());
 * 
 *         var foo = new Instance("foo", InstanceArgs.builder()
 *             .name("terraform-test")
 *             .securityGroups(sg1.name())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instances and Ports
 * 
 * Neutron Ports are a great feature and provide a lot of functionality. However,
 * there are some notes to be aware of when mixing Instances and Ports:
 * 
 * * In OpenStack environments prior to the Kilo release, deleting or recreating
 * an Instance will cause the Instance&#39;s Port(s) to be deleted. One way of working
 * around this is to taint any Port(s) used in Instances which are to be recreated.
 * See [here](https://review.openstack.org/#/c/126309/) for further information.
 * 
 * * When attaching an Instance to one or more networks using Ports, place the
 * security groups on the Port and not the Instance. If you place the security
 * groups on the Instance, the security groups will not be applied upon creation,
 * but they will be applied upon a refresh. This is a known OpenStack bug.
 * 
 * * Network IP information is not available within an instance for networks that
 * are attached with Ports. This is mostly due to the flexibility Neutron Ports
 * provide when it comes to IP addresses. For example, a Neutron Port can have
 * multiple Fixed IP addresses associated with it. It&#39;s not possible to know which
 * single IP address the user would want returned to the Instance&#39;s state
 * information. Therefore, in order for a Provisioner to connect to an Instance
 * via it&#39;s network Port, customize the `connection` information:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.networking.Port;
 * import com.pulumi.openstack.networking.PortArgs;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var port1 = new Port("port1", PortArgs.builder()
 *             .name("port_1")
 *             .adminStateUp(true)
 *             .networkId("0a1d0a27-cffa-4de3-92c5-9d3fd3f2e74d")
 *             .securityGroupIds(            
 *                 "2f02d20a-8dca-49b7-b26f-b6ce9fddaf4f",
 *                 "ca1e5ed7-dae8-4605-987b-fadaeeb30461")
 *             .build());
 * 
 *         var instance1 = new Instance("instance1", InstanceArgs.builder()
 *             .name("instance_1")
 *             .networks(InstanceNetworkArgs.builder()
 *                 .port(port1.id())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Instances and Networks
 * 
 * Instances almost always require a network. Here are some notes to be aware of
 * with how Instances and Networks relate:
 * 
 * * In scenarios where you only have one network available, you can create an
 * instance without specifying a `network` block. OpenStack will automatically
 * launch the instance on this network.
 * 
 * * If you have access to more than one network, you will need to specify a network
 * with a `network` block. Not specifying a network will result in the following
 * error:
 * 
 * * If you intend to use the `openstack.compute.InterfaceAttach` resource,
 *   you still need to make sure one of the above points is satisfied. An instance
 *   cannot be created without a valid network configuration even if you intend to
 *   use `openstack.compute.InterfaceAttach` after the instance has been created.
 * 
 * ## Importing instances
 * 
 * Importing instances can be tricky, since the nova api does not offer all
 * information provided at creation time for later retrieval.
 * Network interface attachment order, and number and sizes of ephemeral
 * disks are examples of this.
 * 
 * ### Importing basic instance
 * Assume you want to import an instance with one ephemeral root disk,
 * and one network interface.
 * 
 * Your configuration would look like the following:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var basicInstance = new Instance("basicInstance", InstanceArgs.builder()
 *             .name("basic")
 *             .flavorId("<flavor_id>")
 *             .keyPair("<keyname>")
 *             .securityGroups("default")
 *             .imageId("<image_id>")
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("<network_name>")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * Then you execute
 * 
 * ### Importing an instance with multiple emphemeral disks
 * 
 * The importer cannot read the emphemeral disk configuration
 * of an instance, so just specify imageId as in the configuration
 * of the basic instance example.
 * 
 * ### Importing instance with multiple network interfaces.
 * 
 * Nova returns the network interfaces grouped by network, thus not in creation
 * order.
 * That means that if you have multiple network interfaces you must take
 * care of the order of networks in your configuration.
 * 
 * As example we want to import an instance with one ephemeral root disk,
 * and 3 network interfaces.
 * 
 * Examples
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var boot_from_volume = new Instance("boot-from-volume", InstanceArgs.builder()
 *             .name("boot-from-volume")
 *             .flavorId("<flavor_id")
 *             .keyPair("<keyname>")
 *             .imageId("<image_id>")
 *             .securityGroups("default")
 *             .networks(            
 *                 InstanceNetworkArgs.builder()
 *                     .name("<network1>")
 *                     .build(),
 *                 InstanceNetworkArgs.builder()
 *                     .name("<network2>")
 *                     .build(),
 *                 InstanceNetworkArgs.builder()
 *                     .name("<network1>")
 *                     .fixedIpV4("<fixed_ip_v4>")
 *                     .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * In the above configuration the networks are out of order compared to what nova
 * and thus the import code returns, which means the plan will not
 * be empty after import.
 * 
 * So either with care check the plan and modify configuration, or read the
 * network order in the state file after import and modify your
 * configuration accordingly.
 * 
 *  * A note on ports. If you have created a neutron port independent of an
 *     instance, then the import code has no way to detect that the port is created
 *     idenpendently, and therefore on deletion of imported instances you might have
 *     port resources in your project, which you expected to be created by the
 *     instance and thus to also be deleted with the instance.
 * 
 * ### Importing instances with multiple block storage volumes.
 * 
 * We have an instance with two block storage volumes, one bootable and one
 * non-bootable.
 * Note that we only configure the bootable device as block_device.
 * The other volumes can be specified as `openstack.blockstorage.Volume`
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.openstack.compute.Instance;
 * import com.pulumi.openstack.compute.InstanceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
 * import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
 * import com.pulumi.openstack.blockstorage.Volume;
 * import com.pulumi.openstack.blockstorage.VolumeArgs;
 * import com.pulumi.openstack.compute.VolumeAttach;
 * import com.pulumi.openstack.compute.VolumeAttachArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var instance2 = new Instance("instance2", InstanceArgs.builder()
 *             .name("instance_2")
 *             .imageId("<image_id>")
 *             .flavorId("<flavor_id>")
 *             .keyPair("<keyname>")
 *             .securityGroups("default")
 *             .blockDevices(InstanceBlockDeviceArgs.builder()
 *                 .uuid("<image_id>")
 *                 .sourceType("image")
 *                 .destinationType("volume")
 *                 .bootIndex(0)
 *                 .deleteOnTermination(true)
 *                 .build())
 *             .networks(InstanceNetworkArgs.builder()
 *                 .name("<network_name>")
 *                 .build())
 *             .build());
 * 
 *         var volume1 = new Volume("volume1", VolumeArgs.builder()
 *             .size(1)
 *             .name("<vol_name>")
 *             .build());
 * 
 *         var va1 = new VolumeAttach("va1", VolumeAttachArgs.builder()
 *             .volumeId(volume1.id())
 *             .instanceId(instance2.id())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * To import the instance outlined in the above configuration
 * do the following:
 * 
 * * A note on block storage volumes, the importer does not read
 *   deleteOnTermination flag, and always assumes true. If you
 *   import an instance created with deleteOnTermination false,
 *   you end up with &#34;orphaned&#34; volumes after destruction of
 *   instances.
 * 
 */
@ResourceType(type="openstack:compute/instance:Instance")
public class Instance extends com.pulumi.resources.CustomResource {
    /**
     * The first detected Fixed IPv4 address.
     * 
     */
    @Export(name="accessIpV4", refs={String.class}, tree="[0]")
    private Output<String> accessIpV4;

    /**
     * @return The first detected Fixed IPv4 address.
     * 
     */
    public Output<String> accessIpV4() {
        return this.accessIpV4;
    }
    /**
     * The first detected Fixed IPv6 address.
     * 
     */
    @Export(name="accessIpV6", refs={String.class}, tree="[0]")
    private Output<String> accessIpV6;

    /**
     * @return The first detected Fixed IPv6 address.
     * 
     */
    public Output<String> accessIpV6() {
        return this.accessIpV6;
    }
    /**
     * The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     * 
     */
    @Export(name="adminPass", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> adminPass;

    /**
     * @return The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     * 
     */
    public Output<Optional<String>> adminPass() {
        return Codegen.optional(this.adminPass);
    }
    /**
     * Contains all instance metadata, even metadata not set
     * by Terraform.
     * 
     */
    @Export(name="allMetadata", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> allMetadata;

    /**
     * @return Contains all instance metadata, even metadata not set
     * by Terraform.
     * 
     */
    public Output<Map<String,String>> allMetadata() {
        return this.allMetadata;
    }
    /**
     * The collection of tags assigned on the instance, which have
     * been explicitly and implicitly added.
     * 
     */
    @Export(name="allTags", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> allTags;

    /**
     * @return The collection of tags assigned on the instance, which have
     * been explicitly and implicitly added.
     * 
     */
    public Output<List<String>> allTags() {
        return this.allTags;
    }
    /**
     * The availability zone in which to create
     * the server. Conflicts with `availabilityZoneHints`. Changing this creates
     * a new server.
     * 
     */
    @Export(name="availabilityZone", refs={String.class}, tree="[0]")
    private Output<String> availabilityZone;

    /**
     * @return The availability zone in which to create
     * the server. Conflicts with `availabilityZoneHints`. Changing this creates
     * a new server.
     * 
     */
    public Output<String> availabilityZone() {
        return this.availabilityZone;
    }
    /**
     * The availability zone in which to
     * create the server. This argument is preferred to `availabilityZone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availabilityZone`. Changing this creates a
     * new server.
     * 
     */
    @Export(name="availabilityZoneHints", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> availabilityZoneHints;

    /**
     * @return The availability zone in which to
     * create the server. This argument is preferred to `availabilityZone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availabilityZone`. Changing this creates a
     * new server.
     * 
     */
    public Output<Optional<String>> availabilityZoneHints() {
        return Codegen.optional(this.availabilityZoneHints);
    }
    /**
     * Configuration of block devices. The blockDevice
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     * 
     */
    @Export(name="blockDevices", refs={List.class,InstanceBlockDevice.class}, tree="[0,1]")
    private Output</* @Nullable */ List<InstanceBlockDevice>> blockDevices;

    /**
     * @return Configuration of block devices. The blockDevice
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     * 
     */
    public Output<Optional<List<InstanceBlockDevice>>> blockDevices() {
        return Codegen.optional(this.blockDevices);
    }
    /**
     * Whether to use the configDrive feature to
     * configure the instance. Changing this creates a new server.
     * 
     */
    @Export(name="configDrive", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> configDrive;

    /**
     * @return Whether to use the configDrive feature to
     * configure the instance. Changing this creates a new server.
     * 
     */
    public Output<Optional<Boolean>> configDrive() {
        return Codegen.optional(this.configDrive);
    }
    /**
     * The creation time of the instance.
     * 
     */
    @Export(name="created", refs={String.class}, tree="[0]")
    private Output<String> created;

    /**
     * @return The creation time of the instance.
     * 
     */
    public Output<String> created() {
        return this.created;
    }
    /**
     * The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    @Export(name="flavorId", refs={String.class}, tree="[0]")
    private Output<String> flavorId;

    /**
     * @return The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    public Output<String> flavorId() {
        return this.flavorId;
    }
    /**
     * The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    @Export(name="flavorName", refs={String.class}, tree="[0]")
    private Output<String> flavorName;

    /**
     * @return The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    public Output<String> flavorName() {
        return this.flavorName;
    }
    /**
     * Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     * 
     */
    @Export(name="forceDelete", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceDelete;

    /**
     * @return Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     * 
     */
    public Output<Optional<Boolean>> forceDelete() {
        return Codegen.optional(this.forceDelete);
    }
    /**
     * Specifies the exact hypervisor hostname on
     * which to create the instance. When provided, this parameter is included in
     * the request to Nova, directing the scheduler to launch the instance on the
     * specified host. Note: This option requires administrative privileges and a
     * Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
     * this value forces a new instance to be created.
     * 
     */
    @Export(name="hypervisorHostname", refs={String.class}, tree="[0]")
    private Output<String> hypervisorHostname;

    /**
     * @return Specifies the exact hypervisor hostname on
     * which to create the instance. When provided, this parameter is included in
     * the request to Nova, directing the scheduler to launch the instance on the
     * specified host. Note: This option requires administrative privileges and a
     * Nova microversion of 2.74 or later. Conflicts with `personality`. Changing
     * this value forces a new instance to be created.
     * 
     */
    public Output<String> hypervisorHostname() {
        return this.hypervisorHostname;
    }
    /**
     * (Optional; Required if `imageName` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     * 
     */
    @Export(name="imageId", refs={String.class}, tree="[0]")
    private Output<String> imageId;

    /**
     * @return (Optional; Required if `imageName` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     * 
     */
    public Output<String> imageId() {
        return this.imageId;
    }
    /**
     * (Optional; Required if `imageId` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     * 
     */
    @Export(name="imageName", refs={String.class}, tree="[0]")
    private Output<String> imageName;

    /**
     * @return (Optional; Required if `imageId` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     * 
     */
    public Output<String> imageName() {
        return this.imageName;
    }
    /**
     * The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant&#39;s account.
     * Changing this creates a new server.
     * 
     */
    @Export(name="keyPair", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> keyPair;

    /**
     * @return The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant&#39;s account.
     * Changing this creates a new server.
     * 
     */
    public Output<Optional<String>> keyPair() {
        return Codegen.optional(this.keyPair);
    }
    /**
     * Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     * 
     */
    @Export(name="metadata", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> metadata;

    /**
     * @return Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     * 
     */
    public Output<Optional<Map<String,String>>> metadata() {
        return Codegen.optional(this.metadata);
    }
    /**
     * A unique name for the resource.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return A unique name for the resource.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Special string for `network` option to create
     * the server. `networkMode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     * 
     */
    @Export(name="networkMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> networkMode;

    /**
     * @return Special string for `network` option to create
     * the server. `networkMode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     * 
     */
    public Output<Optional<String>> networkMode() {
        return Codegen.optional(this.networkMode);
    }
    /**
     * An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     * 
     */
    @Export(name="networks", refs={List.class,InstanceNetwork.class}, tree="[0,1]")
    private Output<List<InstanceNetwork>> networks;

    /**
     * @return An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     * 
     */
    public Output<List<InstanceNetwork>> networks() {
        return this.networks;
    }
    /**
     * Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure is
     * described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
     * the existing server.
     * 
     */
    @Export(name="personalities", refs={List.class,InstancePersonality.class}, tree="[0,1]")
    private Output</* @Nullable */ List<InstancePersonality>> personalities;

    /**
     * @return Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure is
     * described below. Conflicts with `hypervisorHostname`. Changing this rebuilds
     * the existing server.
     * 
     */
    public Output<Optional<List<InstancePersonality>>> personalities() {
        return Codegen.optional(this.personalities);
    }
    /**
     * Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;, &#39;paused&#39;
     * and &#39;shelved_offloaded&#39; are supported values.
     * *Note*: If the initial powerState is the shutoff or paused
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     * 
     */
    @Export(name="powerState", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> powerState;

    /**
     * @return Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;, &#39;paused&#39;
     * and &#39;shelved_offloaded&#39; are supported values.
     * *Note*: If the initial powerState is the shutoff or paused
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     * 
     */
    public Output<Optional<String>> powerState() {
        return Codegen.optional(this.powerState);
    }
    /**
     * The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     * 
     */
    @Export(name="schedulerHints", refs={List.class,InstanceSchedulerHint.class}, tree="[0,1]")
    private Output</* @Nullable */ List<InstanceSchedulerHint>> schedulerHints;

    /**
     * @return Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     * 
     */
    public Output<Optional<List<InstanceSchedulerHint>>> schedulerHints() {
        return Codegen.optional(this.schedulerHints);
    }
    /**
     * An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     * 
     */
    @Export(name="securityGroups", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> securityGroups;

    /**
     * @return An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     * 
     */
    public Output<List<String>> securityGroups() {
        return this.securityGroups;
    }
    /**
     * Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
     * 
     */
    @Export(name="stopBeforeDestroy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> stopBeforeDestroy;

    /**
     * @return Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
     * 
     */
    public Output<Optional<Boolean>> stopBeforeDestroy() {
        return Codegen.optional(this.stopBeforeDestroy);
    }
    /**
     * A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The time when the instance was last updated.
     * 
     */
    @Export(name="updated", refs={String.class}, tree="[0]")
    private Output<String> updated;

    /**
     * @return The time when the instance was last updated.
     * 
     */
    public Output<String> updated() {
        return this.updated;
    }
    /**
     * The user data to provide when launching the instance.
     * Changing this creates a new server.
     * 
     */
    @Export(name="userData", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> userData;

    /**
     * @return The user data to provide when launching the instance.
     * Changing this creates a new server.
     * 
     */
    public Output<Optional<String>> userData() {
        return Codegen.optional(this.userData);
    }
    /**
     * Map of additional vendor-specific options.
     * Supported options are described below.
     * 
     */
    @Export(name="vendorOptions", refs={InstanceVendorOptions.class}, tree="[0]")
    private Output</* @Nullable */ InstanceVendorOptions> vendorOptions;

    /**
     * @return Map of additional vendor-specific options.
     * Supported options are described below.
     * 
     */
    public Output<Optional<InstanceVendorOptions>> vendorOptions() {
        return Codegen.optional(this.vendorOptions);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Instance(java.lang.String name) {
        this(name, InstanceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Instance(java.lang.String name, @Nullable InstanceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Instance(java.lang.String name, @Nullable InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("openstack:compute/instance:Instance", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Instance(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("openstack:compute/instance:Instance", name, state, makeResourceOptions(options, id), false);
    }

    private static InstanceArgs makeArgs(@Nullable InstanceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? InstanceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "adminPass"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Instance get(java.lang.String name, Output<java.lang.String> id, @Nullable InstanceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Instance(name, id, state, options);
    }
}
