// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.openstack.compute;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.openstack.compute.inputs.InstanceBlockDeviceArgs;
import com.pulumi.openstack.compute.inputs.InstanceNetworkArgs;
import com.pulumi.openstack.compute.inputs.InstancePersonalityArgs;
import com.pulumi.openstack.compute.inputs.InstanceSchedulerHintArgs;
import com.pulumi.openstack.compute.inputs.InstanceVendorOptionsArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class InstanceArgs extends com.pulumi.resources.ResourceArgs {

    public static final InstanceArgs Empty = new InstanceArgs();

    /**
     * The first detected Fixed IPv4 address.
     * 
     */
    @Import(name="accessIpV4")
    private @Nullable Output<String> accessIpV4;

    /**
     * @return The first detected Fixed IPv4 address.
     * 
     */
    public Optional<Output<String>> accessIpV4() {
        return Optional.ofNullable(this.accessIpV4);
    }

    /**
     * The first detected Fixed IPv6 address.
     * 
     */
    @Import(name="accessIpV6")
    private @Nullable Output<String> accessIpV6;

    /**
     * @return The first detected Fixed IPv6 address.
     * 
     */
    public Optional<Output<String>> accessIpV6() {
        return Optional.ofNullable(this.accessIpV6);
    }

    /**
     * The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     * 
     */
    @Import(name="adminPass")
    private @Nullable Output<String> adminPass;

    /**
     * @return The administrative password to assign to the server.
     * Changing this changes the root password on the existing server.
     * 
     */
    public Optional<Output<String>> adminPass() {
        return Optional.ofNullable(this.adminPass);
    }

    /**
     * The availability zone in which to create
     * the server. Conflicts with `availability_zone_hints`. Changing this creates
     * a new server.
     * 
     */
    @Import(name="availabilityZone")
    private @Nullable Output<String> availabilityZone;

    /**
     * @return The availability zone in which to create
     * the server. Conflicts with `availability_zone_hints`. Changing this creates
     * a new server.
     * 
     */
    public Optional<Output<String>> availabilityZone() {
        return Optional.ofNullable(this.availabilityZone);
    }

    /**
     * The availability zone in which to
     * create the server. This argument is preferred to `availability_zone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availability_zone`. Changing this creates a
     * new server.
     * 
     */
    @Import(name="availabilityZoneHints")
    private @Nullable Output<String> availabilityZoneHints;

    /**
     * @return The availability zone in which to
     * create the server. This argument is preferred to `availability_zone`, when
     * scheduling the server on a
     * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
     * host or node. Conflicts with `availability_zone`. Changing this creates a
     * new server.
     * 
     */
    public Optional<Output<String>> availabilityZoneHints() {
        return Optional.ofNullable(this.availabilityZoneHints);
    }

    /**
     * Configuration of block devices. The block_device
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     * 
     */
    @Import(name="blockDevices")
    private @Nullable Output<List<InstanceBlockDeviceArgs>> blockDevices;

    /**
     * @return Configuration of block devices. The block_device
     * structure is documented below. Changing this creates a new server.
     * You can specify multiple block devices which will create an instance with
     * multiple disks. This configuration is very flexible, so please see the
     * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
     * for more information.
     * 
     */
    public Optional<Output<List<InstanceBlockDeviceArgs>>> blockDevices() {
        return Optional.ofNullable(this.blockDevices);
    }

    /**
     * Whether to use the config_drive feature to
     * configure the instance. Changing this creates a new server.
     * 
     */
    @Import(name="configDrive")
    private @Nullable Output<Boolean> configDrive;

    /**
     * @return Whether to use the config_drive feature to
     * configure the instance. Changing this creates a new server.
     * 
     */
    public Optional<Output<Boolean>> configDrive() {
        return Optional.ofNullable(this.configDrive);
    }

    /**
     * The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    @Import(name="flavorId")
    private @Nullable Output<String> flavorId;

    /**
     * @return The flavor ID of
     * the desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    public Optional<Output<String>> flavorId() {
        return Optional.ofNullable(this.flavorId);
    }

    /**
     * The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    @Import(name="flavorName")
    private @Nullable Output<String> flavorName;

    /**
     * @return The name of the
     * desired flavor for the server. Changing this resizes the existing server.
     * 
     */
    public Optional<Output<String>> flavorName() {
        return Optional.ofNullable(this.flavorName);
    }

    /**
     * Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     * 
     */
    @Import(name="forceDelete")
    private @Nullable Output<Boolean> forceDelete;

    /**
     * @return Whether to force the OpenStack instance to be
     * forcefully deleted. This is useful for environments that have reclaim / soft
     * deletion enabled.
     * 
     */
    public Optional<Output<Boolean>> forceDelete() {
        return Optional.ofNullable(this.forceDelete);
    }

    /**
     * (Optional; Required if `image_name` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     * 
     */
    @Import(name="imageId")
    private @Nullable Output<String> imageId;

    /**
     * @return (Optional; Required if `image_name` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The image ID of
     * the desired image for the server. Changing this rebuilds the existing
     * server.
     * 
     */
    public Optional<Output<String>> imageId() {
        return Optional.ofNullable(this.imageId);
    }

    /**
     * (Optional; Required if `image_id` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     * 
     */
    @Import(name="imageName")
    private @Nullable Output<String> imageName;

    /**
     * @return (Optional; Required if `image_id` is empty and not booting
     * from a volume. Do not specify if booting from a volume.) The name of the
     * desired image for the server. Changing this rebuilds the existing server.
     * 
     */
    public Optional<Output<String>> imageName() {
        return Optional.ofNullable(this.imageName);
    }

    /**
     * The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant&#39;s account.
     * Changing this creates a new server.
     * 
     */
    @Import(name="keyPair")
    private @Nullable Output<String> keyPair;

    /**
     * @return The name of a key pair to put on the server. The key
     * pair must already be created and associated with the tenant&#39;s account.
     * Changing this creates a new server.
     * 
     */
    public Optional<Output<String>> keyPair() {
        return Optional.ofNullable(this.keyPair);
    }

    /**
     * Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     * 
     */
    @Import(name="metadata")
    private @Nullable Output<Map<String,String>> metadata;

    /**
     * @return Metadata key/value pairs to make available from
     * within the instance. Changing this updates the existing server metadata.
     * 
     */
    public Optional<Output<Map<String,String>>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * A unique name for the resource.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return A unique name for the resource.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Special string for `network` option to create
     * the server. `network_mode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     * 
     */
    @Import(name="networkMode")
    private @Nullable Output<String> networkMode;

    /**
     * @return Special string for `network` option to create
     * the server. `network_mode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
     * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
     * 
     */
    public Optional<Output<String>> networkMode() {
        return Optional.ofNullable(this.networkMode);
    }

    /**
     * An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     * 
     */
    @Import(name="networks")
    private @Nullable Output<List<InstanceNetworkArgs>> networks;

    /**
     * @return An array of one or more networks to attach to the
     * instance. The network object structure is documented below. Changing this
     * creates a new server.
     * 
     */
    public Optional<Output<List<InstanceNetworkArgs>>> networks() {
        return Optional.ofNullable(this.networks);
    }

    /**
     * Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure
     * is described below. Changing this rebuilds the existing server.
     * 
     */
    @Import(name="personalities")
    private @Nullable Output<List<InstancePersonalityArgs>> personalities;

    /**
     * @return Customize the personality of an instance by
     * defining one or more files and their contents. The personality structure
     * is described below. Changing this rebuilds the existing server.
     * 
     */
    public Optional<Output<List<InstancePersonalityArgs>>> personalities() {
        return Optional.ofNullable(this.personalities);
    }

    /**
     * Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;
     * and &#39;shelved_offloaded&#39; are supported values.
     * *Note*: If the initial power_state is the shutoff
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     * 
     */
    @Import(name="powerState")
    private @Nullable Output<String> powerState;

    /**
     * @return Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;
     * and &#39;shelved_offloaded&#39; are supported values.
     * *Note*: If the initial power_state is the shutoff
     * the VM will be stopped immediately after build and the provisioners like
     * remote-exec or files are not supported.
     * 
     */
    public Optional<Output<String>> powerState() {
        return Optional.ofNullable(this.powerState);
    }

    /**
     * The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region in which to create the server instance. If
     * omitted, the `region` argument of the provider is used. Changing this
     * creates a new server.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     * 
     */
    @Import(name="schedulerHints")
    private @Nullable Output<List<InstanceSchedulerHintArgs>> schedulerHints;

    /**
     * @return Provide the Nova scheduler with hints on how
     * the instance should be launched. The available hints are described below.
     * 
     */
    public Optional<Output<List<InstanceSchedulerHintArgs>>> schedulerHints() {
        return Optional.ofNullable(this.schedulerHints);
    }

    /**
     * An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     * 
     */
    @Import(name="securityGroups")
    private @Nullable Output<List<String>> securityGroups;

    /**
     * @return An array of one or more security group names
     * to associate with the server. Changing this results in adding/removing
     * security groups from the existing server. *Note*: When attaching the
     * instance to networks using Ports, place the security groups on the Port
     * and not the instance. *Note*: Names should be used and not ids, as ids
     * trigger unnecessary updates.
     * 
     */
    public Optional<Output<List<String>>> securityGroups() {
        return Optional.ofNullable(this.securityGroups);
    }

    /**
     * Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
     * 
     */
    @Import(name="stopBeforeDestroy")
    private @Nullable Output<Boolean> stopBeforeDestroy;

    /**
     * @return Whether to try stop instance gracefully
     * before destroying it, thus giving chance for guest OS daemons to stop correctly.
     * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
     * 
     */
    public Optional<Output<Boolean>> stopBeforeDestroy() {
        return Optional.ofNullable(this.stopBeforeDestroy);
    }

    /**
     * A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return A set of string tags for the instance. Changing this
     * updates the existing instance tags.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * The user data to provide when launching the instance.
     * Changing this creates a new server.
     * 
     */
    @Import(name="userData")
    private @Nullable Output<String> userData;

    /**
     * @return The user data to provide when launching the instance.
     * Changing this creates a new server.
     * 
     */
    public Optional<Output<String>> userData() {
        return Optional.ofNullable(this.userData);
    }

    /**
     * Map of additional vendor-specific options.
     * Supported options are described below.
     * 
     */
    @Import(name="vendorOptions")
    private @Nullable Output<InstanceVendorOptionsArgs> vendorOptions;

    /**
     * @return Map of additional vendor-specific options.
     * Supported options are described below.
     * 
     */
    public Optional<Output<InstanceVendorOptionsArgs>> vendorOptions() {
        return Optional.ofNullable(this.vendorOptions);
    }

    private InstanceArgs() {}

    private InstanceArgs(InstanceArgs $) {
        this.accessIpV4 = $.accessIpV4;
        this.accessIpV6 = $.accessIpV6;
        this.adminPass = $.adminPass;
        this.availabilityZone = $.availabilityZone;
        this.availabilityZoneHints = $.availabilityZoneHints;
        this.blockDevices = $.blockDevices;
        this.configDrive = $.configDrive;
        this.flavorId = $.flavorId;
        this.flavorName = $.flavorName;
        this.forceDelete = $.forceDelete;
        this.imageId = $.imageId;
        this.imageName = $.imageName;
        this.keyPair = $.keyPair;
        this.metadata = $.metadata;
        this.name = $.name;
        this.networkMode = $.networkMode;
        this.networks = $.networks;
        this.personalities = $.personalities;
        this.powerState = $.powerState;
        this.region = $.region;
        this.schedulerHints = $.schedulerHints;
        this.securityGroups = $.securityGroups;
        this.stopBeforeDestroy = $.stopBeforeDestroy;
        this.tags = $.tags;
        this.userData = $.userData;
        this.vendorOptions = $.vendorOptions;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(InstanceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private InstanceArgs $;

        public Builder() {
            $ = new InstanceArgs();
        }

        public Builder(InstanceArgs defaults) {
            $ = new InstanceArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param accessIpV4 The first detected Fixed IPv4 address.
         * 
         * @return builder
         * 
         */
        public Builder accessIpV4(@Nullable Output<String> accessIpV4) {
            $.accessIpV4 = accessIpV4;
            return this;
        }

        /**
         * @param accessIpV4 The first detected Fixed IPv4 address.
         * 
         * @return builder
         * 
         */
        public Builder accessIpV4(String accessIpV4) {
            return accessIpV4(Output.of(accessIpV4));
        }

        /**
         * @param accessIpV6 The first detected Fixed IPv6 address.
         * 
         * @return builder
         * 
         */
        public Builder accessIpV6(@Nullable Output<String> accessIpV6) {
            $.accessIpV6 = accessIpV6;
            return this;
        }

        /**
         * @param accessIpV6 The first detected Fixed IPv6 address.
         * 
         * @return builder
         * 
         */
        public Builder accessIpV6(String accessIpV6) {
            return accessIpV6(Output.of(accessIpV6));
        }

        /**
         * @param adminPass The administrative password to assign to the server.
         * Changing this changes the root password on the existing server.
         * 
         * @return builder
         * 
         */
        public Builder adminPass(@Nullable Output<String> adminPass) {
            $.adminPass = adminPass;
            return this;
        }

        /**
         * @param adminPass The administrative password to assign to the server.
         * Changing this changes the root password on the existing server.
         * 
         * @return builder
         * 
         */
        public Builder adminPass(String adminPass) {
            return adminPass(Output.of(adminPass));
        }

        /**
         * @param availabilityZone The availability zone in which to create
         * the server. Conflicts with `availability_zone_hints`. Changing this creates
         * a new server.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZone(@Nullable Output<String> availabilityZone) {
            $.availabilityZone = availabilityZone;
            return this;
        }

        /**
         * @param availabilityZone The availability zone in which to create
         * the server. Conflicts with `availability_zone_hints`. Changing this creates
         * a new server.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZone(String availabilityZone) {
            return availabilityZone(Output.of(availabilityZone));
        }

        /**
         * @param availabilityZoneHints The availability zone in which to
         * create the server. This argument is preferred to `availability_zone`, when
         * scheduling the server on a
         * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
         * host or node. Conflicts with `availability_zone`. Changing this creates a
         * new server.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZoneHints(@Nullable Output<String> availabilityZoneHints) {
            $.availabilityZoneHints = availabilityZoneHints;
            return this;
        }

        /**
         * @param availabilityZoneHints The availability zone in which to
         * create the server. This argument is preferred to `availability_zone`, when
         * scheduling the server on a
         * [particular](https://docs.openstack.org/nova/latest/admin/availability-zones.html)
         * host or node. Conflicts with `availability_zone`. Changing this creates a
         * new server.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZoneHints(String availabilityZoneHints) {
            return availabilityZoneHints(Output.of(availabilityZoneHints));
        }

        /**
         * @param blockDevices Configuration of block devices. The block_device
         * structure is documented below. Changing this creates a new server.
         * You can specify multiple block devices which will create an instance with
         * multiple disks. This configuration is very flexible, so please see the
         * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder blockDevices(@Nullable Output<List<InstanceBlockDeviceArgs>> blockDevices) {
            $.blockDevices = blockDevices;
            return this;
        }

        /**
         * @param blockDevices Configuration of block devices. The block_device
         * structure is documented below. Changing this creates a new server.
         * You can specify multiple block devices which will create an instance with
         * multiple disks. This configuration is very flexible, so please see the
         * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder blockDevices(List<InstanceBlockDeviceArgs> blockDevices) {
            return blockDevices(Output.of(blockDevices));
        }

        /**
         * @param blockDevices Configuration of block devices. The block_device
         * structure is documented below. Changing this creates a new server.
         * You can specify multiple block devices which will create an instance with
         * multiple disks. This configuration is very flexible, so please see the
         * following [reference](https://docs.openstack.org/nova/latest/user/block-device-mapping.html)
         * for more information.
         * 
         * @return builder
         * 
         */
        public Builder blockDevices(InstanceBlockDeviceArgs... blockDevices) {
            return blockDevices(List.of(blockDevices));
        }

        /**
         * @param configDrive Whether to use the config_drive feature to
         * configure the instance. Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder configDrive(@Nullable Output<Boolean> configDrive) {
            $.configDrive = configDrive;
            return this;
        }

        /**
         * @param configDrive Whether to use the config_drive feature to
         * configure the instance. Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder configDrive(Boolean configDrive) {
            return configDrive(Output.of(configDrive));
        }

        /**
         * @param flavorId The flavor ID of
         * the desired flavor for the server. Changing this resizes the existing server.
         * 
         * @return builder
         * 
         */
        public Builder flavorId(@Nullable Output<String> flavorId) {
            $.flavorId = flavorId;
            return this;
        }

        /**
         * @param flavorId The flavor ID of
         * the desired flavor for the server. Changing this resizes the existing server.
         * 
         * @return builder
         * 
         */
        public Builder flavorId(String flavorId) {
            return flavorId(Output.of(flavorId));
        }

        /**
         * @param flavorName The name of the
         * desired flavor for the server. Changing this resizes the existing server.
         * 
         * @return builder
         * 
         */
        public Builder flavorName(@Nullable Output<String> flavorName) {
            $.flavorName = flavorName;
            return this;
        }

        /**
         * @param flavorName The name of the
         * desired flavor for the server. Changing this resizes the existing server.
         * 
         * @return builder
         * 
         */
        public Builder flavorName(String flavorName) {
            return flavorName(Output.of(flavorName));
        }

        /**
         * @param forceDelete Whether to force the OpenStack instance to be
         * forcefully deleted. This is useful for environments that have reclaim / soft
         * deletion enabled.
         * 
         * @return builder
         * 
         */
        public Builder forceDelete(@Nullable Output<Boolean> forceDelete) {
            $.forceDelete = forceDelete;
            return this;
        }

        /**
         * @param forceDelete Whether to force the OpenStack instance to be
         * forcefully deleted. This is useful for environments that have reclaim / soft
         * deletion enabled.
         * 
         * @return builder
         * 
         */
        public Builder forceDelete(Boolean forceDelete) {
            return forceDelete(Output.of(forceDelete));
        }

        /**
         * @param imageId (Optional; Required if `image_name` is empty and not booting
         * from a volume. Do not specify if booting from a volume.) The image ID of
         * the desired image for the server. Changing this rebuilds the existing
         * server.
         * 
         * @return builder
         * 
         */
        public Builder imageId(@Nullable Output<String> imageId) {
            $.imageId = imageId;
            return this;
        }

        /**
         * @param imageId (Optional; Required if `image_name` is empty and not booting
         * from a volume. Do not specify if booting from a volume.) The image ID of
         * the desired image for the server. Changing this rebuilds the existing
         * server.
         * 
         * @return builder
         * 
         */
        public Builder imageId(String imageId) {
            return imageId(Output.of(imageId));
        }

        /**
         * @param imageName (Optional; Required if `image_id` is empty and not booting
         * from a volume. Do not specify if booting from a volume.) The name of the
         * desired image for the server. Changing this rebuilds the existing server.
         * 
         * @return builder
         * 
         */
        public Builder imageName(@Nullable Output<String> imageName) {
            $.imageName = imageName;
            return this;
        }

        /**
         * @param imageName (Optional; Required if `image_id` is empty and not booting
         * from a volume. Do not specify if booting from a volume.) The name of the
         * desired image for the server. Changing this rebuilds the existing server.
         * 
         * @return builder
         * 
         */
        public Builder imageName(String imageName) {
            return imageName(Output.of(imageName));
        }

        /**
         * @param keyPair The name of a key pair to put on the server. The key
         * pair must already be created and associated with the tenant&#39;s account.
         * Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder keyPair(@Nullable Output<String> keyPair) {
            $.keyPair = keyPair;
            return this;
        }

        /**
         * @param keyPair The name of a key pair to put on the server. The key
         * pair must already be created and associated with the tenant&#39;s account.
         * Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder keyPair(String keyPair) {
            return keyPair(Output.of(keyPair));
        }

        /**
         * @param metadata Metadata key/value pairs to make available from
         * within the instance. Changing this updates the existing server metadata.
         * 
         * @return builder
         * 
         */
        public Builder metadata(@Nullable Output<Map<String,String>> metadata) {
            $.metadata = metadata;
            return this;
        }

        /**
         * @param metadata Metadata key/value pairs to make available from
         * within the instance. Changing this updates the existing server metadata.
         * 
         * @return builder
         * 
         */
        public Builder metadata(Map<String,String> metadata) {
            return metadata(Output.of(metadata));
        }

        /**
         * @param name A unique name for the resource.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique name for the resource.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkMode Special string for `network` option to create
         * the server. `network_mode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
         * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
         * 
         * @return builder
         * 
         */
        public Builder networkMode(@Nullable Output<String> networkMode) {
            $.networkMode = networkMode;
            return this;
        }

        /**
         * @param networkMode Special string for `network` option to create
         * the server. `network_mode` can be `&#34;auto&#34;` or `&#34;none&#34;`.
         * Please see the following [reference](https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#id11) for more information. Conflicts with `network`.
         * 
         * @return builder
         * 
         */
        public Builder networkMode(String networkMode) {
            return networkMode(Output.of(networkMode));
        }

        /**
         * @param networks An array of one or more networks to attach to the
         * instance. The network object structure is documented below. Changing this
         * creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder networks(@Nullable Output<List<InstanceNetworkArgs>> networks) {
            $.networks = networks;
            return this;
        }

        /**
         * @param networks An array of one or more networks to attach to the
         * instance. The network object structure is documented below. Changing this
         * creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder networks(List<InstanceNetworkArgs> networks) {
            return networks(Output.of(networks));
        }

        /**
         * @param networks An array of one or more networks to attach to the
         * instance. The network object structure is documented below. Changing this
         * creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder networks(InstanceNetworkArgs... networks) {
            return networks(List.of(networks));
        }

        /**
         * @param personalities Customize the personality of an instance by
         * defining one or more files and their contents. The personality structure
         * is described below. Changing this rebuilds the existing server.
         * 
         * @return builder
         * 
         */
        public Builder personalities(@Nullable Output<List<InstancePersonalityArgs>> personalities) {
            $.personalities = personalities;
            return this;
        }

        /**
         * @param personalities Customize the personality of an instance by
         * defining one or more files and their contents. The personality structure
         * is described below. Changing this rebuilds the existing server.
         * 
         * @return builder
         * 
         */
        public Builder personalities(List<InstancePersonalityArgs> personalities) {
            return personalities(Output.of(personalities));
        }

        /**
         * @param personalities Customize the personality of an instance by
         * defining one or more files and their contents. The personality structure
         * is described below. Changing this rebuilds the existing server.
         * 
         * @return builder
         * 
         */
        public Builder personalities(InstancePersonalityArgs... personalities) {
            return personalities(List.of(personalities));
        }

        /**
         * @param powerState Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;
         * and &#39;shelved_offloaded&#39; are supported values.
         * *Note*: If the initial power_state is the shutoff
         * the VM will be stopped immediately after build and the provisioners like
         * remote-exec or files are not supported.
         * 
         * @return builder
         * 
         */
        public Builder powerState(@Nullable Output<String> powerState) {
            $.powerState = powerState;
            return this;
        }

        /**
         * @param powerState Provide the VM state. Only &#39;active&#39;, &#39;shutoff&#39;
         * and &#39;shelved_offloaded&#39; are supported values.
         * *Note*: If the initial power_state is the shutoff
         * the VM will be stopped immediately after build and the provisioners like
         * remote-exec or files are not supported.
         * 
         * @return builder
         * 
         */
        public Builder powerState(String powerState) {
            return powerState(Output.of(powerState));
        }

        /**
         * @param region The region in which to create the server instance. If
         * omitted, the `region` argument of the provider is used. Changing this
         * creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region in which to create the server instance. If
         * omitted, the `region` argument of the provider is used. Changing this
         * creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param schedulerHints Provide the Nova scheduler with hints on how
         * the instance should be launched. The available hints are described below.
         * 
         * @return builder
         * 
         */
        public Builder schedulerHints(@Nullable Output<List<InstanceSchedulerHintArgs>> schedulerHints) {
            $.schedulerHints = schedulerHints;
            return this;
        }

        /**
         * @param schedulerHints Provide the Nova scheduler with hints on how
         * the instance should be launched. The available hints are described below.
         * 
         * @return builder
         * 
         */
        public Builder schedulerHints(List<InstanceSchedulerHintArgs> schedulerHints) {
            return schedulerHints(Output.of(schedulerHints));
        }

        /**
         * @param schedulerHints Provide the Nova scheduler with hints on how
         * the instance should be launched. The available hints are described below.
         * 
         * @return builder
         * 
         */
        public Builder schedulerHints(InstanceSchedulerHintArgs... schedulerHints) {
            return schedulerHints(List.of(schedulerHints));
        }

        /**
         * @param securityGroups An array of one or more security group names
         * to associate with the server. Changing this results in adding/removing
         * security groups from the existing server. *Note*: When attaching the
         * instance to networks using Ports, place the security groups on the Port
         * and not the instance. *Note*: Names should be used and not ids, as ids
         * trigger unnecessary updates.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(@Nullable Output<List<String>> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        /**
         * @param securityGroups An array of one or more security group names
         * to associate with the server. Changing this results in adding/removing
         * security groups from the existing server. *Note*: When attaching the
         * instance to networks using Ports, place the security groups on the Port
         * and not the instance. *Note*: Names should be used and not ids, as ids
         * trigger unnecessary updates.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(List<String> securityGroups) {
            return securityGroups(Output.of(securityGroups));
        }

        /**
         * @param securityGroups An array of one or more security group names
         * to associate with the server. Changing this results in adding/removing
         * security groups from the existing server. *Note*: When attaching the
         * instance to networks using Ports, place the security groups on the Port
         * and not the instance. *Note*: Names should be used and not ids, as ids
         * trigger unnecessary updates.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        /**
         * @param stopBeforeDestroy Whether to try stop instance gracefully
         * before destroying it, thus giving chance for guest OS daemons to stop correctly.
         * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
         * 
         * @return builder
         * 
         */
        public Builder stopBeforeDestroy(@Nullable Output<Boolean> stopBeforeDestroy) {
            $.stopBeforeDestroy = stopBeforeDestroy;
            return this;
        }

        /**
         * @param stopBeforeDestroy Whether to try stop instance gracefully
         * before destroying it, thus giving chance for guest OS daemons to stop correctly.
         * If instance doesn&#39;t stop within timeout, it will be destroyed anyway.
         * 
         * @return builder
         * 
         */
        public Builder stopBeforeDestroy(Boolean stopBeforeDestroy) {
            return stopBeforeDestroy(Output.of(stopBeforeDestroy));
        }

        /**
         * @param tags A set of string tags for the instance. Changing this
         * updates the existing instance tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags A set of string tags for the instance. Changing this
         * updates the existing instance tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags A set of string tags for the instance. Changing this
         * updates the existing instance tags.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param userData The user data to provide when launching the instance.
         * Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder userData(@Nullable Output<String> userData) {
            $.userData = userData;
            return this;
        }

        /**
         * @param userData The user data to provide when launching the instance.
         * Changing this creates a new server.
         * 
         * @return builder
         * 
         */
        public Builder userData(String userData) {
            return userData(Output.of(userData));
        }

        /**
         * @param vendorOptions Map of additional vendor-specific options.
         * Supported options are described below.
         * 
         * @return builder
         * 
         */
        public Builder vendorOptions(@Nullable Output<InstanceVendorOptionsArgs> vendorOptions) {
            $.vendorOptions = vendorOptions;
            return this;
        }

        /**
         * @param vendorOptions Map of additional vendor-specific options.
         * Supported options are described below.
         * 
         * @return builder
         * 
         */
        public Builder vendorOptions(InstanceVendorOptionsArgs vendorOptions) {
            return vendorOptions(Output.of(vendorOptions));
        }

        public InstanceArgs build() {
            return $;
        }
    }

}
