// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.openstack.containerinfra;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterTemplateArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterTemplateArgs Empty = new ClusterTemplateArgs();

    /**
     * The API server port for the Container
     * Orchestration Engine for this cluster template. Changing this updates the
     * API server port of the existing cluster template.
     * 
     */
    @Import(name="apiserverPort")
    private @Nullable Output<Integer> apiserverPort;

    /**
     * @return The API server port for the Container
     * Orchestration Engine for this cluster template. Changing this updates the
     * API server port of the existing cluster template.
     * 
     */
    public Optional<Output<Integer>> apiserverPort() {
        return Optional.ofNullable(this.apiserverPort);
    }

    /**
     * The distro for the cluster (fedora-atomic,
     * coreos, etc.). Changing this updates the cluster distro of the existing
     * cluster template.
     * 
     */
    @Import(name="clusterDistro")
    private @Nullable Output<String> clusterDistro;

    /**
     * @return The distro for the cluster (fedora-atomic,
     * coreos, etc.). Changing this updates the cluster distro of the existing
     * cluster template.
     * 
     */
    public Optional<Output<String>> clusterDistro() {
        return Optional.ofNullable(this.clusterDistro);
    }

    /**
     * The Container Orchestration Engine for this cluster
     * template. Changing this updates the engine of the existing cluster
     * template.
     * 
     */
    @Import(name="coe", required=true)
    private Output<String> coe;

    /**
     * @return The Container Orchestration Engine for this cluster
     * template. Changing this updates the engine of the existing cluster
     * template.
     * 
     */
    public Output<String> coe() {
        return this.coe;
    }

    /**
     * Address of the DNS nameserver that is used in
     * nodes of the cluster. Changing this updates the DNS nameserver of the
     * existing cluster template.
     * 
     */
    @Import(name="dnsNameserver")
    private @Nullable Output<String> dnsNameserver;

    /**
     * @return Address of the DNS nameserver that is used in
     * nodes of the cluster. Changing this updates the DNS nameserver of the
     * existing cluster template.
     * 
     */
    public Optional<Output<String>> dnsNameserver() {
        return Optional.ofNullable(this.dnsNameserver);
    }

    /**
     * Docker storage driver. Changing this
     * updates the Docker storage driver of the existing cluster template.
     * 
     */
    @Import(name="dockerStorageDriver")
    private @Nullable Output<String> dockerStorageDriver;

    /**
     * @return Docker storage driver. Changing this
     * updates the Docker storage driver of the existing cluster template.
     * 
     */
    public Optional<Output<String>> dockerStorageDriver() {
        return Optional.ofNullable(this.dockerStorageDriver);
    }

    /**
     * The size (in GB) of the Docker volume.
     * Changing this updates the Docker volume size of the existing cluster
     * template.
     * 
     */
    @Import(name="dockerVolumeSize")
    private @Nullable Output<Integer> dockerVolumeSize;

    /**
     * @return The size (in GB) of the Docker volume.
     * Changing this updates the Docker volume size of the existing cluster
     * template.
     * 
     */
    public Optional<Output<Integer>> dockerVolumeSize() {
        return Optional.ofNullable(this.dockerVolumeSize);
    }

    /**
     * The ID of the external network that will
     * be used for the cluster. Changing this updates the external network ID of
     * the existing cluster template.
     * 
     */
    @Import(name="externalNetworkId")
    private @Nullable Output<String> externalNetworkId;

    /**
     * @return The ID of the external network that will
     * be used for the cluster. Changing this updates the external network ID of
     * the existing cluster template.
     * 
     */
    public Optional<Output<String>> externalNetworkId() {
        return Optional.ofNullable(this.externalNetworkId);
    }

    /**
     * The fixed network that will be attached to the
     * cluster. Changing this updates the fixed network of the existing cluster
     * template.
     * 
     */
    @Import(name="fixedNetwork")
    private @Nullable Output<String> fixedNetwork;

    /**
     * @return The fixed network that will be attached to the
     * cluster. Changing this updates the fixed network of the existing cluster
     * template.
     * 
     */
    public Optional<Output<String>> fixedNetwork() {
        return Optional.ofNullable(this.fixedNetwork);
    }

    /**
     * The fixed subnet that will be attached to the
     * cluster. Changing this updates the fixed subnet of the existing cluster
     * template.
     * 
     */
    @Import(name="fixedSubnet")
    private @Nullable Output<String> fixedSubnet;

    /**
     * @return The fixed subnet that will be attached to the
     * cluster. Changing this updates the fixed subnet of the existing cluster
     * template.
     * 
     */
    public Optional<Output<String>> fixedSubnet() {
        return Optional.ofNullable(this.fixedSubnet);
    }

    /**
     * The flavor for the nodes of the cluster. Can be set via
     * the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
     * flavor of the existing cluster template.
     * 
     */
    @Import(name="flavor")
    private @Nullable Output<String> flavor;

    /**
     * @return The flavor for the nodes of the cluster. Can be set via
     * the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
     * flavor of the existing cluster template.
     * 
     */
    public Optional<Output<String>> flavor() {
        return Optional.ofNullable(this.flavor);
    }

    /**
     * Indicates whether created cluster should
     * create floating IP for every node or not. Changing this updates the
     * floating IP enabled attribute of the existing cluster template.
     * 
     */
    @Import(name="floatingIpEnabled")
    private @Nullable Output<Boolean> floatingIpEnabled;

    /**
     * @return Indicates whether created cluster should
     * create floating IP for every node or not. Changing this updates the
     * floating IP enabled attribute of the existing cluster template.
     * 
     */
    public Optional<Output<Boolean>> floatingIpEnabled() {
        return Optional.ofNullable(this.floatingIpEnabled);
    }

    /**
     * Indicates whether the ClusterTemplate is hidden or not.
     * Changing this updates the hidden attribute of the existing cluster
     * template.
     * 
     */
    @Import(name="hidden")
    private @Nullable Output<Boolean> hidden;

    /**
     * @return Indicates whether the ClusterTemplate is hidden or not.
     * Changing this updates the hidden attribute of the existing cluster
     * template.
     * 
     */
    public Optional<Output<Boolean>> hidden() {
        return Optional.ofNullable(this.hidden);
    }

    /**
     * The address of a proxy for receiving all HTTP
     * requests and relay them. Changing this updates the HTTP proxy address of
     * the existing cluster template.
     * 
     */
    @Import(name="httpProxy")
    private @Nullable Output<String> httpProxy;

    /**
     * @return The address of a proxy for receiving all HTTP
     * requests and relay them. Changing this updates the HTTP proxy address of
     * the existing cluster template.
     * 
     */
    public Optional<Output<String>> httpProxy() {
        return Optional.ofNullable(this.httpProxy);
    }

    /**
     * The address of a proxy for receiving all HTTPS
     * requests and relay them. Changing this updates the HTTPS proxy address of
     * the existing cluster template.
     * 
     */
    @Import(name="httpsProxy")
    private @Nullable Output<String> httpsProxy;

    /**
     * @return The address of a proxy for receiving all HTTPS
     * requests and relay them. Changing this updates the HTTPS proxy address of
     * the existing cluster template.
     * 
     */
    public Optional<Output<String>> httpsProxy() {
        return Optional.ofNullable(this.httpsProxy);
    }

    /**
     * The reference to an image that is used for nodes of the
     * cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
     * Changing this updates the image attribute of the existing cluster template.
     * 
     */
    @Import(name="image", required=true)
    private Output<String> image;

    /**
     * @return The reference to an image that is used for nodes of the
     * cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
     * Changing this updates the image attribute of the existing cluster template.
     * 
     */
    public Output<String> image() {
        return this.image;
    }

    /**
     * The insecure registry URL for the cluster
     * template. Changing this updates the insecure registry attribute of the
     * existing cluster template.
     * 
     */
    @Import(name="insecureRegistry")
    private @Nullable Output<String> insecureRegistry;

    /**
     * @return The insecure registry URL for the cluster
     * template. Changing this updates the insecure registry attribute of the
     * existing cluster template.
     * 
     */
    public Optional<Output<String>> insecureRegistry() {
        return Optional.ofNullable(this.insecureRegistry);
    }

    /**
     * The name of the Compute service SSH keypair.
     * Changing this updates the keypair of the existing cluster template.
     * 
     */
    @Import(name="keypairId")
    private @Nullable Output<String> keypairId;

    /**
     * @return The name of the Compute service SSH keypair.
     * Changing this updates the keypair of the existing cluster template.
     * 
     */
    public Optional<Output<String>> keypairId() {
        return Optional.ofNullable(this.keypairId);
    }

    /**
     * The list of key value pairs representing additional
     * properties of the cluster template. Changing this updates the labels of the
     * existing cluster template.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,Object>> labels;

    /**
     * @return The list of key value pairs representing additional
     * properties of the cluster template. Changing this updates the labels of the
     * existing cluster template.
     * 
     */
    public Optional<Output<Map<String,Object>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The flavor for the master nodes. Can be set via
     * the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
     * the master flavor of the existing cluster template.
     * 
     */
    @Import(name="masterFlavor")
    private @Nullable Output<String> masterFlavor;

    /**
     * @return The flavor for the master nodes. Can be set via
     * the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
     * the master flavor of the existing cluster template.
     * 
     */
    public Optional<Output<String>> masterFlavor() {
        return Optional.ofNullable(this.masterFlavor);
    }

    /**
     * Indicates whether created cluster should
     * has a loadbalancer for master nodes or not. Changing this updates the
     * attribute of the existing cluster template.
     * 
     */
    @Import(name="masterLbEnabled")
    private @Nullable Output<Boolean> masterLbEnabled;

    /**
     * @return Indicates whether created cluster should
     * has a loadbalancer for master nodes or not. Changing this updates the
     * attribute of the existing cluster template.
     * 
     */
    public Optional<Output<Boolean>> masterLbEnabled() {
        return Optional.ofNullable(this.masterLbEnabled);
    }

    /**
     * The name of the cluster template. Changing this updates
     * the name of the existing cluster template.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the cluster template. Changing this updates
     * the name of the existing cluster template.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The name of the driver for the container
     * network. Changing this updates the network driver of the existing cluster
     * template.
     * 
     */
    @Import(name="networkDriver")
    private @Nullable Output<String> networkDriver;

    /**
     * @return The name of the driver for the container
     * network. Changing this updates the network driver of the existing cluster
     * template.
     * 
     */
    public Optional<Output<String>> networkDriver() {
        return Optional.ofNullable(this.networkDriver);
    }

    /**
     * A comma-separated list of IP addresses that shouldn&#39;t
     * be used in the cluster. Changing this updates the no proxy list of the
     * existing cluster template.
     * 
     */
    @Import(name="noProxy")
    private @Nullable Output<String> noProxy;

    /**
     * @return A comma-separated list of IP addresses that shouldn&#39;t
     * be used in the cluster. Changing this updates the no proxy list of the
     * existing cluster template.
     * 
     */
    public Optional<Output<String>> noProxy() {
        return Optional.ofNullable(this.noProxy);
    }

    /**
     * Indicates whether cluster template should be public.
     * Changing this updates the public attribute of the existing cluster
     * template.
     * 
     */
    @Import(name="public")
    private @Nullable Output<Boolean> public_;

    /**
     * @return Indicates whether cluster template should be public.
     * Changing this updates the public attribute of the existing cluster
     * template.
     * 
     */
    public Optional<Output<Boolean>> public_() {
        return Optional.ofNullable(this.public_);
    }

    /**
     * The region in which to obtain the V1 Container Infra
     * client. A Container Infra client is needed to create a cluster template. If
     * omitted,the `region` argument of the provider is used. Changing this
     * creates a new cluster template.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region in which to obtain the V1 Container Infra
     * client. A Container Infra client is needed to create a cluster template. If
     * omitted,the `region` argument of the provider is used. Changing this
     * creates a new cluster template.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * Indicates whether Docker registry is enabled
     * in the cluster. Changing this updates the registry enabled attribute of the
     * existing cluster template.
     * 
     */
    @Import(name="registryEnabled")
    private @Nullable Output<Boolean> registryEnabled;

    /**
     * @return Indicates whether Docker registry is enabled
     * in the cluster. Changing this updates the registry enabled attribute of the
     * existing cluster template.
     * 
     */
    public Optional<Output<Boolean>> registryEnabled() {
        return Optional.ofNullable(this.registryEnabled);
    }

    /**
     * The server type for the cluster template. Changing
     * this updates the server type of the existing cluster template.
     * 
     */
    @Import(name="serverType")
    private @Nullable Output<String> serverType;

    /**
     * @return The server type for the cluster template. Changing
     * this updates the server type of the existing cluster template.
     * 
     */
    public Optional<Output<String>> serverType() {
        return Optional.ofNullable(this.serverType);
    }

    /**
     * Indicates whether the TLS should be disabled in
     * the cluster. Changing this updates the attribute of the existing cluster.
     * 
     */
    @Import(name="tlsDisabled")
    private @Nullable Output<Boolean> tlsDisabled;

    /**
     * @return Indicates whether the TLS should be disabled in
     * the cluster. Changing this updates the attribute of the existing cluster.
     * 
     */
    public Optional<Output<Boolean>> tlsDisabled() {
        return Optional.ofNullable(this.tlsDisabled);
    }

    /**
     * The name of the driver that is used for the
     * volumes of the cluster nodes. Changing this updates the volume driver of
     * the existing cluster template.
     * 
     */
    @Import(name="volumeDriver")
    private @Nullable Output<String> volumeDriver;

    /**
     * @return The name of the driver that is used for the
     * volumes of the cluster nodes. Changing this updates the volume driver of
     * the existing cluster template.
     * 
     */
    public Optional<Output<String>> volumeDriver() {
        return Optional.ofNullable(this.volumeDriver);
    }

    private ClusterTemplateArgs() {}

    private ClusterTemplateArgs(ClusterTemplateArgs $) {
        this.apiserverPort = $.apiserverPort;
        this.clusterDistro = $.clusterDistro;
        this.coe = $.coe;
        this.dnsNameserver = $.dnsNameserver;
        this.dockerStorageDriver = $.dockerStorageDriver;
        this.dockerVolumeSize = $.dockerVolumeSize;
        this.externalNetworkId = $.externalNetworkId;
        this.fixedNetwork = $.fixedNetwork;
        this.fixedSubnet = $.fixedSubnet;
        this.flavor = $.flavor;
        this.floatingIpEnabled = $.floatingIpEnabled;
        this.hidden = $.hidden;
        this.httpProxy = $.httpProxy;
        this.httpsProxy = $.httpsProxy;
        this.image = $.image;
        this.insecureRegistry = $.insecureRegistry;
        this.keypairId = $.keypairId;
        this.labels = $.labels;
        this.masterFlavor = $.masterFlavor;
        this.masterLbEnabled = $.masterLbEnabled;
        this.name = $.name;
        this.networkDriver = $.networkDriver;
        this.noProxy = $.noProxy;
        this.public_ = $.public_;
        this.region = $.region;
        this.registryEnabled = $.registryEnabled;
        this.serverType = $.serverType;
        this.tlsDisabled = $.tlsDisabled;
        this.volumeDriver = $.volumeDriver;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterTemplateArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterTemplateArgs $;

        public Builder() {
            $ = new ClusterTemplateArgs();
        }

        public Builder(ClusterTemplateArgs defaults) {
            $ = new ClusterTemplateArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param apiserverPort The API server port for the Container
         * Orchestration Engine for this cluster template. Changing this updates the
         * API server port of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder apiserverPort(@Nullable Output<Integer> apiserverPort) {
            $.apiserverPort = apiserverPort;
            return this;
        }

        /**
         * @param apiserverPort The API server port for the Container
         * Orchestration Engine for this cluster template. Changing this updates the
         * API server port of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder apiserverPort(Integer apiserverPort) {
            return apiserverPort(Output.of(apiserverPort));
        }

        /**
         * @param clusterDistro The distro for the cluster (fedora-atomic,
         * coreos, etc.). Changing this updates the cluster distro of the existing
         * cluster template.
         * 
         * @return builder
         * 
         */
        public Builder clusterDistro(@Nullable Output<String> clusterDistro) {
            $.clusterDistro = clusterDistro;
            return this;
        }

        /**
         * @param clusterDistro The distro for the cluster (fedora-atomic,
         * coreos, etc.). Changing this updates the cluster distro of the existing
         * cluster template.
         * 
         * @return builder
         * 
         */
        public Builder clusterDistro(String clusterDistro) {
            return clusterDistro(Output.of(clusterDistro));
        }

        /**
         * @param coe The Container Orchestration Engine for this cluster
         * template. Changing this updates the engine of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder coe(Output<String> coe) {
            $.coe = coe;
            return this;
        }

        /**
         * @param coe The Container Orchestration Engine for this cluster
         * template. Changing this updates the engine of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder coe(String coe) {
            return coe(Output.of(coe));
        }

        /**
         * @param dnsNameserver Address of the DNS nameserver that is used in
         * nodes of the cluster. Changing this updates the DNS nameserver of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder dnsNameserver(@Nullable Output<String> dnsNameserver) {
            $.dnsNameserver = dnsNameserver;
            return this;
        }

        /**
         * @param dnsNameserver Address of the DNS nameserver that is used in
         * nodes of the cluster. Changing this updates the DNS nameserver of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder dnsNameserver(String dnsNameserver) {
            return dnsNameserver(Output.of(dnsNameserver));
        }

        /**
         * @param dockerStorageDriver Docker storage driver. Changing this
         * updates the Docker storage driver of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder dockerStorageDriver(@Nullable Output<String> dockerStorageDriver) {
            $.dockerStorageDriver = dockerStorageDriver;
            return this;
        }

        /**
         * @param dockerStorageDriver Docker storage driver. Changing this
         * updates the Docker storage driver of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder dockerStorageDriver(String dockerStorageDriver) {
            return dockerStorageDriver(Output.of(dockerStorageDriver));
        }

        /**
         * @param dockerVolumeSize The size (in GB) of the Docker volume.
         * Changing this updates the Docker volume size of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder dockerVolumeSize(@Nullable Output<Integer> dockerVolumeSize) {
            $.dockerVolumeSize = dockerVolumeSize;
            return this;
        }

        /**
         * @param dockerVolumeSize The size (in GB) of the Docker volume.
         * Changing this updates the Docker volume size of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder dockerVolumeSize(Integer dockerVolumeSize) {
            return dockerVolumeSize(Output.of(dockerVolumeSize));
        }

        /**
         * @param externalNetworkId The ID of the external network that will
         * be used for the cluster. Changing this updates the external network ID of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder externalNetworkId(@Nullable Output<String> externalNetworkId) {
            $.externalNetworkId = externalNetworkId;
            return this;
        }

        /**
         * @param externalNetworkId The ID of the external network that will
         * be used for the cluster. Changing this updates the external network ID of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder externalNetworkId(String externalNetworkId) {
            return externalNetworkId(Output.of(externalNetworkId));
        }

        /**
         * @param fixedNetwork The fixed network that will be attached to the
         * cluster. Changing this updates the fixed network of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder fixedNetwork(@Nullable Output<String> fixedNetwork) {
            $.fixedNetwork = fixedNetwork;
            return this;
        }

        /**
         * @param fixedNetwork The fixed network that will be attached to the
         * cluster. Changing this updates the fixed network of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder fixedNetwork(String fixedNetwork) {
            return fixedNetwork(Output.of(fixedNetwork));
        }

        /**
         * @param fixedSubnet The fixed subnet that will be attached to the
         * cluster. Changing this updates the fixed subnet of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder fixedSubnet(@Nullable Output<String> fixedSubnet) {
            $.fixedSubnet = fixedSubnet;
            return this;
        }

        /**
         * @param fixedSubnet The fixed subnet that will be attached to the
         * cluster. Changing this updates the fixed subnet of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder fixedSubnet(String fixedSubnet) {
            return fixedSubnet(Output.of(fixedSubnet));
        }

        /**
         * @param flavor The flavor for the nodes of the cluster. Can be set via
         * the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
         * flavor of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder flavor(@Nullable Output<String> flavor) {
            $.flavor = flavor;
            return this;
        }

        /**
         * @param flavor The flavor for the nodes of the cluster. Can be set via
         * the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
         * flavor of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder flavor(String flavor) {
            return flavor(Output.of(flavor));
        }

        /**
         * @param floatingIpEnabled Indicates whether created cluster should
         * create floating IP for every node or not. Changing this updates the
         * floating IP enabled attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder floatingIpEnabled(@Nullable Output<Boolean> floatingIpEnabled) {
            $.floatingIpEnabled = floatingIpEnabled;
            return this;
        }

        /**
         * @param floatingIpEnabled Indicates whether created cluster should
         * create floating IP for every node or not. Changing this updates the
         * floating IP enabled attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder floatingIpEnabled(Boolean floatingIpEnabled) {
            return floatingIpEnabled(Output.of(floatingIpEnabled));
        }

        /**
         * @param hidden Indicates whether the ClusterTemplate is hidden or not.
         * Changing this updates the hidden attribute of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder hidden(@Nullable Output<Boolean> hidden) {
            $.hidden = hidden;
            return this;
        }

        /**
         * @param hidden Indicates whether the ClusterTemplate is hidden or not.
         * Changing this updates the hidden attribute of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder hidden(Boolean hidden) {
            return hidden(Output.of(hidden));
        }

        /**
         * @param httpProxy The address of a proxy for receiving all HTTP
         * requests and relay them. Changing this updates the HTTP proxy address of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder httpProxy(@Nullable Output<String> httpProxy) {
            $.httpProxy = httpProxy;
            return this;
        }

        /**
         * @param httpProxy The address of a proxy for receiving all HTTP
         * requests and relay them. Changing this updates the HTTP proxy address of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder httpProxy(String httpProxy) {
            return httpProxy(Output.of(httpProxy));
        }

        /**
         * @param httpsProxy The address of a proxy for receiving all HTTPS
         * requests and relay them. Changing this updates the HTTPS proxy address of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder httpsProxy(@Nullable Output<String> httpsProxy) {
            $.httpsProxy = httpsProxy;
            return this;
        }

        /**
         * @param httpsProxy The address of a proxy for receiving all HTTPS
         * requests and relay them. Changing this updates the HTTPS proxy address of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder httpsProxy(String httpsProxy) {
            return httpsProxy(Output.of(httpsProxy));
        }

        /**
         * @param image The reference to an image that is used for nodes of the
         * cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
         * Changing this updates the image attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder image(Output<String> image) {
            $.image = image;
            return this;
        }

        /**
         * @param image The reference to an image that is used for nodes of the
         * cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
         * Changing this updates the image attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder image(String image) {
            return image(Output.of(image));
        }

        /**
         * @param insecureRegistry The insecure registry URL for the cluster
         * template. Changing this updates the insecure registry attribute of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder insecureRegistry(@Nullable Output<String> insecureRegistry) {
            $.insecureRegistry = insecureRegistry;
            return this;
        }

        /**
         * @param insecureRegistry The insecure registry URL for the cluster
         * template. Changing this updates the insecure registry attribute of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder insecureRegistry(String insecureRegistry) {
            return insecureRegistry(Output.of(insecureRegistry));
        }

        /**
         * @param keypairId The name of the Compute service SSH keypair.
         * Changing this updates the keypair of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder keypairId(@Nullable Output<String> keypairId) {
            $.keypairId = keypairId;
            return this;
        }

        /**
         * @param keypairId The name of the Compute service SSH keypair.
         * Changing this updates the keypair of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder keypairId(String keypairId) {
            return keypairId(Output.of(keypairId));
        }

        /**
         * @param labels The list of key value pairs representing additional
         * properties of the cluster template. Changing this updates the labels of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,Object>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels The list of key value pairs representing additional
         * properties of the cluster template. Changing this updates the labels of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,Object> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param masterFlavor The flavor for the master nodes. Can be set via
         * the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
         * the master flavor of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder masterFlavor(@Nullable Output<String> masterFlavor) {
            $.masterFlavor = masterFlavor;
            return this;
        }

        /**
         * @param masterFlavor The flavor for the master nodes. Can be set via
         * the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
         * the master flavor of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder masterFlavor(String masterFlavor) {
            return masterFlavor(Output.of(masterFlavor));
        }

        /**
         * @param masterLbEnabled Indicates whether created cluster should
         * has a loadbalancer for master nodes or not. Changing this updates the
         * attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder masterLbEnabled(@Nullable Output<Boolean> masterLbEnabled) {
            $.masterLbEnabled = masterLbEnabled;
            return this;
        }

        /**
         * @param masterLbEnabled Indicates whether created cluster should
         * has a loadbalancer for master nodes or not. Changing this updates the
         * attribute of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder masterLbEnabled(Boolean masterLbEnabled) {
            return masterLbEnabled(Output.of(masterLbEnabled));
        }

        /**
         * @param name The name of the cluster template. Changing this updates
         * the name of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the cluster template. Changing this updates
         * the name of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkDriver The name of the driver for the container
         * network. Changing this updates the network driver of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder networkDriver(@Nullable Output<String> networkDriver) {
            $.networkDriver = networkDriver;
            return this;
        }

        /**
         * @param networkDriver The name of the driver for the container
         * network. Changing this updates the network driver of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder networkDriver(String networkDriver) {
            return networkDriver(Output.of(networkDriver));
        }

        /**
         * @param noProxy A comma-separated list of IP addresses that shouldn&#39;t
         * be used in the cluster. Changing this updates the no proxy list of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder noProxy(@Nullable Output<String> noProxy) {
            $.noProxy = noProxy;
            return this;
        }

        /**
         * @param noProxy A comma-separated list of IP addresses that shouldn&#39;t
         * be used in the cluster. Changing this updates the no proxy list of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder noProxy(String noProxy) {
            return noProxy(Output.of(noProxy));
        }

        /**
         * @param public_ Indicates whether cluster template should be public.
         * Changing this updates the public attribute of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder public_(@Nullable Output<Boolean> public_) {
            $.public_ = public_;
            return this;
        }

        /**
         * @param public_ Indicates whether cluster template should be public.
         * Changing this updates the public attribute of the existing cluster
         * template.
         * 
         * @return builder
         * 
         */
        public Builder public_(Boolean public_) {
            return public_(Output.of(public_));
        }

        /**
         * @param region The region in which to obtain the V1 Container Infra
         * client. A Container Infra client is needed to create a cluster template. If
         * omitted,the `region` argument of the provider is used. Changing this
         * creates a new cluster template.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region in which to obtain the V1 Container Infra
         * client. A Container Infra client is needed to create a cluster template. If
         * omitted,the `region` argument of the provider is used. Changing this
         * creates a new cluster template.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param registryEnabled Indicates whether Docker registry is enabled
         * in the cluster. Changing this updates the registry enabled attribute of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder registryEnabled(@Nullable Output<Boolean> registryEnabled) {
            $.registryEnabled = registryEnabled;
            return this;
        }

        /**
         * @param registryEnabled Indicates whether Docker registry is enabled
         * in the cluster. Changing this updates the registry enabled attribute of the
         * existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder registryEnabled(Boolean registryEnabled) {
            return registryEnabled(Output.of(registryEnabled));
        }

        /**
         * @param serverType The server type for the cluster template. Changing
         * this updates the server type of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder serverType(@Nullable Output<String> serverType) {
            $.serverType = serverType;
            return this;
        }

        /**
         * @param serverType The server type for the cluster template. Changing
         * this updates the server type of the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder serverType(String serverType) {
            return serverType(Output.of(serverType));
        }

        /**
         * @param tlsDisabled Indicates whether the TLS should be disabled in
         * the cluster. Changing this updates the attribute of the existing cluster.
         * 
         * @return builder
         * 
         */
        public Builder tlsDisabled(@Nullable Output<Boolean> tlsDisabled) {
            $.tlsDisabled = tlsDisabled;
            return this;
        }

        /**
         * @param tlsDisabled Indicates whether the TLS should be disabled in
         * the cluster. Changing this updates the attribute of the existing cluster.
         * 
         * @return builder
         * 
         */
        public Builder tlsDisabled(Boolean tlsDisabled) {
            return tlsDisabled(Output.of(tlsDisabled));
        }

        /**
         * @param volumeDriver The name of the driver that is used for the
         * volumes of the cluster nodes. Changing this updates the volume driver of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder volumeDriver(@Nullable Output<String> volumeDriver) {
            $.volumeDriver = volumeDriver;
            return this;
        }

        /**
         * @param volumeDriver The name of the driver that is used for the
         * volumes of the cluster nodes. Changing this updates the volume driver of
         * the existing cluster template.
         * 
         * @return builder
         * 
         */
        public Builder volumeDriver(String volumeDriver) {
            return volumeDriver(Output.of(volumeDriver));
        }

        public ClusterTemplateArgs build() {
            if ($.coe == null) {
                throw new MissingRequiredPropertyException("ClusterTemplateArgs", "coe");
            }
            if ($.image == null) {
                throw new MissingRequiredPropertyException("ClusterTemplateArgs", "image");
            }
            return $;
        }
    }

}
